<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【CMU 15-213 CSAPP】详解lab2——bomblab</title>
      <link href="/2024/02/10/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3lab2%E2%80%94%E2%80%94bomblab/"/>
      <url>/2024/02/10/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3lab2%E2%80%94%E2%80%94bomblab/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又是一个刚上手差点放弃的lab，一边看视频一边看书一边找资料，初窥门径知道gdb怎么用和汇编怎么看后就开始自己拆弹了</p><p>参考资料：</p><p>gdb命令：<a href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">Enscript Output (cmu.edu)</a></p><p>windows和linux读取换行符的转换问题：<a href="https://blog.csdn.net/hnxyxiaomeng/article/details/84979649">windows和linux下读取文件换行符的一个坑——\r\n和\n_linux unknown \r\n-CSDN博客</a></p><p>bomblab全攻略：<a href="https://www.bilibili.com/video/BV1vu411o7QP">【深入理解计算机系统 实验2 CSAPP】bomb lab 炸弹实验 CMU bomblab</a></p><h1 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h1><h2 id="0-实验热身"><a href="#0-实验热身" class="headerlink" title="0. 实验热身"></a>0. 实验热身</h2><h3 id="0-1-gdb命令"><a href="#0-1-gdb命令" class="headerlink" title="0.1 gdb命令"></a>0.1 gdb命令</h3><p>先圈一下一些重要的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">gdb，启动！</span></span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/bomb# gdb bomb</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印栈信息</span></span><br><span class="line">(gdb) info stack</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印寄存器的值</span></span><br><span class="line">(gdb) print $rax</span><br><span class="line">(gdb) p $rax</span><br><span class="line">(gdb) p /x $rip # 输出当前指令地址</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反汇编某个函数</span></span><br><span class="line">(gdb) disas funcName</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将输出信息保存到文件中（很好用，方便在文件看汇编</span></span><br><span class="line">(gdb) set logging file fileName</span><br><span class="line">(gdb) set logging on</span><br><span class="line">    # 反汇编某个函数</span><br><span class="line">(gdb) set logging off</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调试</span></span><br><span class="line">(gdb) break funcName #设置断点</span><br><span class="line">(gdb) run </span><br><span class="line">(gdb) layout asm # 显示汇编代码 ctrl+x+a退出</span><br></pre></td></tr></table></figure><h3 id="0-2-常用寄存器"><a href="#0-2-常用寄存器" class="headerlink" title="0.2 常用寄存器"></a>0.2 常用寄存器</h3><p><img src="/img/2024/02/register1.png" alt="register1.png"><br><img src="/img/2024/02/register2.png" alt="register2.png"></p><p>还有一个$rip保存指令地址</p><h3 id="0-3-保存答案"><a href="#0-3-保存答案" class="headerlink" title="0.3 保存答案"></a>0.3 保存答案</h3><p>bomb.c允许我们传入文件，文件包含已经破解的炸弹的密码，在调试后面的炸弹时就不需要反复输入了：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run ans.txt</span><br></pre></td></tr></table></figure></p><p>注意！！！如果是<strong>在wsl中访问windows</strong>的文件，会出现换行符的转换问题，导致程<strong>序读到的字符串比我们写的多出一个\r</strong>，解决方案如下：</p><p>用vim打开ans.txt<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/bomb# vim ans.txt</span><br></pre></td></tr></table></figure><br>输入以下命令<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">set</span> fileformat=unix</span><br><span class="line">:<span class="keyword">wq</span></span><br></pre></td></tr></table></figure><br>之后即可正常使用</p><h2 id="1-phase-1"><a href="#1-phase-1" class="headerlink" title="1. phase_1"></a>1. phase_1</h2><h3 id="1-1-对主函数反汇编"><a href="#1-1-对主函数反汇编" class="headerlink" title="1.1 对主函数反汇编"></a>1.1 对主函数反汇编</h3><p>先将主函数反汇编后保存在main.asm<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set logging file main.asm</span><br><span class="line">(gdb) set logging on</span><br><span class="line">(gdb) disas main</span><br><span class="line">(gdb) set logging off</span><br></pre></td></tr></table></figure></p><p>找到跟第一个炸弹有关的代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">; main.asm</span><br><span class="line">   0x0000000000400e2d &lt;+141&gt;:call   0x400b10 &lt;puts@plt&gt;</span><br><span class="line">   0x0000000000400e32 &lt;+146&gt;:call   0x40149e &lt;read_line&gt;</span><br><span class="line">   0x0000000000400e37 &lt;+151&gt;:mov    %rax,%rdi</span><br><span class="line">   0x0000000000400e3a &lt;+154&gt;:call   0x400ee0 &lt;phase_1&gt;</span><br></pre></td></tr></table></figure><br>我们知道%rax是存返回值的，%rdi是存第一个参数的，那么上述代码的意思，就是在read_line()中读到用户的输入，然后将这个输入返回，作为phase_1()的参数</p><h3 id="1-2-对phase-1-反汇编"><a href="#1-2-对phase-1-反汇编" class="headerlink" title="1.2 对phase_1()反汇编"></a>1.2 对phase_1()反汇编</h3><p>同理，对phase_1()反汇编，我们对其逐行解析一下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; phase_1.asm</span><br><span class="line">   0x0000000000400ee0 &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">   0x0000000000400ee4 &lt;+4&gt;:mov    $0x402400,%esi               ; 将常量赋给%esi</span><br><span class="line">   0x0000000000400ee9 &lt;+9&gt;:call   0x401338 &lt;strings_not_equal&gt; ; 调用函数比较两个字符串, 第一个参数是%edi, 第二个参数是%esi</span><br><span class="line">   0x0000000000400eee &lt;+14&gt;:test   %eax,%eax</span><br><span class="line">   0x0000000000400ef0 &lt;+16&gt;:je     0x400ef7 &lt;phase_1+23&gt;     ; 当两个字符串相等时，跳过炸弹爆炸(explode_bomb)</span><br><span class="line">   0x0000000000400ef2 &lt;+18&gt;:call   0x40143a &lt;explode_bomb&gt;         </span><br><span class="line">   0x0000000000400ef7 &lt;+23&gt;:add    $0x8,%rsp</span><br><span class="line">   0x0000000000400efb &lt;+27&gt;:ret    </span><br></pre></td></tr></table></figure><br>从上述分析可知，我们要输入一个字符串跟内存$0x402400处的字符串一样</p><p>那么先看一下这个字符串是什么：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">x/s 0xbffff890 Examine a string stored at 0xbffff890</span></span><br><span class="line">(gdb) x/s 0x402400</span><br><span class="line">0x402400:       &quot;Border relations with Canada have never been better.&quot;</span><br></pre></td></tr></table></figure><br>因此，密码就是：<strong>Border relations with Canada have never been better.</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/bomb# ./bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br></pre></td></tr></table></figure><h2 id="2-phase-2"><a href="#2-phase-2" class="headerlink" title="2. phase_2"></a>2. phase_2</h2><h3 id="2-1-分析read-six-numbers"><a href="#2-1-分析read-six-numbers" class="headerlink" title="2.1 分析read_six_numbers()"></a>2.1 分析read_six_numbers()</h3><p>一回生二回熟，对 <strong>phase_2()</strong> 反汇编，然后掐头去尾（忽略callee-saved register的保存复原操作），先看最前面的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">; phase_2.asm</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:sub    $0x28,%rsp</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:call   0x40145c &lt;read_six_numbers&gt;</span><br><span class="line">   0x0000000000400f0a &lt;+14&gt;:cmpl   $0x1,(%rsp)</span><br><span class="line">   0x0000000000400f0e &lt;+18&gt;:je     0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f10 &lt;+20&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f15 &lt;+25&gt;:jmp    0x400f30 &lt;phase_2+52&gt;</span><br><span class="line">   0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax</span><br><span class="line">   0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax</span><br><span class="line">   0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)</span><br><span class="line">   0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;  </span><br><span class="line">   0x0000000000400f20 &lt;+36&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">   0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx</span><br><span class="line">   0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx</span><br><span class="line">   0x0000000000400f2c &lt;+48&gt;:jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f2e &lt;+50&gt;:jmp    0x400f3c &lt;phase_2+64&gt;</span><br><span class="line">   0x0000000000400f30 &lt;+52&gt;:lea    0x4(%rsp),%rbx</span><br><span class="line">   0x0000000000400f35 &lt;+57&gt;:lea    0x18(%rsp),%rbp</span><br><span class="line">   0x0000000000400f3a &lt;+62&gt;:jmp    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">   0x0000000000400f3c &lt;+64&gt;:add    $0x28,%rsp</span><br></pre></td></tr></table></figure><p>看起来比phase_1()复杂得多，先看最前面吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; phase_2.asm</span><br><span class="line">   0x0000000000400efe &lt;+2&gt;:sub    $0x28,%rsp</span><br><span class="line">   0x0000000000400f02 &lt;+6&gt;:mov    %rsp,%rsi</span><br><span class="line">   0x0000000000400f05 &lt;+9&gt;:call   0x40145c &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure><p>这里为phase_2()申请了一段栈帧，然后调用read_six_numbers，第一个参数$rdi还是我们输入的字符串，<strong>第二个参数%rsi居然是phase_2()栈顶的位置</strong>！</p><p>那read_six_numbers干了什么？有些人能猜出来，我是没猜出来，可以对 <strong>read_six_numbers()</strong> 反汇编继续分析：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">; read_six_numbers.asm</span><br><span class="line">   0x000000000040145c &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">   0x0000000000401460 &lt;+4&gt;:mov    %rsi,%rdx        ; %rsi是phase_2()的栈帧的栈顶，我们记作p, 那么%rdx = p</span><br><span class="line">   0x0000000000401463 &lt;+7&gt;:lea    0x4(%rsi),%rcx   ; %rcx = p + 4</span><br><span class="line">   0x0000000000401467 &lt;+11&gt;:lea    0x14(%rsi),%rax   </span><br><span class="line">   0x000000000040146b &lt;+15&gt;:mov    %rax,0x8(%rsp)   ; 0x8(%rsp) = p + 0x14 = p + 20</span><br><span class="line">   0x0000000000401470 &lt;+20&gt;:lea    0x10(%rsi),%rax</span><br><span class="line">   0x0000000000401474 &lt;+24&gt;:mov    %rax,(%rsp)      ; (%rsp) = p + 0x10 = p + 16</span><br><span class="line">   0x0000000000401478 &lt;+28&gt;:lea    0xc(%rsi),%r9    ; %r9 = p + 0xc = p + 12</span><br><span class="line">   0x000000000040147c &lt;+32&gt;:lea    0x8(%rsi),%r8    ; %r8 = p + 8</span><br><span class="line">   0x0000000000401480 &lt;+36&gt;:mov    $0x4025c3,%esi   ; %esi为地址0x4025c3上的值, x/s 4025c3得&quot;%d %d %d %d %d %d&quot;</span><br><span class="line">   0x0000000000401485 &lt;+41&gt;:mov    $0x0,%eax        ; %eax = 0</span><br><span class="line">   </span><br><span class="line">   ; 重点来了，下面调用了sscanf()，在c语言中，这个函数读取一个字符串，将它格式化到其他参数中</span><br><span class="line">   ; 那么这个函数的参数是哪些？</span><br><span class="line">   ; 显然, 第一个参数 %edi 没改变过, 仍然是我们输入的字符串,</span><br><span class="line">   ; 第二个参数是%esi = &quot;%d %d %d %d %d %d&quot;, 也就是将我们的字符串格式化成六个十进制整型数字</span><br><span class="line">   ; 第三到六个参数依次为 %edx=p, %ecx=p+4, %r8=p+8, %r9=p+12</span><br><span class="line">   ; 从第七个参数开始不使用寄存器, 而是read_six_numbers()的栈帧, 如下:</span><br><span class="line">   ; 第七个参数 (%rsp)=p+16, 第八个参数0x8(%rsp)=p+20</span><br><span class="line">   ;</span><br><span class="line">   ; 总结: 也就是说, sscanf()从我们输入的字符串中读取六个十进制数, 然后存到phase_2()的栈帧中, </span><br><span class="line">   ; 栈顶存的第一个, 每+4位存一个</span><br><span class="line">   0x000000000040148a &lt;+46&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line"></span><br><span class="line">   0x000000000040148f &lt;+51&gt;:cmp    $0x5,%eax        ; sscanf()的返回值应该是匹配数</span><br><span class="line">   0x0000000000401492 &lt;+54&gt;:jg     0x401499 &lt;read_six_numbers+61&gt;  </span><br><span class="line">   0x0000000000401494 &lt;+56&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 如果没有六个数, 那么炸弹爆炸</span><br><span class="line">   0x0000000000401499 &lt;+61&gt;:add    $0x18,%rsp</span><br><span class="line">   0x000000000040149d &lt;+65&gt;:ret     </span><br></pre></td></tr></table></figure></p><p>省流：read_six_numbers()<strong>从我们输入的字符串中读取六个十进制数, 然后存到phase_2()的栈帧中</strong>, (%rsp)存第一个, 0x4(rsp)存第二个, …, 0x14(rsp)存第六个。</p><h3 id="2-2-分析phase-2-主体"><a href="#2-2-分析phase-2-主体" class="headerlink" title="2.2 分析phase_2()主体"></a>2.2 分析phase_2()主体</h3><p>接下来继续分析read_six_numbers()之后的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f0a &lt;+14&gt;:cmpl   $0x1,(%rsp)</span><br><span class="line">0x0000000000400f0e &lt;+18&gt;:je     0x400f30 &lt;phase_2+52&gt;  </span><br><span class="line">0x0000000000400f10 &lt;+20&gt;:call   0x40143a &lt;explode_bomb&gt;   ; (%rsp)不为1则引爆炸弹, 说明第一个数是1</span><br><span class="line"></span><br><span class="line">; 以下四段构成了一个循环: </span><br><span class="line">; for(%rbx=0x4(%rsp), %rbp=0x18(%rsp); %rbx != %rbp; %rbx += 4)&#123;</span><br><span class="line">;  %eax = -0x4(rbx);</span><br><span class="line">;  %eax += %eax</span><br><span class="line">;  if (*%rbx != %eax)</span><br><span class="line">;     explode_bomb();</span><br><span class="line">; &#125;</span><br><span class="line">0x0000000000400f15 &lt;+25&gt;:jmp    0x400f30 &lt;phase_2+52&gt;     ; 通过之后跳到phase_2+52</span><br><span class="line"></span><br><span class="line">0x0000000000400f17 &lt;+27&gt;:mov    -0x4(%rbx),%eax           ; %eax = -0x4(%rbx), 是第一个数, 也就是1</span><br><span class="line">0x0000000000400f1a &lt;+30&gt;:add    %eax,%eax                 ; %eax += %eax, 也就是翻倍</span><br><span class="line">0x0000000000400f1c &lt;+32&gt;:cmp    %eax,(%rbx)                </span><br><span class="line">0x0000000000400f1e &lt;+34&gt;:je     0x400f25 &lt;phase_2+41&gt;  </span><br><span class="line">0x0000000000400f20 &lt;+36&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 如果%rbx不等于两倍的-0x4(%rbx), bomb!</span><br><span class="line">0x0000000000400f25 &lt;+41&gt;:add    $0x4,%rbx                 ; %rbx += 0x4</span><br><span class="line"></span><br><span class="line">0x0000000000400f29 &lt;+45&gt;:cmp    %rbp,%rbx                 </span><br><span class="line">0x0000000000400f2c &lt;+48&gt;:jne    0x400f17 &lt;phase_2+27&gt;</span><br><span class="line">0x0000000000400f2e &lt;+50&gt;:jmp    0x400f3c &lt;phase_2+64&gt;     ; if(%rbx != %rbp) 跳转到phase_27, 也就是循环, 否则跳转到phase_2+64</span><br><span class="line"></span><br><span class="line">0x0000000000400f30 &lt;+52&gt;:lea    0x4(%rsp),%rbx            ; %rbx = 0x4(%rsp), 是第二个数的地址</span><br><span class="line">0x0000000000400f35 &lt;+57&gt;:lea    0x18(%rsp),%rbp           ; %rbp = 0x18(%rsp), 是第六个数的地址0x14(%rsp)再加4</span><br><span class="line">0x0000000000400f3a &lt;+62&gt;:jmp    0x400f17 &lt;phase_2+27&gt;     ; 初始化%rbx和%rbp后跳转到phase_2+27</span><br><span class="line"></span><br><span class="line">; 总结: 上述循环要求从第二个数开始到第六个数, 每个数都得是前一个数的两倍, </span><br><span class="line">; 也就是要求我们输入: 1 2 4 8 16 32</span><br><span class="line"></span><br><span class="line">0x0000000000400f3c &lt;+64&gt;:add    $0x28,%rsp</span><br><span class="line">0x0000000000400f40 &lt;+68&gt;:pop    %rbx</span><br><span class="line">0x0000000000400f41 &lt;+69&gt;:pop    %rbp</span><br><span class="line">0x0000000000400f42 &lt;+70&gt;:ret    </span><br></pre></td></tr></table></figure></p><p>省流：read_six_numbers()读取了六个数字, 而phase_2()中要求我们<strong>第一个数是1，且从第二个数开始，每个数需要是前一个数的两倍</strong>，故密码为：<strong>1 2 4 8 16 32</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/bomb# ./bomb</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br></pre></td></tr></table></figure></p><h2 id="3-phase-3"><a href="#3-phase-3" class="headerlink" title="3. phase_3"></a>3. phase_3</h2><p>对phase_3()反汇编，先看最前面：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f43 &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">0x0000000000400f47 &lt;+4&gt;:lea    0xc(%rsp),%rcx   ; 第四个参数是0xc(%rsp)</span><br><span class="line">0x0000000000400f4c &lt;+9&gt;:lea    0x8(%rsp),%rdx   ; 第三个参数是0x8(%rsp)</span><br><span class="line">0x0000000000400f51 &lt;+14&gt;:mov    $0x4025cf,%esi   ; 第二个参数是地址0x4025cf的值, x/s 0x4025cf得&quot;%d %d&quot;</span><br><span class="line">0x0000000000400f56 &lt;+19&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000400f5b &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;  ; 太熟悉了家人们</span><br><span class="line"></span><br><span class="line">0x0000000000400f60 &lt;+29&gt;:cmp    $0x1,%eax</span><br><span class="line">0x0000000000400f63 &lt;+32&gt;:jg     0x400f6a &lt;phase_3+39&gt;</span><br><span class="line">0x0000000000400f65 &lt;+34&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 没有读到两个数- &gt; bomb!</span><br></pre></td></tr></table></figure><br>省流：从我们输入的字符串中读取两个十进制数，<strong>第一个存储在0x8(%rsp)</strong>，<strong>第二个存储在0xc(%rsp)</strong></p><p>再往下面看：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f6a &lt;+39&gt;:cmpl   $0x7,0x8(%rsp)         </span><br><span class="line">0x0000000000400f6f &lt;+44&gt;:ja     0x400fad &lt;phase_3+106&gt;    ; 第一个数比7大就跳到phase_3+106 -&gt; bomb!</span><br><span class="line">0x0000000000400f71 &lt;+46&gt;:mov    0x8(%rsp),%eax      </span><br><span class="line">0x0000000000400f75 &lt;+50&gt;:jmp    *0x402470(,%rax,8)  ; 根据第一个数的值跳转到某个位置 相当于switch</span><br></pre></td></tr></table></figure><br>打印每个跳转地址：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p /x *(0x402470)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = 0x400f7c</span></span><br><span class="line">(gdb) p /x *(0x402470+1*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">3 = 0x400fb9</span></span><br><span class="line">(gdb) p /x *(0x402470+2*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">4 = 0x400f83</span></span><br><span class="line">(gdb) p /x *(0x402470+3*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">5 = 0x400f8a</span></span><br><span class="line">(gdb) p /x *(0x402470+4*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">6 = 0x400f91</span></span><br><span class="line">(gdb) p /x *(0x402470+5*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">7 = 0x400f98</span></span><br><span class="line">(gdb) p /x *(0x402470+6*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">8 = 0x400f9f</span></span><br><span class="line">(gdb) p /x *(0x402470+7*8)</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">9 = 0x400fa6</span></span><br></pre></td></tr></table></figure></p><p>将这些地址对应到语句中，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400f7c &lt;+57&gt;:mov    $0xcf,%eax          ; 0x8(%rsp) = 0</span><br><span class="line">0x0000000000400f81 &lt;+62&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400f83 &lt;+64&gt;:mov    $0x2c3,%eax         ; 0x8(%rsp) = 2</span><br><span class="line">0x0000000000400f88 &lt;+69&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400f8a &lt;+71&gt;:mov    $0x100,%eax         ; 0x8(%rsp) = 3</span><br><span class="line">0x0000000000400f8f &lt;+76&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400f91 &lt;+78&gt;:mov    $0x185,%eax         ; 0x8(%rsp) = 4</span><br><span class="line">0x0000000000400f96 &lt;+83&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400f98 &lt;+85&gt;:mov    $0xce,%eax          ; 0x8(%rsp) = 5</span><br><span class="line">0x0000000000400f9d &lt;+90&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400f9f &lt;+92&gt;:mov    $0x2aa,%eax         ; 0x8(%rsp) = 6</span><br><span class="line">0x0000000000400fa4 &lt;+97&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400fa6 &lt;+99&gt;:mov    $0x147,%eax         ; 0x8(%rsp) = 7</span><br><span class="line">0x0000000000400fab &lt;+104&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line"></span><br><span class="line">0x0000000000400fad &lt;+106&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line">0x0000000000400fb2 &lt;+111&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000400fb7 &lt;+116&gt;:jmp    0x400fbe &lt;phase_3+123&gt;</span><br><span class="line">0x0000000000400fb9 &lt;+118&gt;:mov    $0x137,%eax         ; 0x8(%rsp) = 1</span><br><span class="line"></span><br><span class="line">0x0000000000400fbe &lt;+123&gt;:cmp    0xc(%rsp),%eax      </span><br><span class="line">0x0000000000400fc2 &lt;+127&gt;:je     0x400fc9 &lt;phase_3+134&gt;</span><br><span class="line">0x0000000000400fc4 &lt;+129&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 当第二个数和%eax不相等时爆炸</span><br><span class="line"></span><br><span class="line">0x0000000000400fc9 &lt;+134&gt;:add    $0x18,%rsp</span><br><span class="line">0x0000000000400fcd &lt;+138&gt;:ret    </span><br></pre></td></tr></table></figure></p><p>省流：第一个数应该在[0, 7]，确定了第一个数是哪个，就会对应一个数作为第二个数，因此可以有八种答案：</p><div class="table-container"><table><thead><tr><th style="text-align:center">第一个数</th><th style="text-align:center">第二个数</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">207</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">311</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">707</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">256</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">389</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">206</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">682</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">327</td></tr></tbody></table></div><h2 id="4-phase-4"><a href="#4-phase-4" class="headerlink" title="4. phase_4"></a>4. phase_4</h2><p>我直接disas phase_4：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040100c &lt;+0&gt;:sub    $0x18,%rsp</span><br><span class="line">0x0000000000401010 &lt;+4&gt;:lea    0xc(%rsp),%rcx</span><br><span class="line">0x0000000000401015 &lt;+9&gt;:lea    0x8(%rsp),%rdx</span><br><span class="line">0x000000000040101a &lt;+14&gt;:mov    $0x4025cf,%esi   ；x/s 0x4025cf得&quot;%d %d&quot;</span><br><span class="line">0x000000000040101f &lt;+19&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000401024 &lt;+24&gt;:call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">0x0000000000401029 &lt;+29&gt;:cmp    $0x2,%eax</span><br><span class="line">0x000000000040102c &lt;+32&gt;:jne    0x401035 &lt;phase_4+41&gt;</span><br><span class="line"></span><br><span class="line">0x000000000040102e &lt;+34&gt;:cmpl   $0xe,0x8(%rsp)</span><br><span class="line">0x0000000000401033 &lt;+39&gt;:jbe    0x40103a &lt;phase_4+46&gt;  ; 第一个数要小于等于0xe 十进制为14</span><br><span class="line">0x0000000000401035 &lt;+41&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line"></span><br><span class="line">0x000000000040103a &lt;+46&gt;:mov    $0xe,%edx        ; 14是第三参数</span><br><span class="line">0x000000000040103f &lt;+51&gt;:mov    $0x0,%esi        ; 0是第二个参数</span><br><span class="line">0x0000000000401044 &lt;+56&gt;:mov    0x8(%rsp),%edi   ; 第一个数是第一个参数</span><br><span class="line">0x0000000000401048 &lt;+60&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">0x000000000040104d &lt;+65&gt;:test   %eax,%eax</span><br><span class="line">0x000000000040104f &lt;+67&gt;:jne    0x401058 &lt;phase_4+76&gt;  ; 返回值需要等于0</span><br><span class="line">0x0000000000401051 &lt;+69&gt;:cmpl   $0x0,0xc(%rsp)         ; 第二个数需要等于0</span><br><span class="line">0x0000000000401056 &lt;+74&gt;:je     0x40105d &lt;phase_4+81&gt;  </span><br><span class="line">0x0000000000401058 &lt;+76&gt;:call   0x40143a &lt;explode_bomb&gt;</span><br><span class="line"></span><br><span class="line">0x000000000040105d &lt;+81&gt;:add    $0x18,%rsp</span><br><span class="line">0x0000000000401061 &lt;+85&gt;:ret   </span><br></pre></td></tr></table></figure><br>省流：要求输入两个十进制数，第二个数必须是0，第一个数丢进func4后返回的结果也必须是0</p><p>接下来看func4，我直接disas func4：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000400fce &lt;+0&gt;:sub    $0x8,%rsp</span><br><span class="line">0x0000000000400fd2 &lt;+4&gt;:mov    %edx,%eax  </span><br><span class="line">0x0000000000400fd4 &lt;+6&gt;:sub    %esi,%eax  </span><br><span class="line">0x0000000000400fd6 &lt;+8&gt;:mov    %eax,%ecx  </span><br><span class="line">0x0000000000400fd8 &lt;+10&gt;:shr    $0x1f,%ecx </span><br><span class="line">0x0000000000400fdb &lt;+13&gt;:add    %ecx,%eax  </span><br><span class="line">0x0000000000400fdd &lt;+15&gt;:sar    %eax       </span><br><span class="line">0x0000000000400fdf &lt;+17&gt;:lea    (%rax,%rsi,1),%ecx </span><br><span class="line"></span><br><span class="line">0x0000000000400fe2 &lt;+20&gt;:cmp    %edi,%ecx</span><br><span class="line">0x0000000000400fe4 &lt;+22&gt;:jle    0x400ff2 &lt;func4+36&gt;</span><br><span class="line">0x0000000000400fe6 &lt;+24&gt;:lea    -0x1(%rcx),%edx  </span><br><span class="line"></span><br><span class="line">0x0000000000400fe9 &lt;+27&gt;:call   0x400fce &lt;func4&gt; </span><br><span class="line">0x0000000000400fee &lt;+32&gt;:add    %eax,%eax</span><br><span class="line">0x0000000000400ff0 &lt;+34&gt;:jmp    0x401007 &lt;func4+57&gt;</span><br><span class="line"></span><br><span class="line">0x0000000000400ff2 &lt;+36&gt;:mov    $0x0,%eax</span><br><span class="line">0x0000000000400ff7 &lt;+41&gt;:cmp    %edi,%ecx</span><br><span class="line">0x0000000000400ff9 &lt;+43&gt;:jge    0x401007 &lt;func4+57&gt;</span><br><span class="line">0x0000000000400ffb &lt;+45&gt;:lea    0x1(%rcx),%esi</span><br><span class="line">0x0000000000400ffe &lt;+48&gt;:call   0x400fce &lt;func4&gt;</span><br><span class="line">0x0000000000401003 &lt;+53&gt;:lea    0x1(%rax,%rax,1),%eax</span><br><span class="line"></span><br><span class="line">0x0000000000401007 &lt;+57&gt;:add    $0x8,%rsp</span><br><span class="line">0x000000000040100b &lt;+61&gt;:ret    </span><br></pre></td></tr></table></figure><br>我根据几个比较和跳转的关系把它们分成了几段，可以看到好几处<strong>递归调用</strong>，为了方便看，把三个参数%edi，%esi，%edx记作a，b，c，把%eax和%ecx记作x，y，写成c语言的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun4</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b=<span class="number">0</span>, <span class="type">int</span> c=<span class="number">14</span>)</span>&#123;</span><br><span class="line">   <span class="comment">// a 是我们输入的第一个数</span></span><br><span class="line">   <span class="comment">// 以下注释仅针对第一轮进入函数体</span></span><br><span class="line">   <span class="type">int</span> x = c - b;             <span class="comment">// x=14</span></span><br><span class="line">   <span class="type">int</span> y = (x &gt;= <span class="number">0</span>)? <span class="number">0</span> : <span class="number">-1</span>;  <span class="comment">// y=0</span></span><br><span class="line"></span><br><span class="line">   x = (x + y) / <span class="number">2</span>;           <span class="comment">// x=7</span></span><br><span class="line">   y= x + b;                  <span class="comment">// y=7</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(y &lt;= a)&#123;                <span class="comment">// a &gt;= 7 的时候进入</span></span><br><span class="line">      x = <span class="number">0</span>                   <span class="comment">// x=0, 而我们正需要返回值是0</span></span><br><span class="line">      <span class="keyword">if</span>(y &gt;= a)&#123;             <span class="comment">// 所以只要让 a &lt;=7 即 a = 7就能返回0</span></span><br><span class="line">         <span class="keyword">return</span> x;            <span class="comment">// 所以令 a = 7就能通过  </span></span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         b = y + <span class="number">1</span>            <span class="comment">// a &gt; 7时会走到这里</span></span><br><span class="line">         x = func4(a, b, c);     </span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span> * x + <span class="number">1</span>;    <span class="comment">// 返回一个奇数，不可能为0，因此a &gt; 7必爆</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;                     <span class="comment">// a &lt; 7的时候</span></span><br><span class="line">      c = y - <span class="number">1</span>;              </span><br><span class="line">      x = func4(a, b, c);     <span class="comment">// func4(a, 0, 6)</span></span><br><span class="line">      <span class="comment">// 我们这一轮是func4(a, 0, 14), 输入7能过</span></span><br><span class="line">      <span class="comment">// 同理, 下一轮是func4(a, 0, 6), 输入3能过</span></span><br><span class="line">      <span class="comment">// 再下一轮的c = 6/2-1 = 2, 输入1能过</span></span><br><span class="line">      <span class="comment">// 再下一轮的c = 2/2-1 = 0, 输入0能过</span></span><br><span class="line">      <span class="comment">// 再下一轮的c = 0/2-1 = -1， 不会走到这里, 而是走到返回奇数那里, 必爆 </span></span><br><span class="line">      <span class="comment">// 综上, 第一个数可以取7, 3, 1, 0</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span> * x;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过分析，第一个数可以取<strong>7或3或1或0</strong></p><p>其实在[0, 14]里面枚举也能暴力通过（小声</p><p>综上，答案共有四种，如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">第一个数</th><th style="text-align:center">第二个数</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table></div><h2 id="5-phase-5"><a href="#5-phase-5" class="headerlink" title="5. phase_5"></a>5. phase_5</h2><p>二话不说对phase_5反汇编。</p><p>然后看看头：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0x0000000000401062 &lt;+0&gt;:push   %rbx</span><br><span class="line">0x0000000000401063 &lt;+1&gt;:sub    $0x20,%rsp</span><br><span class="line">0x0000000000401067 &lt;+5&gt;:mov    %rdi,%rbx                 ; %rbx = %rdi为我们输入的字符串</span><br><span class="line">0x000000000040106a &lt;+8&gt;:mov    %fs:0x28,%rax</span><br><span class="line">0x0000000000401073 &lt;+17&gt;:mov    %rax,0x18(%rsp)</span><br><span class="line">0x0000000000401078 &lt;+22&gt;:xor    %eax,%eax                 ; 设置canary</span><br></pre></td></tr></table></figure><br>设置canary是为了防止缓冲区溢出，看看就行，重点注意到%rbx保存了我们输入的字符串</p><p>再往下看<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040107a &lt;+24&gt;:call   0x40131b &lt;string_length&gt;</span><br><span class="line">0x000000000040107f &lt;+29&gt;:cmp    $0x6,%eax</span><br><span class="line">0x0000000000401082 &lt;+32&gt;:je     0x4010d2 &lt;phase_5+112&gt;</span><br><span class="line">0x0000000000401084 &lt;+34&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 字符串长度不为6时爆炸</span><br><span class="line">0x0000000000401089 &lt;+39&gt;:jmp    0x4010d2 &lt;phase_5+112&gt;</span><br></pre></td></tr></table></figure><br>这里要求<strong>字符串长度等于6</strong>，然后跳转到phase_5+112，往下看<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x00000000004010d2 &lt;+112&gt;:mov    $0x0,%eax</span><br><span class="line">0x00000000004010d7 &lt;+117&gt;:jmp    0x40108b &lt;phase_5+41&gt;</span><br></pre></td></tr></table></figure><br>这里把%eax初始化为0，然后又跳转到phase_5+41，往上看<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">0x000000000040108b &lt;+41&gt;:movzbl (%rbx,%rax,1),%ecx        ; movzbl每次拷贝一个字节，%rbx是输入字符串   </span><br><span class="line"> 0x000000000040108f &lt;+45&gt;:mov    %cl,(%rsp)</span><br><span class="line"> 0x0000000000401092 &lt;+48&gt;:mov    (%rsp),%rdx               ; %rdx = %cl</span><br><span class="line"> 0x0000000000401096 &lt;+52&gt;:and    $0xf,%edx                 ; 只取最后四位, 比如a的ascii码为0x41, 就取1</span><br><span class="line"> 0x0000000000401099 &lt;+55&gt;:movzbl 0x4024b0(%rdx),%edx   </span><br><span class="line"> 0x00000000004010a0 &lt;+62&gt;:mov    %dl,0x10(%rsp,%rax,1)     </span><br><span class="line"> </span><br><span class="line"> ; (gdb) x/s 0x4024b0</span><br><span class="line"> ; 0x4024b0 &lt;array.3449&gt;:  &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br><span class="line"> ; 只用看前面16位字母 maduiersnfotvbyl</span><br><span class="line"> ; 以%dl为下标，取一个字符压入栈中</span><br><span class="line"></span><br><span class="line"> 0x00000000004010a4 &lt;+66&gt;:add    $0x1,%rax</span><br><span class="line"> 0x00000000004010a8 &lt;+70&gt;:cmp    $0x6,%rax</span><br><span class="line"> 0x00000000004010ac &lt;+74&gt;:jne    0x40108b &lt;phase_5+41&gt;     ; 循环条件, 共走六遍</span><br><span class="line"></span><br><span class="line"> 0x00000000004010ae &lt;+76&gt;:movb   $0x0,0x16(%rsp)           ; 字符&#x27;\0&#x27;压入栈中</span><br><span class="line"> 0x00000000004010b3 &lt;+81&gt;:mov    $0x40245e,%esi            ; x/s 0x40245e得&quot;flyers&quot;</span><br><span class="line"> 0x00000000004010b8 &lt;+86&gt;:lea    0x10(%rsp),%rdi</span><br><span class="line"> 0x00000000004010bd &lt;+91&gt;:call   0x401338 &lt;strings_not_equal&gt;</span><br><span class="line"> 0x00000000004010c2 &lt;+96&gt;:test   %eax,%eax</span><br><span class="line"> 0x00000000004010c4 &lt;+98&gt;:je     0x4010d9 &lt;phase_5+119&gt;</span><br><span class="line"> 0x00000000004010c6 &lt;+100&gt;:call   0x40143a &lt;explode_bomb&gt;   ; 不等于这个字符串 -&gt; bomb! </span><br><span class="line"></span><br><span class="line"> ; 为了使压入栈中的字符串为flyers, 那么我们输入的字符串中的每个字符, 按十六进制的最后一位应该为：</span><br><span class="line"> ; 9fe567</span><br><span class="line"> ; 查询ASCII码表格就能组合出多种答案，如：ionefg, yonuvw</span><br></pre></td></tr></table></figure><br>省流：从phase_5+41到phase_5+74构成了一个循环，依次取出我们输入的字符串的每一个字符，用<strong>这个字符的编码值 mod 0x10作下标</strong>去取一个常量字符串”maduiersnfotvbyl”中的一个字符压入栈中，最后要求栈中<strong>字符串为”flyers”</strong></p><p>更直观地用c语言表述如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// input为我们输入的字符串, stack为栈, str为常量字符串</span><br><span class="line"></span><br><span class="line">cosnt char str[17] = &quot;maduiersnfotvbyl&quot;   // 其实后面还有字符但是不用管</span><br><span class="line">for(int i = 0; i != 6; ++i)&#123;</span><br><span class="line">   stack[i] = str[input[i] % 0x10];</span><br><span class="line">&#125;</span><br><span class="line">if(strcmp(stack, &quot;flyers&quot;))&#123;</span><br><span class="line">   // 如果stack中的字符串不等于&quot;flyers&quot;</span><br><span class="line">   explode_bomb();</span><br><span class="line">&#125;</span><br><span class="line">return ;</span><br></pre></td></tr></table></figure></p><p>查询ascii码对照表可以有多个答案，如：<br><strong>ionefg</strong><br><strong>yonuvw</strong><br><strong>9?&gt;%&amp;’</strong></p><h2 id="6-phase-6"><a href="#6-phase-6" class="headerlink" title="6. phase_6"></a>6. phase_6</h2><p>phase_6有些太复杂了。。。详细过程可以参考前言挂的b站视频</p><p>大概就是：</p><p>内存里有一条链表：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/24 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:       332     1       6304480 0</span><br><span class="line">0x6032e0 &lt;node2&gt;:       168     2       6304496 0</span><br><span class="line">0x6032f0 &lt;node3&gt;:       924     3       6304512 0</span><br><span class="line">0x603300 &lt;node4&gt;:       691     4       6304528 0</span><br><span class="line">0x603310 &lt;node5&gt;:       477     5       6304544 0</span><br><span class="line">0x603320 &lt;node6&gt;:       443     6       0       0</span><br></pre></td></tr></table></figure></p><p>然后你需要<strong>输入六个数字</strong>，<strong>根据这六个数字重新组合</strong>这条链表：<br>假设第一个数字为x，那么重组后的链表第一个节点为内存中链表的第7 - x个节点</p><p>然后遍历链表，当<strong>链表的值是降序</strong>时，可以通过，因此，节点应该是内存中第<br>3 4 5 6 1 2 个节点</p><p>故我们需要输入的数字为：<strong>4 3 2 1 6 5</strong></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ans.txt如下能通过<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">7 327</span><br><span class="line">7 0</span><br><span class="line">9?&gt;%&amp;&#x27;</span><br><span class="line">4 3 2 1 6 5</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/bomb# ./bomb ans.txt</span><br><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">That&#x27;s number 2.  Keep going!</span><br><span class="line">Halfway there!</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">Congratulations! You&#x27;ve defused the bomb!</span><br></pre></td></tr></table></figure></p><p>磕磕绊绊总算都过了，有点可惜没能赶在龙年到来之前发出这篇题解（是谁除夕夜打lab啊</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 汇编语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【CMU 15-213 CSAPP】详解lab1——datalab</title>
      <link href="/2024/02/05/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3lab1%E2%80%94%E2%80%94datalab/"/>
      <url>/2024/02/05/%E3%80%90CMU%2015-213%20CSAPP%E3%80%91%E8%AF%A6%E8%A7%A3lab1%E2%80%94%E2%80%94datalab/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终于开始学大名鼎鼎的CSAPP，一开始配环境就把我配得想退坑。。幸亏配好了</p><p>lab1真的很难想，实在想不出来就瞅眼别人的思路，然后又再嗯造自己的</p><p>所有注释都是作者一点一点想一点一点敲出来的喵</p><p>环境配置参考：<br><a href="https://blog.csdn.net/qq_40856284/article/details/122164149">CSAPP LAB —— 0. 实验环境搭建_何人听我楚狂声 csdn-CSDN博客</a></p><p>代码思路参考：<br><a href="https://zhuanlan.zhihu.com/p/59534845">CSAPP 之 DataLab详解，没有比这更详细的了 - 知乎 (zhihu.com)</a><br><a href="https://zhuanlan.zhihu.com/p/278569370">cSAPP lab1 datalab - 知乎 (zhihu.com)</a></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><h2 id="1-bitXor"><a href="#1-bitXor" class="headerlink" title="1. bitXor"></a>1. bitXor</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitXor - x^y using only ~ and &amp; </span></span><br><span class="line"><span class="comment"> *   Example: bitXor(4, 5) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp;</span></span><br><span class="line"><span class="comment"> *   Max ops: 14</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bitXor</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="comment">// 按位异或 即 (x &amp; y) | (~x &amp; ~y)</span></span><br><span class="line">  <span class="comment">// 由德摩根律</span></span><br><span class="line">  <span class="keyword">return</span> (~(x &amp; y)) &amp; (~(~x &amp; ~y)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-tmin"><a href="#2-tmin" class="headerlink" title="2. tmin"></a>2. tmin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two&#x27;s complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tmin</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// int 占 4 bite即 32 bit</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-isTmax"><a href="#3-isTmax" class="headerlink" title="3. isTmax"></a>3. isTmax</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * isTmax - returns 1 if x is the maximum, two&#x27;s complement number,</span></span><br><span class="line"><span class="comment"> *     and 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | +</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isTmax</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 当x = 0111 1111时，令y = ~x = 1000 0000，则有 2y = 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 但是, 令2y = 0，得y = 1000 0000 或 0000 0000</span></span><br><span class="line">  <span class="comment">// 1000 0000对应的x为 0111 1111，0000 0000对应的x为1111 1111</span></span><br><span class="line">  <span class="comment">// 即，当x = 1111 1111 时，y = 0000 0000，也有 2y = 0</span></span><br><span class="line">  <span class="comment">// 因此需要构造条件过滤x = 1111 1111 的情况</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 令z = !y，当x = 0111 1111时，z = 0, 当x = 1111 1111时，z = 1</span></span><br><span class="line">  <span class="comment">// 因此只有当x = 0111 1111时，才有2y + z = 0</span></span><br><span class="line">  <span class="type">int</span> y = ~x; </span><br><span class="line">  <span class="type">int</span> z = !y; </span><br><span class="line">  <span class="keyword">return</span> !(y + y + z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-allOddBits"><a href="#4-allOddBits" class="headerlink" title="4. allOddBits"></a>4. allOddBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * allOddBits - return 1 if all odd-numbered bits in word set to 1</span></span><br><span class="line"><span class="comment"> *   where bits are numbered from 0 (least significant) to 31 (most significant)</span></span><br><span class="line"><span class="comment"> *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">allOddBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 0x55 = 0101 0101 所有偶数位为1</span></span><br><span class="line">  <span class="comment">// x | 0x55555555 中偶数位全为1，</span></span><br><span class="line">  <span class="comment">// 那么，当且仅当x的奇数位全为1时，结果为0xffffffff</span></span><br><span class="line">  <span class="comment">// 对0xffffffff按位取反得0，再取反得到真</span></span><br><span class="line">  <span class="type">int</span> temp = <span class="number">0x55</span>;</span><br><span class="line">  temp = temp + (temp &lt;&lt; <span class="number">8</span>);</span><br><span class="line">  temp = temp + (temp &lt;&lt; <span class="number">16</span>);</span><br><span class="line">  <span class="keyword">return</span> !~(x | temp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0x55555555 其实也是 ~(0xAAAAAAAA)，按照德摩根律</span></span><br><span class="line">  <span class="comment">// return !(~x &amp; 0xAAAAAAAA);</span></span><br><span class="line">  <span class="comment">// 这种写法也是正确的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-negate"><a href="#5-negate" class="headerlink" title="5. negate"></a>5. negate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">negate</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 求负数得操作是取反加一</span></span><br><span class="line">  <span class="comment">// 取反：1111 1111 - x = -1 -x</span></span><br><span class="line">  <span class="comment">// 加一：(-1 - x) + 1 = -x</span></span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-isAsciiDigit"><a href="#6-isAsciiDigit" class="headerlink" title="6. isAsciiDigit"></a>6. isAsciiDigit</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#x27;0&#x27; to &#x27;9&#x27;)</span></span><br><span class="line"><span class="comment"> *   Example: isAsciiDigit(0x35) = 1.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x3a) = 0.</span></span><br><span class="line"><span class="comment"> *            isAsciiDigit(0x05) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isAsciiDigit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果 x &gt;= 0x30 &amp;&amp; x &lt;= 0x39</span></span><br><span class="line">  <span class="comment">// 那么 x - 0x30 &gt;= 0, x - 0x39  &lt;= 0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// x - 0x30 &gt;= 0, x - 0x39 - 1 &lt; 0</span></span><br><span class="line">  <span class="comment">// 又 -0x30 = ~0x30 + 1, -0x39 = ~0x39 + 1</span></span><br><span class="line">  <span class="comment">// 即 (x + ~0x30 + 1) &gt;&gt; 31 = 0, (x + ~0x39) &gt;&gt; 31 = -1  </span></span><br><span class="line">  <span class="comment">// 注意：c语言右移补符号位(坑死我了)</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> judgeUpper = (x + ~<span class="number">0x39</span>) &gt;&gt; <span class="number">31</span>; </span><br><span class="line">  <span class="type">int</span> judgeLower = (x + ~<span class="number">0x30</span> + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> !(~judgeUpper | judgeLower); <span class="comment">//当且仅当judgeUpper为-1而且judgeLower为0时,返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-conditional"><a href="#7-conditional" class="headerlink" title="7. conditional"></a>7. conditional</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * conditional - same as x ? y : z </span></span><br><span class="line"><span class="comment"> *   Example: conditional(2,4,5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 16</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">conditional</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span> &#123;</span><br><span class="line">  <span class="comment">// 先得到x的布尔值：0或者1：x = !!x</span></span><br><span class="line">  <span class="comment">// 全0或全1会更好处理，全0就是0，全1是-1</span></span><br><span class="line">  <span class="comment">// 取反加一得相反数：x = ~x + 1 </span></span><br><span class="line"></span><br><span class="line">  x = ~(!!x) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (x &amp; y) | (~x &amp; z);  <span class="comment">//确实很牛逼</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-isLessOrEqual"><a href="#8-isLessOrEqual" class="headerlink" title="8. isLessOrEqual"></a>8. isLessOrEqual</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isLessOrEqual</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">  <span class="comment">// 跟isAsciiDigit差不多</span></span><br><span class="line">  <span class="comment">// x &lt;= y 得 x - y &lt;= 0  得 x + ~y &lt; 0 得(x + ~y) &gt;&gt; 31 = -1</span></span><br><span class="line">  <span class="comment">// 当 x 和 y 同号时 两数相减不会出现溢出 异号则会 所以需要判断符号</span></span><br><span class="line">  <span class="type">int</span> flag = (x ^ y) &gt;&gt; <span class="number">31</span>; <span class="comment">// x y同号时，flag = 00..00 否则为 11..11</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 x 和 y 同号时</span></span><br><span class="line">  <span class="type">int</span> signEq = !~((x + ~y) &gt;&gt; <span class="number">31</span> );  <span class="comment">// 满足 x &lt;= y 时 signEq = 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 x 和 y 不同号时，y是正数时返回true</span></span><br><span class="line">  <span class="type">int</span> signNeq = !(y &gt;&gt; <span class="number">31</span>);           <span class="comment">// 满足 x &lt;= y 时 signNeq = 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 flag = 00..00，flag &amp; signEq = signEq, ~flag &amp; signNeq = 0, 结果为signEq</span></span><br><span class="line">  <span class="comment">// 当 flag = 11..11，flag &amp; signEq = 0, ~flag &amp; signNeq = signNeq, 结果为signNeq</span></span><br><span class="line">  <span class="keyword">return</span> (~flag &amp; signEq) | (flag &amp; signNeq); <span class="comment">// 受conditional的启发，很牛逼(再次)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-logicalNeg"><a href="#9-logicalNeg" class="headerlink" title="9. logicalNeg"></a>9. logicalNeg</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalNeg - implement the ! operator, using all of </span></span><br><span class="line"><span class="comment"> *              the legal operators except !</span></span><br><span class="line"><span class="comment"> *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">logicalNeg</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0要变成1，直接加一呗</span></span><br><span class="line">  <span class="comment">// 其他数要变成0，还得跟上述操作兼容qwq</span></span><br><span class="line">  <span class="comment">// 思路：有一个操作能使0变成0，除了0的其他所有数变成-1，得到的结果再加一</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当x不为0时, x | -x 符号为一定为1, 再右移31位得到-1</span></span><br><span class="line">  <span class="comment">// 当x为0时, x | -x = 0, 右移31位还是0</span></span><br><span class="line">  <span class="keyword">return</span> ((x | (~x + <span class="number">1</span>)) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-howManyBits"><a href="#10-howManyBits" class="headerlink" title="10. howManyBits"></a>10. howManyBits</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* howManyBits - return the minimum number of bits required to represent x in</span></span><br><span class="line"><span class="comment"> *             two&#x27;s complement</span></span><br><span class="line"><span class="comment"> *  Examples: howManyBits(12) = 5</span></span><br><span class="line"><span class="comment"> *            howManyBits(298) = 10</span></span><br><span class="line"><span class="comment"> *            howManyBits(-5) = 4</span></span><br><span class="line"><span class="comment"> *            howManyBits(0)  = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(-1) = 1</span></span><br><span class="line"><span class="comment"> *            howManyBits(0x80000000) = 32</span></span><br><span class="line"><span class="comment"> *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *  Max ops: 90</span></span><br><span class="line"><span class="comment"> *  Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 101 表示 -4+2+1 = -3, 1101表示 -8+4+2+1 = -3, 11101表示 -16+8+4+2+1 = -3</span></span><br><span class="line">  <span class="comment">// 由此可见, 在负数的补码前面加很多位1, 得到的值是一样的, </span></span><br><span class="line">  <span class="comment">// 同理, 去掉前面重复的1，所表达的值也是一样的</span></span><br><span class="line">  <span class="comment">// 因此, 负数找最高位0就能确定需要多少位就能表达这个数</span></span><br><span class="line">  <span class="comment">// 总之：正数找最高位1，负数找最高位0</span></span><br><span class="line">  <span class="type">int</span> b_0, b_1, b_2, b_4, b_8, b_16;</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>; </span><br><span class="line">  x = (~sign &amp; x) | (sign &amp; ~x); <span class="comment">// 正数负数统一处理, 转化为找x的最高位1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 别人的办法真是十分巧妙啊（</span></span><br><span class="line">  b_16 = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>;  <span class="comment">// b_16 = (高16位有1)? 16 : 0</span></span><br><span class="line">  x = x &gt;&gt; b_16;            <span class="comment">// 高16位有1就继续看高16位, 没有就看后面的</span></span><br><span class="line">  b_8 = !!(x &gt;&gt; <span class="number">8</span>) &lt;&lt; <span class="number">3</span>;    <span class="comment">// 同理 b_8 = (高8位有1)? 8 : 0</span></span><br><span class="line">  x = x &gt;&gt; b_8;</span><br><span class="line">  b_4 = !!(x &gt;&gt; <span class="number">4</span>) &lt;&lt; <span class="number">2</span>;    </span><br><span class="line">  x = x &gt;&gt; b_4;</span><br><span class="line">  b_2 = !!(x &gt;&gt; <span class="number">2</span>) &lt;&lt; <span class="number">1</span>;    </span><br><span class="line">  x = x &gt;&gt; b_2;</span><br><span class="line">  b_1 = !!(x &gt;&gt; <span class="number">1</span>);         </span><br><span class="line">  x = x &gt;&gt; b_1;</span><br><span class="line">  b_0 = x;                  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> + b_0 + b_1 + b_2 + b_4 + b_8 + b_16;  <span class="comment">// 1 是符号位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-floatScale2"><a href="#11-floatScale2" class="headerlink" title="11. floatScale2"></a>11. floatScale2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatScale2 - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatScale2</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="comment">// 单精度浮点数32位 符号位1 指数位8 数值位23</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取符号, 铁定用的着</span></span><br><span class="line">  <span class="type">int</span> filter = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> sign = uf &amp; filter ; </span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先判断传入的值是否为非规格化值, 进行特殊处理</span></span><br><span class="line">  <span class="comment">// 只看指数位：(filter &gt;&gt; 8) ^ filter = 0111 1111 1000 00..</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (((filter &gt;&gt; <span class="number">8</span>) ^ filter) &amp; uf) &gt;&gt; <span class="number">23</span>;   </span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">exp</span>)</span><br><span class="line">    <span class="keyword">return</span> (uf &lt;&lt; <span class="number">1</span>) | sign;  <span class="comment">// 指数为为0, 可以向指数为1平滑转化, 太绝了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">exp</span> == <span class="number">255</span>)</span><br><span class="line">    <span class="keyword">return</span> uf;</span><br><span class="line"></span><br><span class="line">  ++<span class="built_in">exp</span>;                      <span class="comment">// 指数+1就是把值乘2</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> == <span class="number">255</span>)</span><br><span class="line">    <span class="keyword">return</span> ((filter &gt;&gt; <span class="number">8</span>) ^ filter) | sign; <span class="comment">// 判断越界</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取数值位</span></span><br><span class="line">  val = ~(filter &gt;&gt; <span class="number">8</span>) &amp; uf;</span><br><span class="line">  <span class="keyword">return</span> sign | (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) | val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-floatFloat2Int"><a href="#12-floatFloat2Int" class="headerlink" title="12. floatFloat2Int"></a>12. floatFloat2Int</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatFloat2Int - Return bit-level equivalent of expression (int) f</span></span><br><span class="line"><span class="comment"> *   for floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Argument is passed as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point value.</span></span><br><span class="line"><span class="comment"> *   Anything out of range (including NaN and infinity) should return</span></span><br><span class="line"><span class="comment"> *   0x80000000u.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">floatFloat2Int</span><span class="params">(<span class="type">unsigned</span> uf)</span> &#123;</span><br><span class="line">  <span class="comment">// 同上, 先判断非规格化值</span></span><br><span class="line">  <span class="type">int</span> filter = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">  <span class="comment">// int sign = uf &amp; filter;</span></span><br><span class="line">  <span class="type">int</span> <span class="built_in">exp</span> = (((filter &gt;&gt; <span class="number">8</span>) ^ filter) &amp; uf) &gt;&gt; <span class="number">23</span>;</span><br><span class="line">  <span class="type">int</span> val, sign;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exp</span> = <span class="built_in">exp</span> - <span class="number">127</span>;  <span class="comment">// 添加bias </span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> &gt; <span class="number">31</span>)</span><br><span class="line">    <span class="keyword">return</span> filter;  <span class="comment">// 超过int范围的数按要求返回0x800..00u 包括inf和NaN</span></span><br><span class="line"></span><br><span class="line">  val = (~(filter &gt;&gt; <span class="number">8</span>) &amp; uf) | (<span class="number">1</span> &lt;&lt; <span class="number">23</span>); <span class="comment">// 取数值位, 加上隐藏的1</span></span><br><span class="line">  <span class="comment">// 这里的val已经是1.*** 小数点向右移了23位的结果了, 因此只需要再向右移exp - 23 位</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span> &gt; <span class="number">23</span>)</span><br><span class="line">    val = val &lt;&lt; (<span class="built_in">exp</span> - <span class="number">23</span>);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    val = val &gt;&gt; (<span class="number">23</span> - <span class="built_in">exp</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 负数用补码表示</span></span><br><span class="line">  sign = filter &amp; uf;</span><br><span class="line">  <span class="keyword">if</span>(!sign)</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> ~val + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-floatPower2"><a href="#13-floatPower2" class="headerlink" title="13. floatPower2"></a>13. floatPower2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * floatPower2 - Return bit-level equivalent of the expression 2.0^x</span></span><br><span class="line"><span class="comment"> *   (2.0 raised to the power x) for any 32-bit integer x.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   The unsigned value that is returned should have the identical bit</span></span><br><span class="line"><span class="comment"> *   representation as the single-precision floating-point number 2.0^x.</span></span><br><span class="line"><span class="comment"> *   If the result is too small to be represented as a denorm, return</span></span><br><span class="line"><span class="comment"> *   0. If too large, return +INF.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while </span></span><br><span class="line"><span class="comment"> *   Max ops: 30 </span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="comment">// 求2^x = 1.0 * 2^x, 数值部分为0, 指数部分为x</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// float 不能超过 2^127</span></span><br><span class="line">  <span class="comment">// x过大使超过浮点数表示范围时, 按要求返回inf = 0x7f800000</span></span><br><span class="line">  <span class="comment">// x过小按要求返回0</span></span><br><span class="line">  <span class="keyword">if</span>(x &gt; <span class="number">127</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt; <span class="number">-126</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ((x + <span class="number">127</span>) &lt;&lt; <span class="number">23</span>) ; <span class="comment">// 注意加上bias = 127</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@Andrew:/mnt/d/.c/csapp/datalab-handout# ./dlc bits.c</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/datalab-handout# make clean</span><br><span class="line">rm -f *.o btest fshow ishow *~</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/datalab-handout# make ./btest</span><br><span class="line">gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c</span><br><span class="line">btest.c: In function ‘test_function’:</span><br><span class="line">btest.c:334:23: warning: ‘arg_test_range’ may be used uninitialized [-Wmaybe-uninitialized]</span><br><span class="line">  334 |     if (arg_test_range[2] &lt; 1)</span><br><span class="line">      |         ~~~~~~~~~~~~~~^~~</span><br><span class="line">btest.c:299:9: note: ‘arg_test_range’ declared here</span><br><span class="line">  299 |     int arg_test_range[3]; /* test range for each argument */</span><br><span class="line">      |         ^~~~~~~~~~~~~~</span><br><span class="line">root@Andrew:/mnt/d/.c/csapp/datalab-handout# ./btest</span><br><span class="line">Score   Rating  Errors  Function</span><br><span class="line"> 1      1       0       bitXor</span><br><span class="line"> 1      1       0       tmin</span><br><span class="line"> 1      1       0       isTmax</span><br><span class="line"> 2      2       0       allOddBits</span><br><span class="line"> 2      2       0       negate</span><br><span class="line"> 3      3       0       isAsciiDigit</span><br><span class="line"> 3      3       0       conditional</span><br><span class="line"> 3      3       0       isLessOrEqual</span><br><span class="line"> 4      4       0       logicalNeg</span><br><span class="line"> 4      4       0       howManyBits</span><br><span class="line"> 4      4       0       floatScale2</span><br><span class="line"> 4      4       0       floatFloat2Int</span><br><span class="line"> 4      4       0       floatPower2</span><br><span class="line">Total points: 36/36</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSAPP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS145 Intro to databases 学习笔记5——递归查询、OLAP、NoSQL</title>
      <link href="/2024/02/02/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%E3%80%81OLAP%E3%80%81NoSQL/"/>
      <url>/2024/02/02/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94%E9%80%92%E5%BD%92%E6%9F%A5%E8%AF%A2%E3%80%81OLAP%E3%80%81NoSQL/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>好耶！终于刷完了。看到进阶课程CS245还挺有意思的，就是找不到公开课，啥时候再去啃啃pdf。</p><p>本文是作者学习<strong>standford CS145 Introduction to Databases</strong>系列视频的第五篇笔记辣，估计是最后一篇，主要包括了第十五章到第十七章的内容：</p><ol><li>递归查询</li><li>OLAP</li><li>NoSQL</li></ol><p>相关参考资料：</p><p>OLTP和OLAP的区别：<a href="https://www.zhihu.com/question/305820203">OLAP和OLTP的区别是什么？ - 知乎 (zhihu.com)</a></p><p>With Cude 和 With Rollup：<a href="https://www.jianshu.com/p/343a684fc7a2">Hive中with cube、with rollup、grouping sets用法 - 简书 (jianshu.com)</a></p><p>NoSQL数据库的代表：<a href="https://zhuanlan.zhihu.com/p/418281466">一文打尽，主流 NoSQL 及应用场景详解～ - 知乎 (zhihu.com)</a></p><hr><h1 id="一、递归查询"><a href="#一、递归查询" class="headerlink" title="一、递归查询"></a>一、递归查询</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><h3 id="1-1-WITH-AS语句"><a href="#1-1-WITH-AS语句" class="headerlink" title="1.1 WITH AS语句"></a>1.1 WITH AS语句</h3><p>利用<strong>WITH AS</strong>语句<strong>为查询语句指定一个标识符</strong>，方便其他查询去调用<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">With</span> RI <span class="keyword">As</span> (query_1)</span><br><span class="line">     R2 <span class="keyword">As</span> (query_2)</span><br><span class="line">     Rn <span class="keyword">As</span> (query_n)</span><br><span class="line"><span class="operator">&lt;</span>query involving Rl, ..., Rn (<span class="keyword">and</span> other tables)<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></p><p>指定为<strong>RECURSIVE</strong>表示允许语句自身递归调用以及语句之间相互递归<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">With</span> <span class="keyword">Recursive</span></span><br><span class="line">     RI <span class="keyword">As</span> (query_1)</span><br><span class="line">     R2 <span class="keyword">As</span> (query_2)</span><br><span class="line">     Rn <span class="keyword">As</span> (query_n)</span><br><span class="line"><span class="operator">&lt;</span>query involving Rl, ..., Rn (<span class="keyword">and</span> other tables)<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></p><p>一般来说，使用RECURSIVE时，查询语句应该满足以下形式<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">With</span> <span class="keyword">Recursive</span></span><br><span class="line">     R <span class="keyword">As</span> (base query</span><br><span class="line">             <span class="keyword">Union</span> </span><br><span class="line">             <span class="keyword">recursive</span> query)</span><br><span class="line"><span class="operator">&lt;</span>query involving R (<span class="keyword">and</span> other tables)<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><br>在这里使用Union而不是Union All是为了避免不断加入重复值，使递归得以终止</p><h3 id="1-2-线性递归-Linear-Recursion"><a href="#1-2-线性递归-Linear-Recursion" class="headerlink" title="1.2 线性递归(Linear Recursion)"></a>1.2 线性递归(Linear Recursion)</h3><p>在recursive query中<strong>只递归调用自身一次</strong>的，叫做<strong>线性递归</strong></p><p>常用于表中每个元组指定了直接的上下级关系，要求找到所有的无论直接或间接的上下级关系</p><p>示例如下：</p><p>(1) 已有表ParentOf(parent, child)，给定一个名字，找到他所有的祖先<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    Ancestor(a,d) <span class="keyword">as</span> (<span class="keyword">select</span> parent <span class="keyword">as</span> a, child <span class="keyword">as</span> d <span class="keyword">from</span> ParentOf</span><br><span class="line">                      <span class="keyword">union</span></span><br><span class="line">                      <span class="keyword">select</span> Ancestor.a, Parentof.child <span class="keyword">as</span> d </span><br><span class="line">                      <span class="keyword">from</span> Ancestor, ParentOf</span><br><span class="line">                      <span class="keyword">where</span> Ancestor.d <span class="operator">=</span> Parentof.parent)</span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> Ancestor <span class="keyword">where</span> d <span class="operator">=</span> <span class="string">&#x27;Mary&#x27;</span></span><br></pre></td></tr></table></figure></p><p>(2) 已有表<br>Project(name, mgrID) 包含项目的名字及其项目负责人(警觉)<br>Manager(mID, eID) 表示上下级关系，mID为上级的ID，eID为下级的ID<br>Emplyee(ID, salary) 表示员工的薪水<br>现求：给定一个项目的名字，求这个项目之下所有人的薪水总和<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--思路：先找到项目之下的所有人的ID，再与Employee表联合查询薪水总和</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    ProjectEmps <span class="keyword">as</span> ( <span class="keyword">select</span> mgrID <span class="keyword">as</span> ID <span class="keyword">from</span> Project <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;ProjectName&#x27;</span></span><br><span class="line">                     <span class="keyword">union</span></span><br><span class="line">                     <span class="keyword">select</span> <span class="keyword">distinct</span> eID <span class="keyword">as</span> ID </span><br><span class="line">                     <span class="keyword">from</span> Manager M, Project P</span><br><span class="line">                     <span class="keyword">where</span> M.mID <span class="operator">=</span> P.eID )</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> ProjectEmps </span><br><span class="line"><span class="keyword">where</span> ID <span class="keyword">in</span> (<span class="keyword">select</span> ID <span class="keyword">from</span> ProjectEmps)</span><br></pre></td></tr></table></figure></p><p>(3) 已有表<br>Flight(orig, dest, cost) 表示从地点orig直达地点dest的航班需要的消费cost<br>现求：给定出发地和目的地，求从出发地到目的地的最小消费<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--思路：先找到所有直接或间接的路径及其消费，再根据出发地和目的地聚合查询</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    Route(orig, dest, total) <span class="keyword">as</span> </span><br><span class="line">               ( <span class="keyword">select</span> orig, dest, cost <span class="keyword">as</span> total <span class="keyword">from</span> Flight</span><br><span class="line">                 <span class="keyword">union</span></span><br><span class="line">                 <span class="keyword">select</span> R.orig, F.dest, (cost <span class="operator">+</span> total) <span class="keyword">as</span> total </span><br><span class="line">                 fromn Route R, Flight F</span><br><span class="line">                 <span class="keyword">where</span> R.dest <span class="operator">=</span> F.orig )</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(total) <span class="keyword">from</span> Route</span><br><span class="line"><span class="keyword">where</span> orig <span class="operator">=</span> <span class="string">&#x27;origName&#x27;</span> <span class="keyword">and</span> dest <span class="operator">=</span> <span class="string">&#x27;destName&#x27;</span></span><br></pre></td></tr></table></figure></p><p>但是，当航班出现环时，会引起无限递归，需要<strong>限制递归次数</strong>，有两种方案：</p><ol><li>在最后的查询语句中<strong>使用limit</strong>：直接限制得到的结果数量，缺点是不能聚合查询</li><li>在递归语句中<strong>引入计数变量</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用limit</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    Route(orig, dest, total) <span class="keyword">as</span> </span><br><span class="line">               ( <span class="keyword">select</span> orig, dest, cost <span class="keyword">as</span> total <span class="keyword">from</span> Flight</span><br><span class="line">                 <span class="keyword">union</span></span><br><span class="line">                 <span class="keyword">select</span> R.orig, F.dest, (cost <span class="operator">+</span> total) <span class="keyword">as</span> total </span><br><span class="line">                 fromn Route R, Flight F</span><br><span class="line">                 <span class="keyword">where</span> R.dest <span class="operator">=</span> F.orig )</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Route  <span class="comment">--不能使用 select min(total)，因为这意味着查询期待20个最小值(没有意义)</span></span><br><span class="line"><span class="keyword">where</span> orig <span class="operator">=</span> <span class="string">&#x27;origName&#x27;</span> <span class="keyword">and</span> dest <span class="operator">=</span> <span class="string">&#x27;destName&#x27;</span> limit <span class="number">20</span>  <span class="comment">--限制结果只能有20条</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--引入计数变量，计算路径的长度并加以限制</span></span><br><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    Route(orig, dest, total, length) <span class="keyword">as</span> </span><br><span class="line">               ( <span class="keyword">select</span> orig, dest, cost, <span class="number">1</span> <span class="keyword">as</span> total <span class="keyword">from</span> Flight  <span class="comment">--直达航班路径长度为1</span></span><br><span class="line">                 <span class="keyword">union</span></span><br><span class="line">                 <span class="keyword">select</span> R.orig, F.dest, (cost <span class="operator">+</span> total) <span class="keyword">as</span> total， (R.length <span class="operator">+</span> <span class="number">1</span>) <span class="keyword">as</span> length </span><br><span class="line">                 fromn Route R, Flight F</span><br><span class="line">                 <span class="keyword">where</span> R.dest <span class="operator">=</span> F.orig <span class="keyword">and</span> R.length <span class="operator">&lt;</span> <span class="number">10</span>)  <span class="comment">--限制路径长度不能超过10</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(total) <span class="keyword">from</span> Route</span><br><span class="line"><span class="keyword">where</span> orig <span class="operator">=</span> <span class="string">&#x27;origName&#x27;</span> <span class="keyword">and</span> dest <span class="operator">=</span> <span class="string">&#x27;destName&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="2-非线性递归和互相递归"><a href="#2-非线性递归和互相递归" class="headerlink" title="2. 非线性递归和互相递归"></a>2. 非线性递归和互相递归</h2><h3 id="2-1-非线性递归-Non-linear-Recursion"><a href="#2-1-非线性递归-Non-linear-Recursion" class="headerlink" title="2.1 非线性递归(Non-linear Recursion)"></a>2.1 非线性递归(Non-linear Recursion)</h3><p>与线性递归相对地，<strong>非线性递归</strong>在递归语句中会<strong>多次引用自身</strong>。</p><p>通过以下示例，让我们思考非线性递归有什么特点：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    Ancestor(a,d) <span class="keyword">as</span> (<span class="keyword">select</span> parent <span class="keyword">as</span> a, child <span class="keyword">as</span> d <span class="keyword">from</span> ParentOf</span><br><span class="line">                      <span class="keyword">union</span></span><br><span class="line">                      <span class="keyword">select</span> A1.a, A2.d </span><br><span class="line">                      <span class="keyword">from</span> Ancesror A1, Ancestor A2</span><br><span class="line">                      <span class="keyword">where</span> A1.d <span class="operator">=</span> A2.a)</span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> Ancestor <span class="keyword">where</span> d <span class="operator">=</span> <span class="string">&#x27;Mary&#x27;</span></span><br></pre></td></tr></table></figure><br>在该示例中，我们连接两个Ancestor，而不是像前面一样用一个Ancestor连接原始的ParentOf。不难发现，这种连接方式能用<strong>更少的次数收敛到结果</strong></p><p>但是由于非线性递归较难实现，<strong>SQL标准不要求</strong>非线性递归，<strong>现有的数据库系统也未实现</strong>非线性递归</p><h3 id="2-2-互相递归-Mutual-Recursion"><a href="#2-2-互相递归-Mutual-Recursion" class="headerlink" title="2.2 互相递归(Mutual Recursion)"></a>2.2 互相递归(Mutual Recursion)</h3><p>相互递归是指<strong>多个被标识的递归语句成环地互相调用</strong></p><h4 id="1-Hub-and-Authority-示例"><a href="#1-Hub-and-Authority-示例" class="headerlink" title="(1) Hub and Authority 示例"></a>(1) Hub and Authority 示例</h4><p>现有表<br>Link(src, dest) 表示src到dest存在一条有向边</p><p>我们定义<br>被三个Hub所指的节点称作Authority<br>指向了三个Authority的节点称作Hub</p><p>初始给定两表HubStart(node)包含部分Hub, AuthStart(node)包含部分Authority<br>现求所有的Hub和Authority<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> revursive </span><br><span class="line">    Hub <span class="keyword">as</span> ( <span class="keyword">select</span> node <span class="keyword">from</span> HubStart</span><br><span class="line">             <span class="keyword">union</span></span><br><span class="line">             <span class="keyword">select</span> src <span class="keyword">as</span> node <span class="keyword">from</span> Link</span><br><span class="line">             <span class="keyword">where</span> dest <span class="keyword">in</span> (<span class="keyword">select</span> node <span class="keyword">from</span> Auth)  <span class="comment">--指向Auth</span></span><br><span class="line">             <span class="keyword">group</span> <span class="keyword">by</span> src <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>)  <span class="comment">--按src分组，找到指向Auth大于3的src就是Hub</span></span><br><span class="line">    Auth <span class="keyword">as</span> ( <span class="keyword">select</span> node <span class="keyword">from</span> AuthStart   </span><br><span class="line">              <span class="keyword">union</span></span><br><span class="line">              <span class="keyword">select</span> dest <span class="keyword">as</span> node <span class="keyword">from</span> Link</span><br><span class="line">              <span class="keyword">where</span> src <span class="keyword">in</span> (selcet node <span class="keyword">from</span> Hub)  <span class="comment">--被Hub所指</span></span><br><span class="line">              <span class="keyword">group</span> <span class="keyword">by</span> dest <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>  <span class="comment">--按dest分组，被超过3个Hub所指的dest就是Auth</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Hub;</span><br></pre></td></tr></table></figure></p><h4 id="2-两种不被允许的情况-在递归语句中"><a href="#2-两种不被允许的情况-在递归语句中" class="headerlink" title="(2) 两种不被允许的情况(在递归语句中)"></a>(2) 两种不被允许的情况(在递归语句中)</h4><p><strong>不允许负依赖</strong>(Negative Dependence)的子查询，示例如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> revursive </span><br><span class="line">    Hub <span class="keyword">as</span> ( <span class="keyword">select</span> node <span class="keyword">from</span> HubStart</span><br><span class="line">             <span class="keyword">union</span></span><br><span class="line">             <span class="keyword">select</span> src <span class="keyword">as</span> node <span class="keyword">from</span> Link</span><br><span class="line">             <span class="keyword">where</span> src <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> node <span class="keyword">from</span> Auth)  <span class="comment">--Hub不能同时为Hub</span></span><br><span class="line">             dest <span class="keyword">in</span> (<span class="keyword">select</span> node <span class="keyword">from</span> Auth)  </span><br><span class="line">             <span class="keyword">group</span> <span class="keyword">by</span> src <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>)  </span><br><span class="line">    Auth <span class="keyword">as</span> ( <span class="keyword">select</span> node <span class="keyword">from</span> AuthStart   </span><br><span class="line">              <span class="keyword">union</span></span><br><span class="line">              <span class="keyword">select</span> dest <span class="keyword">as</span> node <span class="keyword">from</span> Link</span><br><span class="line">              <span class="keyword">where</span> dest <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> node <span class="keyword">from</span> Hub)  <span class="comment">--Auth不能同时为Hub</span></span><br><span class="line">              src <span class="keyword">in</span> (selcet node <span class="keyword">from</span> Hub)  </span><br><span class="line">              <span class="keyword">group</span> <span class="keyword">by</span> dest <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">3</span>  </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Hub;</span><br></pre></td></tr></table></figure><br>当我们有一个节点同时为Hub和Authority时，它出现在哪个表中取决于我们创建Hub和Auth的顺序。<strong>SQL标准觉得这很反人类，于是不允许负依赖</strong></p><p><strong>不允许聚合查询</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="keyword">recursive</span> </span><br><span class="line">    R(x) <span class="keyword">as</span> ( <span class="keyword">select</span> x <span class="keyword">from</span> P</span><br><span class="line">           <span class="keyword">union</span></span><br><span class="line">           <span class="keyword">select</span> <span class="built_in">sum</span>(x) <span class="keyword">as</span> x <span class="keyword">from</span> R )</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> R</span><br></pre></td></tr></table></figure><br>假设P为{1, 2}<br>那么第一轮R为{1, 2, 3}<br>第二轮R为{1, 2, 6}<br>第三轮R为{1, 2, 9}…</p><p>视频的解释是：对于R没有很好的定义，于是就不被SQL标准允许了(what?</p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>SQL标准允许线性递归以及相互递归，未要求非线性递归。<br>不允许带负依赖的子查询，或者聚合查询的递归语句。</p><p>现有数据库系统只有实现了线性递归</p><blockquote><p>Extends expressiveness of SQL</p><ul><li>Basic functionality: linear recursion</li><li>Extended functionality: nonlinear recursion, mutual recursion</li><li>Disallowed: recursive subqueries (negative), aggregation</li></ul></blockquote><hr><h1 id="二、OLAP-Online-Analytical-Processing"><a href="#二、OLAP-Online-Analytical-Processing" class="headerlink" title="二、OLAP(Online Analytical Processing)"></a>二、OLAP(Online Analytical Processing)</h1><h2 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>这几集刷下来就像学了一堆行业黑话，其实说到底OLAP就是用来分析大规模的数据，而不是对小部分的数据做增删改查，后者是传统关系型数据库的主要应用，称为OLTP(Online Transaction Processing)。</p><p>两者的对比如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">OLAP/OLTP</th><th style="text-align:center">事务</th><th style="text-align:center">处理的数据规模</th><th style="text-align:center">查询复杂程度</th><th style="text-align:center">更新频率</th></tr></thead><tbody><tr><td style="text-align:center">OLTP</td><td style="text-align:center">短</td><td style="text-align:center">小</td><td style="text-align:center">低</td><td style="text-align:center">频繁</td></tr><tr><td style="text-align:center">OLAP</td><td style="text-align:center">长</td><td style="text-align:center">大</td><td style="text-align:center">高</td><td style="text-align:center">不频繁</td></tr></tbody></table></div><h2 id="2-星型模式-Star-Schema"><a href="#2-星型模式-Star-Schema" class="headerlink" title="2. 星型模式(Star Schema)"></a>2. 星型模式(Star Schema)</h2><p>OLTP组织数据使用的是ER模型，突出实体的特征和实体之间的连接。</p><p>OLAP组织数据的模式则是Star Schema，由一个<strong>不常更新维度表</strong>引用<strong>多个经常更新事实表</strong>组成：</p><ol><li>维度表(Dimensions Table)：属性一般为各事实表的主键(维度属性)以及其他值(依赖属性)，更新不频繁且规模较小。</li><li>事实表(Fact Table)：记录发生的事，更新频繁且规模很大，通常只允许插入</li></ol><p>一堆黑话我真的服了，我尽量讲人话吧：</p><p>维度表包含三个维度和一个值时，我们给数据建一个三维坐标系，将所有数据看作一个立方体，称作<strong>数据立方体</strong>(Data Cube)。多个维度和多个值时也可以这么去抽象。</p><p>只取坐标系上的一个面，也就是不考虑其中一个维度时，就是<strong>对特定维度做聚合操作</strong>，称作<strong>切片</strong>(Slice)，给这个维度加限制条件，即<strong>对特定维度下特定区间做聚合操作</strong>时，称作<strong>切块</strong>(Dice)</p><p>假设我们现在对两个维度分组，现在想更精确地去分析数据，所以要<strong>多对一个维度分组</strong>，称作<strong>钻取</strong>(Drill-down)。相反地，我们觉得现在太精细了，想从更高层次对数据分析，所以要<strong>少对一个维度分组</strong>，称作<strong>上卷</strong>(Roll-up)。示例如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--现在只对两个维度分组</span></span><br><span class="line"><span class="keyword">select</span> state, brand, <span class="built_in">sum</span>(qty<span class="operator">*</span>price)</span><br><span class="line"><span class="keyword">From</span> Sales F, Store S, Item I</span><br><span class="line"><span class="keyword">Where</span> F.storeID <span class="operator">=</span> S.storeID <span class="keyword">And</span> F.itemID <span class="operator">=</span> I.itemID </span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> state, brand</span><br><span class="line"></span><br><span class="line"><span class="comment">--再加一个维度叫做Drill-down</span></span><br><span class="line"><span class="keyword">select</span> state, brand, category, <span class="built_in">sum</span>(qty<span class="operator">*</span>price)</span><br><span class="line"><span class="keyword">From</span> Sales F, Store S, Item I</span><br><span class="line"><span class="keyword">Where</span> F.storeID <span class="operator">=</span> S.storeID <span class="keyword">And</span> F.itemID <span class="operator">=</span> I.itemID </span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> state, brand, category</span><br><span class="line"></span><br><span class="line"><span class="comment">--少一个叫做Roll-up</span></span><br><span class="line"><span class="keyword">select</span> brand, <span class="built_in">sum</span>(qty<span class="operator">*</span>price)</span><br><span class="line"><span class="keyword">From</span> Sales F, Store S, Item I</span><br><span class="line"><span class="keyword">Where</span> F.storeID <span class="operator">=</span> S.storeID <span class="keyword">And</span> F.itemID <span class="operator">=</span> I.itemID </span><br><span class="line"><span class="keyword">Group</span> <span class="keyword">By</span> brand</span><br></pre></td></tr></table></figure></p><h2 id="3-SQL中的OLAP"><a href="#3-SQL中的OLAP" class="headerlink" title="3. SQL中的OLAP"></a>3. SQL中的OLAP</h2><p>SQL标准中，在Group By之后使用With Cude 和 With Rollup以便执行OLAP查询：</p><ol><li><strong>With Cude</strong>：查询结果包含各个维度的笛卡尔组合(包括NULL)，值为NULL代表对该维度聚合</li><li><strong>With Rollup</strong>：一层一层向前Roll-up，即满足前一维度为NULL时，后一维度必定为NULL。适用于有层次结构的数据，比如统计省、市、县的人口</li></ol><p>MySQL支持With Rollup，Postgre和SQLite都不支持</p><p>然而，With Cude可以由各个维度的With Rollup 做并操作得到，示例如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--MySQL不支持with cube</span></span><br><span class="line"><span class="keyword">select</span> storeID, itemID, custID,<span class="built_in">sum</span>(price) <span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> storeID, itemID, custID <span class="keyword">with</span> <span class="keyword">cube</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--上式可以等价于</span></span><br><span class="line"><span class="keyword">select</span> storeID, itemID, custID,<span class="built_in">sum</span>(price) <span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> storeID, itemID, custID <span class="keyword">with</span> <span class="keyword">rollup</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> storeID, itemID, custID, <span class="built_in">sum</span>(price) <span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> itemID, custID, storeID <span class="keyword">with</span> <span class="keyword">rollup</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> storeID, itemID, custID, <span class="built_in">sum</span>(price) <span class="keyword">from</span> Sales</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> custID, storeID, itemID <span class="keyword">with</span> <span class="keyword">rollup</span>;</span><br></pre></td></tr></table></figure></p><hr><h1 id="三、NoSQL"><a href="#三、NoSQL" class="headerlink" title="三、NoSQL"></a>三、NoSQL</h1><h2 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>NoSQL中的SQL不是指SQL这种查询语言，而是<strong>相对于传统的关系型数据库</strong>。No也不是没有的意思，而是<strong>Not Only</strong></p><p>所以NoSQL就是用<strong>其他的关系模式去组织数据，使其能够解决传统关系型数据库不容易甚至不能解决的问题</strong>。通常具有以下特点：</p><ol><li>更灵活的数据组织模式</li><li>更快地、更少消耗的搭建</li><li>面向大规模的数据</li><li>牺牲部分的一致性，允许近似解，去换取更高的性能</li></ol><blockquote><p>+表示优点、-表示缺点<br>+Flexible schema<br>+Quicker/cheaper to set up<br>+Massive scalability<br>+Relaxed consistency-&gt;higher performance &amp; availability<br>-No declarative querylanguage-&gt;more programming<br>-Relaxed consistency-&gt;fewer guarantees</p></blockquote><p>常见的NoSQL数据库包括以下几个类型：</p><ol><li>MapReduce框架(MapReduce framework)</li><li>键值数据库(Key-Values stores)</li><li>文档数据库(Document stores)</li><li>图数据库(Graph database systems)</li><li>列存储数据库(Column stores)</li></ol><h2 id="2-MapReduce框架"><a href="#2-MapReduce框架" class="headerlink" title="2. MapReduce框架"></a>2. MapReduce框架</h2><p>MapReduce起源于Google，代表为Hadoop</p><p>MapReduce框架中</p><ol><li>没有数据模型，直接从文件输入再输出到文件中</li><li>由用户提供一系列函数：map(), reduce(), reader(), writer(), combiner()</li><li>由系统将这些功能粘合(glue)在一起，同时提供容错(fault tolerance)和扩展性(scalability)</li></ol><p>其中，<br>reader()从文件中读取数据，<br>writer()将结果输出到文件中，<br>map()提供将问题分解为子问题的方法，<br>reduce()求解子问题然后合并为结果，<br>combiner()为可选功能，它位于map()和reduce()之间，对子问题预合并，以提高效率。</p><p><img src="/img/2024/02/MapReduce.png" alt="image.png"></p><h2 id="3-键值数据库"><a href="#3-键值数据库" class="headerlink" title="3. 键值数据库"></a>3. 键值数据库</h2><p>键值数据库的代表有Riak、Redis、Memcached、Amazon’s Dynamo、Project Voldemort</p><p>键值数据库应用于OLTP，即小部分数据的频繁增删改查</p><ul><li>数据模型：(key, values) pairs 即键值对</li><li>操作：<ul><li>Insert(key, values) ：插入键值对</li><li>Fetch(key)：根据键查询值</li><li>Update(key)：根据键更新值</li><li>Delete(key)：根据键删除键值对</li></ul></li><li>有些数据库允许value中有更复杂的结构</li><li>有些数据库允许在一定范围的查询</li></ul><h2 id="4-文档数据库"><a href="#4-文档数据库" class="headerlink" title="4. 文档数据库"></a>4. 文档数据库</h2><p>文档数据库的代表有MongoDB、CouchDB、RavenDB</p><p>文档数据库的数据模型和操作跟键值数据库很像，只不过存储的文档有特定的类型</p><ul><li>数据模型：(key, document) pairs</li><li>文档类型：JSON、XML等</li><li>操作：<ul><li>Insert(key, document) ：插入键和文档的对</li><li>Fetch(key)：根据键查询文档</li><li>Update(key)：根据键更新文档</li><li>Delete(key)：根据键删除文档</li></ul></li><li>可以根据文档类型做查询</li></ul><h2 id="5-图数据库"><a href="#5-图数据库" class="headerlink" title="5. 图数据库"></a>5. 图数据库</h2><p>图数据库的代表有Neo4J、Infinite Graph、OrientDB</p><p>不同的图数据库之间实现差别很大</p><ul><li>数据模型：点集 和 边集</li><li>节点包含有属性（包括节点的ID）</li><li>边包含标签（表示节点之间的关系）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> OLAP </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS145 Intro to databases 学习笔记4——索引、约束、触发器、事务、视图、授权</title>
      <link href="/2024/02/01/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%E3%80%81%E7%BA%A6%E6%9D%9F%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8E%88%E6%9D%83/"/>
      <url>/2024/02/01/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95%E3%80%81%E7%BA%A6%E6%9D%9F%E3%80%81%E8%A7%A6%E5%8F%91%E5%99%A8%E3%80%81%E4%BA%8B%E5%8A%A1%E3%80%81%E8%A7%86%E5%9B%BE%E3%80%81%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>已经是学习<strong>standford CS145 Introduction to Databases</strong>系列视频的第四篇笔记，这篇几乎要把SQL中重要的概念都涵盖了。。。</p><p>本文主要包括第十章到第十四章的内容：</p><ol><li>索引</li><li>约束和触发器</li><li>事务</li><li>视图</li><li>授权</li></ol><p>相关参考资料：</p><p>视频链接：<a href="https://www.youtube.com/playlist?list=PLroEs25KGvwzmvIxYHRhoGTz9w8LeXek0">Introduction to Databases - Jennifer Widom - Stanford</a></p><p>黑马的视频也是很实用啊：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru">黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括</a></p><hr><h1 id="一、索引-Indexes"><a href="#一、索引-Indexes" class="headerlink" title="一、索引(Indexes)"></a>一、索引(Indexes)</h1><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>对关系表的某个或某些属性构建<strong>索引</strong>，能够<strong>提高查询的效率</strong>。</p><p>然而，维护索引也需要开销：</p><ul><li>索引需要<strong>占用空间</strong>(最微不足道的开销，空间换时间咱还是愿意的)</li><li><strong>创建索引</strong>需要时间(中等的开销，创建索引确实是耗时的操作)</li><li>索引<strong>需要维护</strong>，特别是在<strong>频繁对数据做修改</strong>时开销很大(几乎可以抵消索引带来的好处)</li></ul><p>因此评价索引需要考虑到<strong>查询</strong>和<strong>修改</strong>的负荷(Query vs. Update)</p><h2 id="2-索引的结构"><a href="#2-索引的结构" class="headerlink" title="2. 索引的结构"></a>2. 索引的结构</h2><p>索引可以有两种结构，分别是：</p><ul><li><strong>B树</strong>或<strong>B+树</strong>(B trees or B+ trees)：可以处理属性的比较关系(=, &lt;, &gt;)，查询的时间复杂度是$O(\log n)$对数级(Logarithmic)</li><li><strong>哈希表</strong>(Hash Tables)：只能处理属性的相等关系(=)，查询的时间复杂度是$O(1)$常数级(Constant)</li></ul><p>因此，只处理相等关系时，尽量用哈希表，需要处理比较关系时可以用B树和B+树</p><h2 id="3-索引的语法"><a href="#3-索引的语法" class="headerlink" title="3. 索引的语法"></a>3. 索引的语法</h2><p><strong>SQL标准</strong>下的索引的语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> Index IndexName <span class="keyword">on</span> T(A) <span class="comment">--对一个属性创建索引</span></span><br><span class="line"><span class="keyword">Create</span> Index IndexName <span class="keyword">on</span> T(Al,A2,..,An) <span class="comment">--对多个属性创建索引</span></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Unique</span> Index IndexName <span class="keyword">on</span> T(A)  <span class="comment">--在创建索引的时候检查属性是否有重复值</span></span><br><span class="line"><span class="keyword">Drop</span> Index IndexName <span class="comment">--删除索引</span></span><br></pre></td></tr></table></figure><hr><h1 id="二、约束和触发器-Constraints-and-Triggers"><a href="#二、约束和触发器-Constraints-and-Triggers" class="headerlink" title="二、约束和触发器(Constraints and Triggers)"></a>二、约束和触发器(Constraints and Triggers)</h1><h2 id="1-基本介绍-1"><a href="#1-基本介绍-1" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p><strong>(1) 约束和触发器的作用</strong></p><p>约束和触发器，它们都允许我们在处理关系模型时，我们需要对<strong>属性的值的范围作限制</strong>，以及处理<strong>不同属性之间的限制关系</strong></p><p><strong>(2) 约束和触发器的区别</strong></p><p>约束是<strong>静态</strong>的，而触发器是<strong>动态</strong>的。触发器不仅允许监控数据库的状态，而且能够作出即时的反馈，比约束更加expressive和powerful。</p><h2 id="2-约束-Constraints"><a href="#2-约束-Constraints" class="headerlink" title="2. 约束(Constraints)"></a>2. 约束(Constraints)</h2><h3 id="2-1-非空约束-Non-null-Constraints"><a href="#2-1-非空约束-Non-null-Constraints" class="headerlink" title="2.1 非空约束(Non-null Constraints)"></a>2.1 非空约束(Non-null Constraints)</h3><p>添加了非空约束的属性，值不能为NULL<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在属性后面加上not null添加非空约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(sID <span class="type">int</span>, sName text, GPA <span class="type">real</span> <span class="keyword">not</span> <span class="keyword">null</span>, sizeHS <span class="type">int</span>);</span><br></pre></td></tr></table></figure></p><h3 id="2-2-主键约束和唯一约束-Key-Constraints"><a href="#2-2-主键约束和唯一约束-Key-Constraints" class="headerlink" title="2.2 主键约束和唯一约束(Key Constraints)"></a>2.2 主键约束和唯一约束(Key Constraints)</h3><p>添加了<strong>主键约束</strong>的属性，值不能重复，且<strong>不能为空</strong><br>添加了<strong>唯一约束</strong>的属性，值不能重复，但是<strong>可以为空</strong>(MySQL 允许多个NULL值，其他数据库不清楚)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在属性后面加上primary key添加主键约束</span></span><br><span class="line"><span class="comment">--在属性后面加上unique添加唯一约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student(sID <span class="type">int</span> <span class="keyword">primary</span> key, sName text <span class="keyword">unique</span></span><br><span class="line">        GPA <span class="type">real</span>, sizeHS <span class="type">int</span>);</span><br></pre></td></tr></table></figure></p><p>可以为多个属性添加Key Constraints</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将多个属性作为整体添加约束时，放在所有属性的末尾</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Apply(sID <span class="type">int</span>, cName text, major text, decision text</span><br><span class="line">        <span class="keyword">unique</span>(sID, cName), <span class="keyword">unique</span>(sID, major));</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> College(cName text, state text, enrollment <span class="type">int</span>,</span><br><span class="line">        <span class="keyword">primary</span> key(cName, state));</span><br></pre></td></tr></table></figure><h3 id="2-3-基于属性和元组的约束-Attribute-based-Tuple-based-Constraints"><a href="#2-3-基于属性和元组的约束-Attribute-based-Tuple-based-Constraints" class="headerlink" title="2.3 基于属性和元组的约束(Attribute-based/Tuple-based Constraints)"></a>2.3 基于属性和元组的约束(Attribute-based/Tuple-based Constraints)</h3><p>Attribute-based Constraints对属性的值的范围作检查<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在属性后添加check( condition )限制值的范围</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(sID <span class="type">int</span>, sName text,</span><br><span class="line">            GPA <span class="type">real</span> <span class="keyword">check</span>(GPA <span class="operator">&lt;=</span> <span class="number">4.0</span> <span class="keyword">and</span> GPA <span class="operator">&gt;</span> <span class="number">0.0</span>)</span><br><span class="line">            sizeHS <span class="type">int</span> <span class="keyword">check</span>(sizeHS <span class="operator">&lt;</span> <span class="number">5000</span>));</span><br></pre></td></tr></table></figure></p><p>Tuple-based Constraints可以表示多个属性之间的限制关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--可以在所有属性的末尾使用check( condition )指定属性间的限制关系</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Apply(sID <span class="type">int</span>, cName text, major text, decision text, </span><br><span class="line">    <span class="keyword">check</span>(decision<span class="operator">=</span><span class="string">&#x27;N&#x27;</span> <span class="keyword">or</span> cName <span class="operator">&lt;&gt;</span> <span class="string">&#x27;Stanford&#x27;</span> <span class="keyword">or</span> major <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CS&#x27;</span>));</span><br></pre></td></tr></table></figure></p><p>事实上，check()可以用来重写许多其他的约束，比如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--用check重写非空约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(sID <span class="type">int</span>, sName text, GPA <span class="type">real</span> <span class="keyword">check</span>(GPA <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>), sizeHS <span class="type">int</span>);</span><br></pre></td></tr></table></figure></p><p>在SQL标准下，check()中编写子查询的有效的，但是实际还没有数据库实现这一功能<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--check()中编写子查询实现外键的引用</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Apply(sID <span class="type">int</span>, cName text, major text, decision text,</span><br><span class="line">    <span class="keyword">check</span>(sID <span class="keyword">in</span>(<span class="keyword">select</span> sID <span class="keyword">from</span> Student)));</span><br></pre></td></tr></table></figure></p><h3 id="2-4-外键约束-Foreign-Key"><a href="#2-4-外键约束-Foreign-Key" class="headerlink" title="2.4 外键约束(Foreign Key)"></a>2.4 外键约束(Foreign Key)</h3><p>视频中也将其叫做引用完整性(Referential integrity)</p><p>表$R$中的属性$A$的值必须在表$S$中的属性$B$中出现，那么：</p><ul><li>称$A$为外键(Foreign Key)，可以有多个属性作为外键</li><li>$B$经常是主键primary key，至少应该是unique的，即不能有重复值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> College(cName text <span class="keyword">primary</span> key, state text, enrollment <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Student(sID <span class="type">int</span> <span class="keyword">primary</span> key, sName text, GPA <span class="type">real</span>, sizeHS <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--attName references tableName(attName) 设置外键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Apply(sID <span class="type">int</span> <span class="keyword">references</span> student(sID),</span><br><span class="line">                    cName text <span class="keyword">references</span> College(cName), </span><br><span class="line">                    major text, decision text);</span><br></pre></td></tr></table></figure><p>处理外键约束往往可以归类为两个问题：</p><p><strong>(1) 对$R.A$的修改和更新：需要检查新的值是否在$S.B$中存在</strong></p><p>对于$S.B$中不存在的值，数据库会直接拒绝该修改和更新操作</p><p><strong>(2) 对$S.B$的更新和删除：需要处理引用了旧的值的$R.A$</strong></p><p>处理这一类问题有三个方案：</p><ol><li>CASCADE：级联，对$S.B$更新时将$R.A$一同更新为新的值；对$S.B$删除时将$R.A$的元组一同删除</li><li>SET NULL：在对$S.B$的更新和删除操作时，将引用了旧的值的$R.A$设为NULL</li><li>RESTRICT：<strong>默认</strong>是RESTRICT，当存在引用了旧的值的$R.A$，不允许对$S.B$的更新和删除操作</li></ol><p>实际上，我们可以分别指定更新和删除要用那个方案<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--ON UPDATE &lt;CASCADE/SET NULL/RESTRICT&gt;：指定更新的方案</span></span><br><span class="line"><span class="comment">--ON DELETE &lt;CASCADE/SET NULL/RESTRICT&gt;：指定删除的方案</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Apply(sID <span class="type">int</span> <span class="keyword">references</span> Student(sID) <span class="keyword">on</span> <span class="keyword">delete</span> <span class="keyword">set</span> <span class="keyword">null</span>,</span><br><span class="line">                    cName text <span class="keyword">references</span> College(cName) <span class="keyword">on</span> <span class="keyword">update</span> cascade,</span><br><span class="line">                    decision text, major text);</span><br></pre></td></tr></table></figure></p><h3 id="2-5-通用断言-General-Assertions"><a href="#2-5-通用断言-General-Assertions" class="headerlink" title="2.5 通用断言(General Assertions)"></a>2.5 通用断言(General Assertions)</h3><p>General Assertions目前<strong>只存在于SQL标准</strong>中，未被数据库所实现。</p><p>创建一个断言，它会在我们对数据库就修改时，检查条件是否成立：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--注意!!以下代码仅为解释General Assertions展示, 无法真实执行</span></span><br><span class="line"><span class="comment">--创建一个断言检查表T中属性A是否存在重复值</span></span><br><span class="line"><span class="keyword">create</span> assertion Key</span><br><span class="line"><span class="keyword">check</span>((<span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> A) <span class="keyword">from</span> T)</span><br><span class="line">    <span class="operator">=</span> <span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="keyword">from</span> T)));</span><br><span class="line"></span><br><span class="line"><span class="comment">--创建一个断言检查外键约束</span></span><br><span class="line"><span class="keyword">create</span> assertion ReferentialIntegrity</span><br><span class="line"><span class="keyword">check</span>(<span class="keyword">not</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Apply</span><br><span class="line">    <span class="keyword">where</span> sID <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> sID <span class="keyword">from</span> student)));</span><br></pre></td></tr></table></figure><h2 id="3-触发器-Triggers"><a href="#3-触发器-Triggers" class="headerlink" title="3. 触发器(Triggers)"></a>3. 触发器(Triggers)</h2><h3 id="3-1-SQL标准下的触发器"><a href="#3-1-SQL标准下的触发器" class="headerlink" title="3.1 SQL标准下的触发器"></a>3.1 SQL标准下的触发器</h3><p>SQL标准下的触发器语法如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">Trigger</span> name             <span class="comment">--创建触发器，为触发器命名</span></span><br><span class="line">Before<span class="operator">|</span>After<span class="operator">|</span>Instead <span class="keyword">of</span> events  <span class="comment">--指定触发器触发的时机，events可以为插入、更新和删除操作</span></span><br><span class="line">[<span class="keyword">referencing</span><span class="operator">-</span>variables]         <span class="comment">--将修改前后的行或表引用为变量</span></span><br><span class="line">[<span class="keyword">For</span> <span class="keyword">Each</span> <span class="type">Row</span>]                  <span class="comment">--指定触发器是Row-Level还是Statement-Level</span></span><br><span class="line"><span class="keyword">When</span> ( <span class="keyword">condition</span> )              <span class="comment">--满足条件时，执行以下动作</span></span><br><span class="line">action</span><br></pre></td></tr></table></figure></p><p><strong>events</strong>可以为插入、更新和删除操作：<br>(1) 插入: Insert on tableName<br>(2) 删除：Delete on tableName<br>(3) 更新：Update [of (attName1, attName2, …)] on tableName</p><p><strong>[referencing-variables]</strong> 可以引用行，也可以引用表：<br>old row as var, new row as var, old table as var, new table as var<br>(1) 对于插入insert操作，只有new<br>(2) 对于删除delete操作，只有old<br>(3) 对于更新update操作，既有old也有new</p><p><strong>[For Each Row]</strong> 有For Each Row表示触发器是行级触发器，否则则是语句级触发器：<br>(1) 行级触发器代表操作有n行，就会执行n次触发器的动作<br>(2) 语句及触发器代表只会在语句末尾执行一次动作<br>需要注意的是，在<strong>SQL标准</strong>中，无论是行级还是语句级，动作都是攒到<strong>语句末尾</strong>执行，而<strong>SQLite和MySQL</strong>的行级触发器都是对<strong>每一行操作即刻时执行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--示例：R.A引用到S.B，级联删除触发器</span></span><br><span class="line"><span class="comment">--行级触发器写法</span></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Trigger</span> Cascade</span><br><span class="line">After <span class="keyword">Delete</span> <span class="keyword">on</span> S</span><br><span class="line"><span class="keyword">Referencing</span> <span class="keyword">Old</span> <span class="type">Row</span> <span class="keyword">As</span> O</span><br><span class="line"><span class="keyword">For</span> <span class="keyword">Each</span> <span class="type">Row</span></span><br><span class="line">[ <span class="keyword">no</span> <span class="keyword">condition</span> ]</span><br><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> R <span class="keyword">where</span> A <span class="operator">=</span> O.B</span><br><span class="line"></span><br><span class="line"><span class="comment">--语句级触发器写法</span></span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Trigger</span> Cascade</span><br><span class="line">After <span class="keyword">Delete</span> <span class="keyword">on</span> S</span><br><span class="line"><span class="keyword">Referencing</span> <span class="keyword">Old</span> <span class="keyword">Table</span> <span class="keyword">As</span> OT</span><br><span class="line">[ <span class="keyword">For</span> <span class="keyword">Each</span> <span class="type">Row</span> ]</span><br><span class="line">[ <span class="keyword">no</span> <span class="keyword">condition</span> ]</span><br><span class="line"><span class="keyword">Delete</span> <span class="keyword">From</span> R <span class="keyword">where</span> A <span class="keyword">in</span> (<span class="keyword">select</span> B <span class="keyword">from</span> OT )</span><br></pre></td></tr></table></figure><h3 id="3-2-触发器的语法"><a href="#3-2-触发器的语法" class="headerlink" title="3.2 触发器的语法"></a>3.2 触发器的语法</h3><p>不同的数据库对SQL标准的实现程度不同，在触发器的语法和功能上也有不同：</p><p>Postgre：完全实现了SQL标准，包括行级、语句级触发器，可以引用行，也可以引用表。但是语法更晦涩<br>SQLite：只有行级触发器，且在对<strong>每行操作时就触发</strong><br>MySQL：只有行级触发器，且在对<strong>每行操作时就触发</strong>，且<strong>每个事件只能有一个触发器</strong>，且对<strong>触发器的链式触发有限制</strong></p><blockquote><p>Postgres &gt;</p><ul><li>Expressiveness/behavior = full standard<br>row-level+ statement-level, old/new row &amp; table</li><li>Cumbersome &amp; awkward syntax</li></ul><p>SQLite &gt;&gt;</p><ul><li>Row-level only,immediate activation =&gt; no old/new table</li></ul><p>MySQL</p><ul><li>Row-level only, immediate activation =&gt; no old/new table</li><li>Only one trigger per event type</li><li>Limited trigger chaining</li></ul></blockquote><p><strong>SQLite</strong>和<strong>MySQL</strong>都<strong>预定义了Old、New</strong>两个变量用于引用旧行和新行，并且将动作action编写在begin和end之间的语句块中。</p><p>下面是SQLite的代码示例：</p><h4 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="(1) 基本操作"></a>(1) 基本操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--insert：只有New</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R1</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> Student </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> New.GPA <span class="operator">&gt;</span> <span class="number">3.3</span> <span class="keyword">and</span> New.GPA <span class="operator">&lt;=</span> <span class="number">3.6</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> Apply <span class="keyword">values</span>(New.sID, <span class="string">&#x27;Stanford&#x27;</span>, <span class="string">&#x27;geology&#x27;</span>, nu11);</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> Apply <span class="keyword">values</span>(New.sID, <span class="string">&#x27;MIT&#x27;</span>, <span class="string">&#x27;biology&#x27;</span>, nul1);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--delete：只有Old</span></span><br><span class="line"><span class="comment">--触发器实现外键的级联删除</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R2</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> Student</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">from</span> Apply <span class="keyword">where</span> sID <span class="operator">=</span> Old.sID;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--update：既有New, 也有Old</span></span><br><span class="line"><span class="comment">--触发器实现外键的级联更新</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R3</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">of</span> cName <span class="keyword">on</span> College</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> Apply <span class="keyword">set</span> cName <span class="operator">=</span> New.cName</span><br><span class="line">    <span class="keyword">where</span> cName <span class="operator">=</span> Old.cName;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="2-拦截错误操作"><a href="#2-拦截错误操作" class="headerlink" title="(2) 拦截错误操作"></a>(2) 拦截错误操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--用before events + select raise(ignore)拦截错误的操作</span></span><br><span class="line"><span class="comment">--触发器实现唯一约束(还需要一个before update的触发器就不多赘述了)</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R4</span><br><span class="line">before <span class="keyword">insert</span> <span class="keyword">on</span> College</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> College <span class="keyword">where</span> cName <span class="operator">=</span> New.cName)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">select</span> raise(ignore);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="3-实现复杂操作"><a href="#3-实现复杂操作" class="headerlink" title="(3) 实现复杂操作"></a>(3) 实现复杂操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--触发器能够实现约束不能实现的东西</span></span><br><span class="line"><span class="comment">--比如check中不能编写子查询和聚合函数，和General Assertions不被数据库支持的问题</span></span><br><span class="line"><span class="comment">--我们用when + select语句来监控并采取action</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R6</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> Apply</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> Apply <span class="keyword">where</span> cName <span class="operator">=</span> New.cName) <span class="operator">&gt;</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> College <span class="keyword">set</span> cName <span class="operator">=</span> cName <span class="operator">||</span> &quot;-Done&quot;  <span class="comment">-- ||运算符表示连接两个字符串</span></span><br><span class="line">    <span class="keyword">where</span> cName <span class="operator">=</span> New.cName;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="4-递归调用"><a href="#4-递归调用" class="headerlink" title="(4) 递归调用"></a>(4) 递归调用</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--默认情况下，SQLite要求触发器不能被递归调用，</span></span><br><span class="line"><span class="comment">--也就是说，一个事件的触发器在一次操作中只能触发一次</span></span><br><span class="line"><span class="comment">--下列语句将允许触发器的递归调用</span></span><br><span class="line">PRAGMA recursive_triggers <span class="operator">=</span> <span class="keyword">on</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--一个或多个触发器互相调用时，需要有终止条件防止死循环</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R1</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> T1</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> T2 <span class="keyword">values</span>(New.A <span class="operator">+</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R2</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> T2</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> T3 <span class="keyword">values</span>(New.A <span class="operator">+</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R3</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> T3</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="comment">--设置终止条件防止死循环</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">select</span>(<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> T1) <span class="operator">&lt;</span> <span class="number">100</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> T1 <span class="keyword">values</span>(New.A <span class="operator">+</span> <span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><h4 id="5-同个事件多个触发器的执行顺序"><a href="#5-同个事件多个触发器的执行顺序" class="headerlink" title="(5) 同个事件多个触发器的执行顺序"></a>(5) 同个事件多个触发器的执行顺序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--当一个事件有多个触发器时，率先触发的是较晚定义的触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R1</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> T1</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> T1 <span class="keyword">set</span> A <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> R2</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> T1</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> T1 <span class="keyword">where</span> A <span class="operator">=</span> <span class="number">2</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">update</span> T1 <span class="keyword">set</span> A <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--执行insert into T1 value(1);</span></span><br><span class="line"><span class="comment">--得到T1中属性A的值为2，说明R2先触发，R1晚触发</span></span><br></pre></td></tr></table></figure><hr><h1 id="三、事务-Transactions"><a href="#三、事务-Transactions" class="headerlink" title="三、事务(Transactions)"></a>三、事务(Transactions)</h1><h2 id="1-基本介绍-2"><a href="#1-基本介绍-2" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>通俗来讲，<strong>事务</strong>就是把<strong>许多语句当作一个整体</strong>来处理。</p><p>语句一般分为三个操作：get(取出数据); modify(修改数据); put(放回数据);<br>然而，当多个语句交叉在一起时，可能会出现属性、元组以及关系表上的结果不一致。<br>因此，我们需要<strong>将语句隔离</strong>开来。</p><p>同时，在进行大批量的语句操作时，如果系统突然崩溃，只有一半的语句被执行，我们需要有一个机制将剩余的语句执行，或者是将已执行的语句撤销，而不是将全部的语句再执行一遍。因此，我们在业务上将一批语句看作一个整体，称作事务，每个事务<strong>要么完全成功，要么完全失败</strong></p><p>在SQL标准中，用”commit”语句来表示一个事务的结束，同时也是下一个事务的开始。启动”Autocommit”模式时，每一条语句就是一个事务</p><h2 id="2-ACID特性"><a href="#2-ACID特性" class="headerlink" title="2. ACID特性"></a>2. ACID特性</h2><p>事务具有四大特性，可以总结为:</p><ol><li><strong>原子性(Atomicity)</strong>：一个事务要么<strong>完全成功</strong>，要么<strong>完全失败</strong></li><li><strong>一致性(Consistency)</strong>：每个事务执行前后都<strong>一直满足预定的约束</strong></li><li><strong>隔离性(Isolation)</strong>：事务中的操作可以交错，但是事务之间应该是<strong>串行</strong>执行的</li><li><strong>持久性(Durability)</strong>：就算系统崩溃，事务做的操作能够<strong>保留在数据库</strong>中</li></ol><h2 id="3-隔离级别-Isolation-Level"><a href="#3-隔离级别-Isolation-Level" class="headerlink" title="3. 隔离级别(Isolation Level)"></a>3. 隔离级别(Isolation Level)</h2><p>隔离级别越高，并发性越低，有时我们愿意牺牲一定的一致性去换取并发性。</p><p>隔离级别是<strong>针对每个事务</strong>而言，我们可以给不同的事务设置不同的隔离级别。</p><p>隔离级别从低到高依次为：</p><ol><li><strong>读未提交</strong>(Read Uncommitted)：允许该事务读取其他事务中，未commit的数据。我们称这种现象为<strong>脏读</strong>(Dirty reads)</li><li><strong>读提交</strong>(Read Committed)：不允许脏读，但是允许多次读取同一组数据。尽管不会出现脏读，但是不同时间读到的同一组数据的值可能会被另一个事务<strong>更新或删除</strong>，导致两次读取的值不同，我们称这种现象为<strong>不可重复读</strong>(Nonrepeatable reads)</li><li><strong>可重复读</strong>(Repeatable Read)：要求被多次读取的同一组数据不能被修改。但是我们在不同时间对表做查询操作时，可能会有另一个事务对该表做<strong>插入</strong>操作，导致第二次查询出现了原来没有的元组，我们称之为幻影元组(Phantom Tuples)，称这种现象为<strong>幻读</strong>(Phantom read)</li><li><strong>串行化</strong>(Serializable)：每个事务之间按照一定顺序执行</li></ol><p>SQL标准的默认隔离级别是Serializable，许多系统默认的隔离级别是：<strong>Repeatable Read</strong></p><p>除了设置事务的隔离级别，我们也可以设置事务为<strong>只读</strong>(Read Only)，使其不能对数据库做任何修改</p><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Set</span> Transaction Read <span class="keyword">Only</span>;</span><br><span class="line"><span class="keyword">Set</span> Transaction Isolation Level Repeatable Read;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">Avg</span>(GPA) <span class="keyword">From</span> student;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">Max</span>(GPA) <span class="keyword">From</span> student</span><br></pre></td></tr></table></figure></p><p>隔离级别对三个问题的解决程度如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">读未提交</td><td style="text-align:center">$\times$</td><td style="text-align:center">$\times$</td><td style="text-align:center">$\times$</td></tr><tr><td style="text-align:center">读提交</td><td style="text-align:center">$\surd$</td><td style="text-align:center">$\times$</td><td style="text-align:center">$\times$</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">$\surd$</td><td style="text-align:center">$\surd$</td><td style="text-align:center">$\times$</td></tr><tr><td style="text-align:center">串行化</td><td style="text-align:center">$\surd$</td><td style="text-align:center">$\surd$</td><td style="text-align:center">$\surd$</td></tr></tbody></table></div><hr><h1 id="四、视图-Views"><a href="#四、视图-Views" class="headerlink" title="四、视图(Views)"></a>四、视图(Views)</h1><h2 id="1-基本介绍-3"><a href="#1-基本介绍-3" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h2><p>视图是建立在关系模型之上的进一步抽象，它封装和隐藏底层的数据，只暴露需要的数据给用户。目的是简化查询，限制数据访问，提高安全性和提高性能。</p><p>视图包括两种：</p><ol><li>默认为虚拟<strong>视图</strong>(Virtual Views)，简称视图。视图是一个虚拟表，不存储任何数据</li><li><strong>物化视图</strong>(Materialized Views)，它占用存储空间，利用增量维护(incremental maintenance)算法使基表与视图保持同步</li></ol><p>当频繁查询且每次查询需要耗费大量资源时，我们使用物化视图</p><p>SQL标准下的视图语法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> [Materialized] <span class="keyword">View</span> vname(A1, A2, …, An) <span class="keyword">AS</span></span><br><span class="line"><span class="operator">&lt;</span>Query<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></p><p>SQLite示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--视图示例</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CSAccept <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> sID, cName</span><br><span class="line"><span class="keyword">from</span> Apply </span><br><span class="line"><span class="keyword">where</span> major <span class="operator">=</span><span class="string">&#x27;CS&#x27;</span><span class="keyword">and</span> decision <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--物化视图示例</span></span><br><span class="line"><span class="keyword">Create</span> Materialized <span class="keyword">View</span> CA<span class="operator">-</span>AppTy <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">Select</span> sID, cName, major </span><br><span class="line"><span class="keyword">From</span> Apply A </span><br><span class="line"><span class="keyword">where</span> cName <span class="keyword">In</span> (<span class="keyword">select</span> cName <span class="keyword">From</span> College <span class="keyword">where</span> state <span class="operator">=</span> <span class="string">&#x27;CA&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p>存在物化视图时，数据库会自动重写一些复杂的查询，以提高查询效率，如下<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Distinct</span> S.sID, S.GPA</span><br><span class="line"><span class="keyword">From</span> College C, Student S, Apply A</span><br><span class="line"><span class="keyword">Where</span> c.cName <span class="operator">=</span> A.cName <span class="keyword">And</span> S.sID <span class="operator">=</span> A.sID </span><br><span class="line">    <span class="keyword">And</span> S.GPA <span class="operator">&gt;</span> <span class="number">3.5</span> <span class="keyword">And</span> C.state <span class="operator">=</span> <span class="string">&#x27;CA&#x27;</span> <span class="keyword">And</span> A.major<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">--以上查询可以被重写为</span></span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">Distinct</span> S.sID, S.GPA</span><br><span class="line"><span class="keyword">From</span> Student S, CA<span class="operator">-</span>Apply A</span><br><span class="line"><span class="keyword">Where</span> S.sID <span class="operator">=</span> A.sID </span><br><span class="line">    <span class="keyword">And</span> S.GPA <span class="operator">&gt;</span> <span class="number">3.5</span> <span class="keyword">And</span> A.major <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br></pre></td></tr></table></figure></p><h2 id="2-视图的修改操作"><a href="#2-视图的修改操作" class="headerlink" title="2. 视图的修改操作"></a>2. 视图的修改操作</h2><h3 id="2-1-使用触发器"><a href="#2-1-使用触发器" class="headerlink" title="2.1 使用触发器"></a>2.1 使用触发器</h3><p>用<strong>INSTEAD OF</strong>接 对视图的修改操作，随后在指定动作中</p><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> CSAcceptDelete</span><br><span class="line">instead <span class="keyword">of</span> <span class="keyword">delete</span> <span class="keyword">on</span> CSAccept</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">delete</span> <span class="keyword">from</span> Apply </span><br><span class="line">    <span class="keyword">where</span> sID <span class="operator">=</span> Old.sID <span class="keyword">and</span> cName <span class="operator">=</span> Old.cName </span><br><span class="line">        <span class="keyword">and</span> major<span class="operator">=</span><span class="string">&#x27;cs&#x27;</span> <span class="keyword">and</span> decision <span class="operator">=</span><span class="string">&#x27;Y&#x27;</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure></p><p>使用触发器对视图修改，优点是能够处理所有的修改操作，只要我们对这些操作编写对应的触发器；缺点是我们无法保证这些修改就是有现实意义的。</p><h3 id="2-2-自动视图修改"><a href="#2-2-自动视图修改" class="headerlink" title="2.2 自动视图修改"></a>2.2 自动视图修改</h3><p>在SQL标准下，当视图满足以下条件时，可称为Updatable Views：</p><ol><li>只对一个表$T$查询，且不能使用DISTINCT</li><li>未被查询的其他值不能有非空约束，或者具有默认值</li><li>子查询中不能出现表$T$</li><li>不能出现分组查询(GROUP BY)和聚合查询</li></ol><p>Updatable Views保证了对视图做修改操作时不会出现歧义。</p><p>一般来说，我们<strong>对视图的修改</strong>会转化为对基表的修改，然后<strong>应该反映在视图</strong>中，而不是悄咪咪地在我们看不到的地方修改了基表的数据，简称，<strong>保证视图的一致性</strong>。</p><p>使用<strong>WITH CHECK OPTION</strong>可以让数据库自动为我们检查修改操作是否违背了一致性：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> CSEE <span class="keyword">as</span></span><br><span class="line"><span class="keyword">select</span> sID, cName, major</span><br><span class="line"><span class="keyword">from</span> Apply </span><br><span class="line"><span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> <span class="keyword">or</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span> </span><br><span class="line"><span class="keyword">with</span> <span class="keyword">check</span> option;</span><br><span class="line"></span><br><span class="line"><span class="comment">--当没有with check option时，</span></span><br><span class="line"><span class="comment">--执行insert into CSEE values(123, &#x27;CMU&#x27;, &#x27;biology&#x27;)是不被阻止的，但是是不安全的</span></span><br></pre></td></tr></table></figure></p><p>使用自动的视图修改，优点是不需要用户的介入就能完成修改操作；缺点很明显，就是需要满足严格的限制条件</p><hr><h1 id="五、授权-Authorization"><a href="#五、授权-Authorization" class="headerlink" title="五、授权(Authorization)"></a>五、授权(Authorization)</h1><p>不同的用户应该对数据库有不同的操作权限，这些权限应当由权限更大的用户进行授权</p><p>SQL标准下的授权和撤销权限操作如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--privs表示授予的权限：select(attName, ...), update(attName, ...)</span></span><br><span class="line"><span class="comment">--users表示获得权限的用户：public表示所有用户</span></span><br><span class="line"><span class="keyword">Grant</span> privs <span class="keyword">On</span> R <span class="keyword">To</span> users</span><br><span class="line">[ <span class="keyword">with</span> <span class="keyword">Grant</span> option ]</span><br><span class="line"></span><br><span class="line"><span class="comment">--Cascade表示级联撤销下级的权限，但是下级经由其他上级得到的授权不会被撤销</span></span><br><span class="line"><span class="comment">--Restrict表示需要从下往上逐级撤销权限</span></span><br><span class="line"><span class="keyword">Revoke</span> privs <span class="keyword">on</span> R <span class="keyword">From</span> users</span><br><span class="line">[Cascade <span class="operator">/</span> Restrict]</span><br></pre></td></tr></table></figure></p><p>MySQL中的授权和撤销权限操作如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询权限</span></span><br><span class="line"><span class="keyword">Show</span> Grants <span class="keyword">For</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--授予权限</span></span><br><span class="line"><span class="keyword">Grant</span> privs <span class="keyword">On</span> R <span class="keyword">To</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--撤销权限</span></span><br><span class="line"><span class="keyword">Revoke</span> privs <span class="keyword">on</span> R <span class="keyword">From</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 关系型数据库 </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS145 Intro to databases 学习笔记3——关系型数据库设计、XML的查询、UML</title>
      <link href="/2024/01/29/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E3%80%81XML%E7%9A%84%E6%9F%A5%E8%AF%A2%E3%80%81UML/"/>
      <url>/2024/01/29/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03%E2%80%94%E2%80%94%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E3%80%81XML%E7%9A%84%E6%9F%A5%E8%AF%A2%E3%80%81UML/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>晚上床上玩手机有点上头，导致一整天下午之前都没怎么精神刷课，于是调整了下学这套课程的排期，多排了一天嘻嘻，这下轻松多了。</p><p>本文是学习<strong>standford CS145 Introduction to Databases</strong>系列视频的第三篇笔记，主要包括第七章到第九章的内容：</p><ol><li>关系型数据库设计</li><li>XML的查询</li><li>统一建模语言(Unified Modeling Language， or UML)</li></ol><p>相关参考资料：</p><p>视频链接：<a href="https://www.youtube.com/playlist?list=PLroEs25KGvwzmvIxYHRhoGTz9w8LeXek0">Introduction to Databases - Jennifer Widom - Stanford</a></p><p>函数依赖、部分依赖、传递依赖等准备知识：<a href="https://blog.csdn.net/wyh7280/article/details/83350722">范式通俗理解：1NF、2NF、3NF和BNCF-CSDN博客</a></p><p>关系模式的分解原则：<a href="https://zhuanlan.zhihu.com/p/676907856">【数据库原理】（18）关系模式的分解 - 知乎 (zhihu.com)</a></p><p>三范式和BCNF的举例：<a href="https://blog.csdn.net/weixin_43954951/article/details/125494783">数据库三范式和BCNF范式的理解：生动举例-CSDN博客</a></p><p>3NF和BCNF的区别：<a href="https://techdifferences.com/difference-between-3nf-and-bcnf.html">Difference Between 3NF and BCNF (with Comparison Chart) - Tech Differences</a></p><p>组合和聚合：<a href="https://blog.csdn.net/m0_37989980/article/details/104470064/#5aggregtionspan_idj11span_169">UML一一 类图关系 (泛化、实现、依赖、关联、聚合、组合)_uml类图关系-CSDN博客</a></p><h1 id="一、关系型数据库设计"><a href="#一、关系型数据库设计" class="headerlink" title="一、关系型数据库设计"></a>一、关系型数据库设计</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>现有关系表$R$，关系表的所有属性的集合为$U$</p><p>设$X$、$Y$和$Z$皆为$R$上的一组属性，即$ X, Y, Z \subseteq U$</p><h3 id="1-1-函数依赖-Functional-Dependencies"><a href="#1-1-函数依赖-Functional-Dependencies" class="headerlink" title="1.1 函数依赖(Functional Dependencies)"></a>1.1 函数依赖(Functional Dependencies)</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="(1) 定义"></a>(1) 定义</h4><p>对 $ \forall t, u \in R$，如果 $t[X] = u[X]$，则有 $ t[Y] = u[Y]$，其中$ t[X]$代表取元组$t$所有$X$中的属性</p><p>则称，$Y$依赖于$X$，记为$X \rightarrow Y$</p><p>讲人话就是<strong>确定了$X$就确定了$Y$</strong>，称$Y$依赖于$X$</p><h4 id="2-Trivial-or-Nontrivial"><a href="#2-Trivial-or-Nontrivial" class="headerlink" title="(2) Trivial or Nontrivial"></a>(2) Trivial or Nontrivial</h4><p>trivial意为平常的、琐碎的、不重要的，所以trivial的Functional Dependency（以下简称FD）就是在讲废话，不能传递更多信息。</p><p>Trivial FD：当$ Y \subseteq X$，我们称$X \rightarrow Y$是 Trivial FD。因为确定了$X$肯定就确定了它的子集$Y$（讲废话</p><p>Nontivial FD：相对地，当$Y \nsubseteq X$，我们称 $ X \rightarrow Y$是 Nontrivial FD。</p><p>Complete nontrivial FD：当$X$和$Y$完全不重合时，即$ Y \cap X = \varnothing $，我们称$X \rightarrow Y$是 Complete nontrivial FD</p><h4 id="3-属性的闭包-Closure-of-Attributes"><a href="#3-属性的闭包-Closure-of-Attributes" class="headerlink" title="(3) 属性的闭包(Closure of Attributes)"></a>(3) 属性的闭包(Closure of Attributes)</h4><p>给定许多依赖$S$，和属性集$X$</p><p>设集合 $set  = X$</p><p>重复以下步骤直到$set$不发生改变:</p><p>如果有$A \rightarrow B$并且$A$在$set$当中，那么$ set  = set \cup B$</p><p>最后得到的$set$成为$X$在$S$上的闭包(Closure)，记作$X^+$</p><p>讲人话，闭包就是<strong>已知许多依赖$S$，确定了$X$后，能够确定的所有属性</strong></p><h3 id="1-2-部分依赖"><a href="#1-2-部分依赖" class="headerlink" title="1.2 部分依赖"></a>1.2 部分依赖</h3><p>当$ X \rightarrow Y$，取$X$的一子集$X’$，若$X’ \rightarrow Y$，则称$Y$部分依赖于$X$</p><p>讲人话就是<strong>确定了$X$中一部分值就能确定了$Y$</strong>，称$Y$部分依赖于$X$</p><h3 id="1-3-传递依赖"><a href="#1-3-传递依赖" class="headerlink" title="1.3 传递依赖"></a>1.3 传递依赖</h3><p>当$X \rightarrow Y$，并且$ Y \rightarrow Z$，并且$ Y \nrightarrow X$，则称$Z$传递依赖于$X$</p><p>讲人话就是<strong>确定了$X$能确定$Y$，确定了$Y$又能确定$Z$</strong>，并且<strong>确定了$Y$不能确定$X$</strong>（在范式比较中会提到为什么这么定义），就说$Z$传递依赖于$X$</p><h3 id="1-4-多值依赖-Multivalued-Dependencies-or-MVD"><a href="#1-4-多值依赖-Multivalued-Dependencies-or-MVD" class="headerlink" title="1.4 多值依赖(Multivalued Dependencies, or MVD)"></a>1.4 多值依赖(Multivalued Dependencies, or MVD)</h3><p>设$Z = U - X - Y$，即$Z$为属性集$U$中<strong>除了$X$和$Y$的剩余所有属性</strong></p><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="(1) 定义"></a>(1) 定义</h4><p>对 $ \forall t_1, t_2 \in R$，如果 $t_1[X] = t_2[X]$，则$\exists v \in R$，使得$v[X] = t_1[X] = t_2[X]$，并且$v[Y] = t_1[Y]$，并且$ v[Z] = t_2[Z]$，则称$Y$多值依赖$X$</p><p><strong>讲人话就是，如果有$(x, y_1, z_1)$和$(x, y_1, z_2)$，则必有$(x, y_1, z_2)$和$(x, y_2, z_1)$（Y和Z是对称的），则称$Y$多值依赖$X$，记作$ Y \twoheadrightarrow X$</strong></p><p>也就是说，确定了$X$为$x$时，$Y$和$Z$会有很多种取值$y_1, y_2, …, y_m$和$z_1, z_2, …, z_n$，$Y$和$Z$的取值的所有组合都会出现</p><p>从定义中，我们可以看出，判断$Y$是否多值依赖$X$，还需要考虑全属性集$U$。也就是说，同样的属性集$Y$和$X$，在不同的全属性集$U$中，它们可能多值依赖的关系不同。</p><h4 id="2-Trivial-or-Nontrivial-1"><a href="#2-Trivial-or-Nontrivial-1" class="headerlink" title="(2) Trivial or Nontrivial"></a>(2) Trivial or Nontrivial</h4><ol><li>Trivial MVD：当$X \cup Y = U$或$Y \subseteq X$时，称$ X \twoheadrightarrow Y$为 Trivial MVD。</li></ol><blockquote><p>如果有$(x, y_1, z_1)$和$(x, y_2, z_2)$</p><p>当$X \cup Y = U$时，$Z = \varnothing$，得$z_1 = z_2 = NULL$。那么$(x, y_1, z_2) = (x, y_1, NULL)$，$(x, y_2, z_1) = (x, y_2, NULL)$已经在表中，自行满足了多值依赖的条件，</p><p>当$Y \subseteq X$时，有$X \rightarrow Y$，得$y_1 = y_2$。那么$(x, y_1, z_2) = (x, y_2, z_2)$，$(x, y_2, z_1) = (x, y_1, z_1)$已经在表中自行满足了多值依赖的条件</p><p>所以满足以上其中一种条件的多值依赖不能传递更多的信息，可称为Trivial MVD</p></blockquote><ol><li>Nontrivial MVD：当$Y$和$X$不满足以上条件，则称$X \twoheadrightarrow Y$为Nontrivial MVD</li></ol><h2 id="2-分解关系模式-Decompostion-of-Relational-Schema"><a href="#2-分解关系模式-Decompostion-of-Relational-Schema" class="headerlink" title="2. 分解关系模式(Decompostion of Relational Schema)"></a>2. 分解关系模式(Decompostion of Relational Schema)</h2><h3 id="2-1-分解的原则"><a href="#2-1-分解的原则" class="headerlink" title="2.1 分解的原则"></a>2.1 分解的原则</h3><p>将关系$R(U)$分解为$R_1(U_1)$和$R_2(U_2)$后，应当满足：</p><ol><li>$U_1 \cup U_2 = U$</li><li>$R_1 \bowtie R_2 = R$ （无损连接性）</li></ol><p>实际上满足第二条就会满足第一条（小声</p><p>“Good” Decomposition，也就是一个好的分解，应当满足<strong>无损连接性</strong>（能通过自然连接得到原始表）和<strong>依赖保留性</strong>（能在每个表中直接得到原来的所有依赖），详见前言中的参考资料</p><h3 id="2-2-BCNF分解"><a href="#2-2-BCNF分解" class="headerlink" title="2.2 BCNF分解"></a>2.2 BCNF分解</h3><h4 id="1-BCNF的定义"><a href="#1-BCNF的定义" class="headerlink" title="(1) BCNF的定义"></a>(1) BCNF的定义</h4><blockquote><p>注意：在实际情况中，可能不止有一组元素能够作为主键，比如$X^+ = U$，$Y^+ = U$，那么称$X$和$Y$都为<strong>超键</strong>，去掉超键中任意属性会使其不再为超键的，叫做<strong>候选键</strong>，我们可以在多个候选键中选一个叫<strong>主键</strong>。</p><p>假设$X$和$Y$都是候选键，$X \cup Y$也就是$X$和$Y$中的所有元素都称作主属性。而<strong>不是只有我们选定的主键中的元素才叫做主属性</strong></p></blockquote><p>对$R$中任一nontrivial FD$X \rightarrow Y$，$X$都是候选键的超集，那么就称$R$满足 鲍依斯-科得范式(Boyce Codd Normal Form, or BCNF)</p><h4 id="2-BCNF分解算法"><a href="#2-BCNF分解算法" class="headerlink" title="(2) BCNF分解算法"></a>(2) BCNF分解算法</h4><p>找到$R$中的候选键</p><p>重复以下步骤直到所有的关系都满足BCNF:</p><ol><li>关系$R’$的依赖$A \rightarrow B$不满足BCNF</li><li>将$R’$ 分解为 $R_1 = (A, B)$和$ R_2(A, rest)$，$rest$为$A$和$B$之外的剩余部分</li><li>找到$R_1$和$R_2$中的FD和候选键</li></ol><h3 id="2-3-4NF分解"><a href="#2-3-4NF分解" class="headerlink" title="2.3 4NF分解"></a>2.3 4NF分解</h3><h4 id="1-4NF的定义"><a href="#1-4NF的定义" class="headerlink" title="(1) 4NF的定义"></a>(1) 4NF的定义</h4><p>对$R$中任一nontrivial MVD$X \twoheadrightarrow Y$，$X$都是候选键的超集，那么就称$R$满足4NF</p><h4 id="2-4NF分解算法"><a href="#2-4NF分解算法" class="headerlink" title="(2) 4NF分解算法"></a>(2) 4NF分解算法</h4><p>找到$R$中的候选键</p><p>重复以下步骤直到所有的关系都满足4NF:</p><ol><li>关系$R’$的依赖$A \twoheadrightarrow B$不满足4NF</li><li>将$R’$ 分解为 $R_1 = (A, B)$和$ R_2(A, rest)$，$rest$为$A$和$B$之外的剩余部分</li><li>找到$R_1$和$R_2$中的MVD和候选键</li></ol><h2 id="3-范式之间的比较"><a href="#3-范式之间的比较" class="headerlink" title="3. 范式之间的比较"></a>3. 范式之间的比较</h2><h3 id="3-1-每一层范式解决的问题"><a href="#3-1-每一层范式解决的问题" class="headerlink" title="3.1 每一层范式解决的问题"></a>3.1 每一层范式解决的问题</h3><ul><li>1NF：每个元组的每个属性的值不能是集合，不可再分关系。1NF是$R$作为关系模型的最基本的条件</li><li>2NF：在1NF的基础上消除了<strong>非主属性对候选键的部分依赖</strong>，也就是非主属性不能只依赖于一部分主属性，应该完全依赖于所有主属性。</li><li>3NF：在2NF的基础上消除了<strong>非主属性对候选键的传递依赖</strong>。也就是非主属性不能依赖于其他非主属性，应该直接完全依赖于所有主属性。</li></ul><blockquote><p>前面我们讲到了传递依赖的定义：</p><p>当$X \rightarrow Y$，并且$ Y \rightarrow Z$，并且$ Y \nrightarrow X$，则称$Z$传递依赖于$X$</p><p>这里要求$ Y \nrightarrow X$是因为，如果$ Y \rightarrow X$，那么$Z$部分依赖于$Y$，而部分依赖已经在2NF中消除了。</p><p><strong>3NF究竟还遗留了哪些问题？</strong></p><p>我们现在只解决了主属性和非主属性之间的冗余，而BCNF希望解决多个候选键之间，也就是主属性之间的冗余。</p><p>当然，如果关系中只有一个候选键，那么3NF和BCNF其实没什么区别。要举出有多个后续键的例子比较困难，所以很难区分喵qwq</p></blockquote><ul><li>BCNF：在3NF的基础上消除了<strong>候选键之间的部分依赖和传递依赖</strong>。</li></ul><blockquote><p>至此，我们已经解决的冗余都是针对依赖关系而言，而依赖是一对一的。</p><p>倘若我们有$X \twoheadrightarrow Y$，剩余部分为$Z$，其中$X$对$Y$是1对m，$X$对$Z$是1对n，他们的组合就有$m \times n$个元组，而实际上用两个表$R_1$和$R_2$共$m + n$个元组就能表示这两个一对多的关系，而且$R_1 \bowtie R_2 = R$也符合分解的原则。</p></blockquote><ul><li>4NF：在BCNF的基础上<strong>消除了nontrivial MVD</strong>。</li></ul><h3 id="3-2-BCNF和4NF的不足"><a href="#3-2-BCNF和4NF的不足" class="headerlink" title="3.2 BCNF和4NF的不足"></a>3.2 BCNF和4NF的不足</h3><p>BCNF和4NF会对所有FD和MVD做检查和分解，当分解出来的表的属性过少时，我们需要对多个表做自然连接才能验证我们原来的FD和MVD，对查询不是很友好，所以应该尽量<strong>先选择能保留更多属性</strong>的分解。然后具体问题具体分析，权衡好查询负载(Query Workload)和过分解(Over Decomposition)之间的关系。</p><h1 id="二、XML的查询"><a href="#二、XML的查询" class="headerlink" title="二、XML的查询"></a>二、XML的查询</h1><h2 id="1-XPath"><a href="#1-XPath" class="headerlink" title="1. XPath"></a>1. XPath</h2><p>视频中关于XPath的语法都能在这里找到：<a href="https://www.runoob.com/xpath/xpath-tutorial.html">XPath 教程 | 菜鸟教程 (runoob.com)</a></p><p>主要列举一些示例方便快速复习：</p><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 谓语(Predicates)：将用于查找某些特定节点的条件嵌入到方括号[]中，将其称之为谓语</span><br><span class="line">// 查询价格小于<span class="number">90</span>且存在作者的姓是Ullman的一本书</span><br><span class="line">// 注意：[]中的条件只针对存在<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/Book[@Price &lt; <span class="number">90</span> <span class="keyword">and</span></span><br><span class="line">    Authors/Author/Last_Name =<span class="string">&quot;Ullman&quot;</span> ]/Title  </span><br></pre></td></tr></table></figure><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 内置函数(Built-in Functions)</span><br><span class="line">// 查询Remark属性中包含<span class="string">&quot;great&quot;</span>的书<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)//Book<span class="built_in">[contains</span>(Remark, <span class="string">&quot;great&quot;</span> )]/Title</span><br></pre></td></tr></table></figure><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// self join<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)//Magazine[Title = </span><br><span class="line">   <span class="built_in"> doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)//Book/Title]</span><br></pre></td></tr></table></figure><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// axes(轴)</span><br><span class="line">// 查询所有父节点不为Bookstore和不为Book的节点<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore//*<span class="built_in">[name</span>(<span class="literal">parent::</span>*)!=<span class="string">&quot;Bookstore&quot;</span></span><br><span class="line">    <span class="keyword">and</span><span class="built_in"> name</span>(<span class="literal">parent::</span>*)!=<span class="string">&quot;Book&quot;</span>]</span><br><span class="line">// 查询所有跟同层级节点有相同Title的Book或Magzine<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/(Book|Magazine)[Title = </span><br><span class="line">    <span class="literal">following-sibling::</span>*/Title <span class="keyword">or</span> Title = <span class="literal">preceding-sibling::</span>*/Title]</span><br></pre></td></tr></table></figure><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由于谓语只能表示<span class="string">&quot;存在&quot;</span><span class="built_in">(exists</span>)关系，当我们想表示<span class="string">&quot;任意&quot;</span>(forall)时，需要使用内置函<span class="built_in">数count</span></span><br><span class="line">// 查询所有作者的First_Name都包含<span class="string">&#x27;J&#x27;</span>的书<span class="built_in"></span></span><br><span class="line"><span class="built_in">doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)//Book[</span><br><span class="line">   <span class="built_in"> count</span>(Authors/Author<span class="built_in">[contains</span>(First_Name,<span class="string">&quot;J”)]) = </span></span><br><span class="line"><span class="string">    count(Authors/Author/First_Name)]</span></span><br></pre></td></tr></table></figure><h2 id="2-XQuery"><a href="#2-XQuery" class="headerlink" title="2. XQuery"></a>2. XQuery</h2><p>视频中大多数的语法能在这里找到：<a href="https://www.runoob.com/xquery/xquery-tutorial.html">XQuery 教程 | 菜鸟教程 (runoob.com)</a></p><p>内置函数需要在XPath中查询：<a href="https://www.runoob.com/xpath/xpath-functions.html">XPath、XQuery 以及 XSLT 函数 | 菜鸟教程 (runoob.com)</a></p><p>限定表达式等在上述链接找不到，可以在这里看：<a href="https://learn.microsoft.com/zh-cn/sql/xquery/quantified-expressions-xquery?view=sql-server-ver16">限定表达式 (XQuery) - SQL Server | Microsoft Learn</a></p><h3 id="2-1-FLWOR表达式"><a href="#2-1-FLWOR表达式" class="headerlink" title="2.1 FLWOR表达式"></a>2.1 FLWOR表达式</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For <span class="variable">$var</span> <span class="keyword">in</span> expr</span><br><span class="line">Let <span class="variable">$var</span> := expr</span><br><span class="line">Where condition</span><br><span class="line">Order <span class="keyword">by</span> expr</span><br><span class="line">Return expr</span><br></pre></td></tr></table></figure><h3 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2 代码示例"></a>2.2 代码示例</h3><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 查询价格小于<span class="number">90</span>且存在作者的姓是Ullman的一本书</span><br><span class="line"><span class="keyword">for</span> <span class="variable">$b</span> <span class="keyword">in</span><span class="built_in"> doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/Book</span><br><span class="line"><span class="keyword">where</span> <span class="variable">$b</span>/@Price &lt; <span class="number">90</span> </span><br><span class="line"> <span class="keyword">and</span> <span class="variable">$b</span>/Authors/Author/Last_Name = <span class="string">&quot;Ullman&quot;</span></span><br><span class="line"><span class="keyword">return</span> <span class="variable">$b</span>/Title</span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">$b</span> <span class="keyword">in</span><span class="built_in"> doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/Book</span><br><span class="line"></span><br><span class="line">// 限定表达式 ( <span class="keyword">some</span> | <span class="keyword">every</span> ) <span class="language-xml"><span class="tag">&lt;<span class="name">variable</span>&gt;</span> in </span><span class="language-xml"><span class="tag">&lt;<span class="name">Expression</span>&gt;</span> (,...) satisfies </span><span class="language-xml"><span class="tag">&lt;<span class="name">Expression</span>&gt;</span>  </span></span><br><span class="line"><span class="language-xml">// some表示&quot;存在&quot;  every表示&quot;任意&quot;</span></span><br><span class="line"><span class="language-xml">// 查询Title中存在作者的First_Name的Book</span></span><br><span class="line"><span class="language-xml">where some $fn in $b/Authors/Author/First_Name satisfies</span></span><br><span class="line"><span class="language-xml">    contains($b/Title, $fn)</span></span><br><span class="line"><span class="language-xml">    </span></span><br><span class="line"><span class="language-xml">// 构造返回结果    </span></span><br><span class="line"><span class="language-xml">return </span><span class="language-xml"><span class="tag">&lt;<span class="name">Book</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        </span><span class="language-xquery">&#123; <span class="variable">$b</span>/Title &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        </span><span class="language-xquery">&#123; <span class="variable">$b</span>/Authors/Author/First_Name &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Book</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 聚合函数</span><br><span class="line">// 查询所有Book的Price的平均值</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Average</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="language-xquery">&#123; <span class="keyword">let</span> <span class="variable">$plist</span> :=<span class="built_in"> doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/Book/@Price</span></span><br><span class="line"><span class="language-xquery">    <span class="keyword">return</span><span class="built_in"> avg</span>(<span class="variable">$plist</span>)&#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Average</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">$b</span> <span class="keyword">in</span><span class="built_in"> doc</span>(<span class="string">&quot;BookstoreQ.xml&quot;</span>)/Bookstore/Book</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="variable">$b</span>/@Price</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Book</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         </span><span class="language-xquery">&#123; <span class="variable">$b</span>/Title &#125;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">         </span><span class="language-xml"><span class="tag">&lt;<span class="name">Price</span>&gt;</span></span><span class="language-xquery">&#123; <span class="variable">$b</span>/data(@Price))&lt;/Price&gt;</span></span><br><span class="line"><span class="language-xquery">       &lt;/Book&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 过滤重复值</span><br><span class="line">//<span class="built_in"> distinct-values</span>返回 值的列表，而不是 节点的列表</span><br><span class="line"><span class="keyword">for</span> <span class="variable">$n</span> <span class="keyword">in</span><span class="built_in"> distinct-values</span><span class="built_in">(doc</span>(<span class="string">&quot;Bookstore0.xml&quot;</span> )//Last_Name)</span><br><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Last_Name</span>&gt;</span> </span><span class="language-xquery">&#123;<span class="variable">$n</span>&#125;</span><span class="language-xml"> <span class="tag">&lt;/<span class="name">Last_Name</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="3-XSLT-EXtensible-Stylesheet-Language"><a href="#3-XSLT-EXtensible-Stylesheet-Language" class="headerlink" title="3. XSLT(EXtensible Stylesheet Language)"></a>3. XSLT(EXtensible Stylesheet Language)</h2><p>XSLT支持将XML转换为其他文档，比如XHTML。对XML的转换也可以看作是查询和构造结果</p><p>示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsl:stylesheet</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span> <span class="attr">xmins:xsl</span>=<span class="string">&quot;http://mmr.w3.org/1999/XSl/Transform&quot;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="attr">xsl:output</span> <span class="attr">method</span>=<span class="string">&quot;xml&quot;</span> <span class="attr">indent</span>=<span class="string">&quot;yes&quot;</span> <span class="attr">onit-xml-declaration-</span>&quot;<span class="attr">yes</span>&quot; /&gt;</span></span><br><span class="line">//外层是基本格式</span><br><span class="line"></span><br><span class="line">// template + match匹配特定节点</span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;Book&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">BookTitle</span>&gt;</span></span><br><span class="line">    // 选择特定节点中的子节点并构造返回结果</span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;Title&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">BookTitle</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;Magazine&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">MagazineTitle</span>&gt;</span> <span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;Title&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">MagazineTitle</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:stylesheet</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 不等号需要使用转义 小于号：$lt;  大于号$gt;</span><br><span class="line">// copy-of + select返回选择到的节点</span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;Book[@Price <span class="symbol">&amp;lt;</span> 90]&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsl:copy-of</span> <span class="attr">select</span>=<span class="string">&quot;.&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 不满足所有匹配的节点和属性会成串返回，因此得作以下处理</span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;text()&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// 更加具体的限定条件所构造的匹配，优先度更高</span><br><span class="line">// 当节点同时满足两个优先度相同的匹配规则时（最好不要，会报错），以最后一个匹配规则为结果</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// apply-templates + select 将 template + select 的结果嵌入其中</span><br><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;*|@*|text()&quot;</span></span></span><br><span class="line"><span class="tag">    &lt;<span class="attr">xsl:copy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsl:apply-templates</span> <span class="attr">select</span>=<span class="string">&quot;*|@*|text()/&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">    &lt;/xsl:copy&gt;</span></span></span><br><span class="line"><span class="string"><span class="tag">&lt;/xsl:template&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsl:template</span> <span class="attr">match</span>=<span class="string">&quot;/&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>My CD Collection<span class="tag">&lt;/<span class="name">h2</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">bgcolor</span>=<span class="string">&quot;#9acd32&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">th</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Artist<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">        // for-each + select 遍历选择到的所有节点</span><br><span class="line">        <span class="tag">&lt;<span class="name">xsl:for-each</span> <span class="attr">select</span>=<span class="string">&quot;catalog/cd&quot;</span>&gt;</span> </span><br><span class="line">            // if + test 选择满足条件的节点</span><br><span class="line">            <span class="tag">&lt;<span class="name">xsl:if</span> <span class="attr">test</span>=<span class="string">&quot;price <span class="symbol">&amp;gt;</span> 10&quot;</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;title&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;artist&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">xsl:value-of</span> <span class="attr">select</span>=<span class="string">&quot;price&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">xsl:if</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsl:for-each</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">xsl:template</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="三、统一建模语言-UML"><a href="#三、统一建模语言-UML" class="headerlink" title="三、统一建模语言(UML)"></a>三、统一建模语言(UML)</h1><p>UML用图形化的表示方法描述对数据模型作建模，可以直接翻译为关系模型</p><h2 id="1-类-Classes"><a href="#1-类-Classes" class="headerlink" title="1. 类(Classes)"></a>1. 类(Classes)</h2><p>关系模型中的每一个表可以描述为一个了类，如</p><p>Student(<u>sID</u>, sName, GPA)</p><p>可以与下述模型互相转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-----------+</span><br><span class="line">|  Student  |</span><br><span class="line">+-----------+</span><br><span class="line">|   sID pk  |</span><br><span class="line">|   sName   |</span><br><span class="line">|    GPA    |</span><br><span class="line">+-----------+</span><br><span class="line">| &lt;methods&gt; |     </span><br><span class="line">+-----------+</span><br></pre></td></tr></table></figure><h2 id="2-关联-和-关联类-Associations-and-Association-Classes"><a href="#2-关联-和-关联类-Associations-and-Association-Classes" class="headerlink" title="2. 关联 和 关联类(Associations and Association Classes)"></a>2. 关联 和 关联类(Associations and Association Classes)</h2><p>一个类跟另一个类有联系，即有关联，可以有一条线将两个类相连来表示，而关联所产生的附加信息我们可以用一个关联类表示，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------+               +-------+  </span><br><span class="line">|   C1  |  Association  |   C2  |</span><br><span class="line">+-------+-------+-------+-------+</span><br><span class="line">|   A1  |       |       |   A2  |</span><br><span class="line">+-------+       |       +-------+</span><br><span class="line">                |</span><br><span class="line">             +--+----+ </span><br><span class="line">             |  C3   |</span><br><span class="line">             +-------+</span><br><span class="line">             |  A3   | </span><br><span class="line">             +-------+             </span><br></pre></td></tr></table></figure><p>其中C1和C2关联到对方的数量可能不同，比如一个学生只能选一个专业，记为1..1，一个专业有至少一个学生修读，记为1..*，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------+               +-------+  </span><br><span class="line">|   C1  |  Association  |   C2  |</span><br><span class="line">+-------+-------+-------+-------+</span><br><span class="line">|   A1  |1..*   |   1..1|   A2  |</span><br><span class="line">+-------+       |       +-------+</span><br><span class="line">                |</span><br><span class="line">             +--+----+ </span><br><span class="line">             |  C3   |</span><br><span class="line">             +-------+</span><br><span class="line">             |  A3   | </span><br><span class="line">             +-------+             </span><br></pre></td></tr></table></figure><p>实际上，如果对应的数量是0..1或者1..1，那么关联表是多余的，可以将关联的属性归到C1中，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-------+               +-------+  </span><br><span class="line">|   C1  |  Association  |   C2  |</span><br><span class="line">+-------+-------+-------+-------+</span><br><span class="line">|   A1  |1..*       1..1|   A2  |</span><br><span class="line">|   A3  |               +-------+</span><br><span class="line">+-------+                                      </span><br></pre></td></tr></table></figure></p><h2 id="3-子类-Subclasses"><a href="#3-子类-Subclasses" class="headerlink" title="3. 子类(Subclasses)"></a>3. 子类(Subclasses)</h2><p>一个父类可以有很多个子类，子类拥有父类的主键和额外的属性或关联，如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">            +------+</span><br><span class="line">            |  C1  |</span><br><span class="line">            +------+</span><br><span class="line">            |  K pk|</span><br><span class="line">            |  A1  |</span><br><span class="line">            +--+---+</span><br><span class="line">               |</span><br><span class="line"> +-------------+------------+</span><br><span class="line"> |             |            |</span><br><span class="line"> |             |            |</span><br><span class="line">+--+--+    +--+--+         +-------+               +-------+  </span><br><span class="line">| C2  |    |  C3 |         |   C4  |  Association  |   C5  |</span><br><span class="line">+-----+    +-----+         +-------+---------------+-------+</span><br><span class="line">| A2  |    |  A3 |         |   A4  |               |   A5  |</span><br><span class="line">+-----+    +-----+         +-------+               +-------+ </span><br></pre></td></tr></table></figure></p><p>不完整/完整(<strong>incomplete</strong>/<strong>complete</strong>)：</p><p>当子类能够表示所有的情况时，我们说这些子类是complete的，否则则是incomplete的</p><p>重叠/不相交 (<strong>overlapping</strong>/<strong>disjoint</strong>)：</p><p>当有对象能够同时属于多个子类时，我们说这些子类是overlapping的，否则则是disjoint的</p><p>将带子类的UML翻译为关系模型有多种办法：</p><ol><li>父类建表，每一个子类就是一个表，只包含子类的属性和父类的主键，适用于disjoint + incomplete的情况</li><li>父类可不建表，每一个子类就是一个表，它不仅包含子类的属性和父类的主键，也包含父类的属性，适用于disjoint + complete的情况</li><li>用一个表包含父类和所有子类的属性：适用于heavily overlapping的情况</li></ol><blockquote><ol><li>Subclass relations contain superclass key+ specialized attrs</li><li>Subclass relations contain all attributes</li><li>One relation containing all superclass + subclass attrs.</li></ol></blockquote><h2 id="4-组合和聚合-Composition-and-Aggregation"><a href="#4-组合和聚合-Composition-and-Aggregation" class="headerlink" title="4. 组合和聚合(Composition and Aggregation)"></a>4. 组合和聚合(Composition and Aggregation)</h2><p>组合和聚合都是关联的特例，强调整体和部分的关系，在转换为关系模型时跟关联没有区别，但是在UML中的描述存在语义上的区别。</p><p>组合中的整体和部分具有强依赖，<strong>整体的对象负责部分的对象的生命周期</strong>，如鸟和翅膀</p><p>而聚合的<strong>整体和部分可以独立存在</strong>，如汽车和轮胎，部门和员工</p><p>详见前言中的参考资料。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 关系型数据库 </tag>
            
            <tag> XML </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS145 Intro to databases 学习笔记2——Relational Algebra、SQL</title>
      <link href="/2024/01/27/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94Relational%20Algebra%E3%80%81SQL/"/>
      <url>/2024/01/27/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%E2%80%94%E2%80%94Relational%20Algebra%E3%80%81SQL/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文是学习<strong>standford CS145 Introduction to Databases</strong>系列视频的第二篇笔记，内容主要包括第五章和第六章查询Relational Model的两种表达形式:</p><ol><li>关系代数(Relational Algebra)</li><li>SQL</li></ol><p>视频链接：<a href="https://www.youtube.com/playlist?list=PLroEs25KGvwzmvIxYHRhoGTz9w8LeXek0">Introduction to Databases - Jennifer Widom - Stanford</a></p><h1 id="一、Relational-Algebra"><a href="#一、Relational-Algebra" class="headerlink" title="一、Relational Algebra"></a>一、Relational Algebra</h1><h2 id="1-基本的运算符"><a href="#1-基本的运算符" class="headerlink" title="1. 基本的运算符"></a>1. 基本的运算符</h2><p>在下述表述中，$E$代表表达式，可以为任意下述符号和关系（也就是表）的组合</p><p>$\Pi_{A_1, A_2, …, A_n} (E)$： <strong>project运算</strong>，$A_1, A_2, …, A_n$为列名，用于<strong>取出特定的几列</strong></p><p>$\sigma_{condition} (E)$：<strong>select运算</strong>，$condition$表示应当满足的条件，用于<strong>筛选特定的几行</strong></p><p>$E_1 \times E_2$：<strong>叉积运算</strong>，<strong>取$E_1$的所有元组和$E_2$的所有元组做组合</strong>，结果行数为两者行数的乘积，列数为两者列数之和</p><p>$E_1 \cup E_2$：<strong>并运算</strong>，为二元运算符，其中，$E_1$和$E_2$应有相同的结构，结果为<strong>两者元组之和去除重复行</strong></p><p>$E_1 - E_2$：<strong>差运算</strong>，为二元运算符，对于其中，$E_1$和$E_2$应有相同的结构，结果为<strong>前者去除重复行</strong></p><p>$\rho_{R(A_1, A_2, …, A_n)} (E) $：<strong>rename运算</strong>，其中$R(A_1, A_2, …, A_n)$代表<strong>某种方法$R$，将$E$中的每一列依次重命名为$A_1, A_2, …, A_n$。</strong></p><h2 id="2-其他常用运算符"><a href="#2-其他常用运算符" class="headerlink" title="2. 其他常用运算符"></a>2. 其他常用运算符</h2><p>以下常用运算符可以由基本的运算符所组合而成，不会增加原有符号体系的表达能力，只是便于书写和更精炼的表达</p><p>$E_1 \bowtie E_2$: <strong>自然连接(natural join)</strong>，相当于<strong>叉积运算后，取相同列名的值相同的元组作为结果</strong>，即</p><blockquote><script type="math/tex; mode=display">E_1 \bowtie E_2 = \Pi_{Shema_1 \cup Shema_2} (\sigma_{E_1.A_1 = E_2.A_1, E_1.A_2 = E_2.A_2,..., E_1.A_n = E_2.A_n} ( E_1 \times E_2))</script></blockquote><p>$E_1 \bowtie_{\theta} E_2$: <strong>$\theta$连接(theta join)</strong>，相当于<strong>叉积运算后，保留满足条件$\theta$的元组作为结果</strong>，即</p><blockquote><script type="math/tex; mode=display">E_1 \bowtie_{\theta} E_2 = \Pi_{Shema_1 \cup Shema_2} (\sigma_{\theta} ( E_1 \times E_2))</script></blockquote><p>$E_1 \cap E_2$：<strong>交运算</strong>，，其中，$E_1$和$E_2$应有相同的结构，结果为<strong>两者元组的所有重复行</strong>，可以由并运算和差运算表达，如下：</p><blockquote><script type="math/tex; mode=display">E_1 \cap E_2 = E_1 - (E_1 - E_2)</script></blockquote><h1 id="二、-SQL"><a href="#二、-SQL" class="headerlink" title="二、 SQL"></a>二、 SQL</h1><h2 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="1. 基本查询"></a>1. 基本查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  A_1, A_2, ..., A_n </span><br><span class="line"><span class="keyword">FROM</span>  R_1, R_2, ..., R_n </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span> </span><br></pre></td></tr></table></figure><p>上述语句相当于关系代数中的：</p><script type="math/tex; mode=display">\Pi_{A_1, A_2, ..., A_n} ( \sigma_{condition} (R_1 \times R_2 \times ... \times R_n))</script><p>由关系代数表达式，不难得到语句执行的顺序为，<strong>先FROM，再WHERE，最后再SELECT</strong></p><p>注意：SQL基于multiset，允许重复元组的存在，而关系代数基于set，不允许重复元组</p><p>示例：</p><p>本节所有示例均基于三个表，结构如下<br>College(<u>cName</u>, state, enrollment) 主键为cName<br>student(<u>sID</u>, sName, GPA, sizeHS) 主键为sID<br>Apply(<u>sID</u>, <u>cName</u>, <u>major</u>, decision) 主键为sID, cName, major</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> student.sID, sName, GPA, Apply.cName, enrollment</span><br><span class="line"><span class="keyword">from</span> student, college, Apply</span><br><span class="line"><span class="keyword">where</span> Apply.sID <span class="operator">=</span> student.sID <span class="keyword">and</span> Apply.cName <span class="operator">=</span> College.cName <span class="comment">--and连接多个条件</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> GPA <span class="keyword">desc</span>; <span class="comment">--order by attName 按属性升序, order by arrName desc 按属性降序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sID, major</span><br><span class="line"><span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">where</span> major <span class="keyword">like</span> <span class="string">&#x27;%bio%&#x27;</span>; <span class="comment">--like接模式串可模糊查询</span></span><br></pre></td></tr></table></figure><h2 id="2-表变量和集合运算符"><a href="#2-表变量和集合运算符" class="headerlink" title="2. 表变量和集合运算符"></a>2. 表变量和集合运算符</h2><h3 id="2-1-表变量-Table-Variables"><a href="#2-1-表变量-Table-Variables" class="headerlink" title="2.1 表变量(Table Variables)"></a>2.1 表变量(Table Variables)</h3><p>可以在FROM后的表达式，为<strong>每个关系赋别名</strong>将其区分开，由于FROM是较先执行的，别名可以在WHERE和SELECT中出现，示例如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询GPA相等的两个学生的信息</span></span><br><span class="line"><span class="keyword">select</span> s1.sID, s1.sName, s1.GPA, s2.sID, s2.sName, s2.GPA</span><br><span class="line"><span class="keyword">from</span> student sl,student s2</span><br><span class="line"><span class="keyword">where</span> s1.GPA <span class="operator">=</span> s2.GPA <span class="keyword">and</span> s1.sID <span class="operator">&lt;&gt;</span> s2.sID;</span><br></pre></td></tr></table></figure><p>后续可将复杂的查询结果命名为一个临时表，用于简化语句，详见”3.子查询 3.2from中的子查询”</p><h3 id="2-2-集合运算符-Set-Operators"><a href="#2-2-集合运算符-Set-Operators" class="headerlink" title="2.2 集合运算符(Set Operators)"></a>2.2 集合运算符(Set Operators)</h3><p>并运算：union去除重复行并作排序，union all保留重复行且不作排序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--在select后接 as newName重命名列名</span></span><br><span class="line"><span class="comment">--对结构相同的两个关系做并运算</span></span><br><span class="line"><span class="keyword">select</span> cName <span class="keyword">as</span> name <span class="keyword">from</span> Co1lege </span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> sName <span class="keyword">as</span> name <span class="keyword">from</span> Student;</span><br></pre></td></tr></table></figure></p><p>交运算：intersect<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询申请了CS且申请了EE的学生的ID</span></span><br><span class="line"><span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line"><span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--相当于</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> A1.sID <span class="comment">--加distinct是由于叉积运算时，其他属性如cName不同会使结果的sID存在重复</span></span><br><span class="line"><span class="keyword">from</span> Apply A1, Apply A2 </span><br><span class="line"><span class="keyword">where</span> A1.sID <span class="operator">=</span> A2.sID <span class="keyword">and</span> A1.major <span class="operator">=</span><span class="string">&#x27;CS&#x27;</span> <span class="keyword">and</span> A2.major <span class="operator">=</span><span class="string">&#x27;EE&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--in 在后续&quot;子查询&quot;中介绍</span></span><br><span class="line"><span class="comment">--也相当于</span></span><br><span class="line"><span class="keyword">select</span> sID</span><br><span class="line"><span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">where</span> sID <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> )</span><br><span class="line"><span class="keyword">and</span> sID <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p>差运算：except<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询申请了CS但没有申请EE的学生的ID</span></span><br><span class="line"><span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">except</span></span><br><span class="line"><span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--相当于</span></span><br><span class="line"><span class="keyword">select</span> sID</span><br><span class="line"><span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">where</span> sID <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> )</span><br><span class="line"><span class="keyword">and</span> sID <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h2 id="3-子查询-Subqueries"><a href="#3-子查询-Subqueries" class="headerlink" title="3. 子查询(Subqueries)"></a>3. 子查询(Subqueries)</h2><h3 id="3-1-where中的子查询"><a href="#3-1-where中的子查询" class="headerlink" title="3.1 where中的子查询"></a>3.1 where中的子查询</h3><p>(1) in / not in</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sID</span><br><span class="line"><span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">where</span> sID <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> )</span><br><span class="line"><span class="keyword">and</span> sID <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> Apply <span class="keyword">where</span> major <span class="operator">=</span> <span class="string">&#x27;EE&#x27;</span>)</span><br></pre></td></tr></table></figure><p>(2) exists / not exists ：往往在from为表起别名，在where的exists后接表达式使其满足一定条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询所在州有其他学校的学校的名字和所在州名</span></span><br><span class="line"><span class="keyword">select</span> cName, state</span><br><span class="line"><span class="keyword">from</span> College c1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> College C2 <span class="keyword">where</span> c2.state <span class="operator">=</span> c1.state);</span><br><span class="line"></span><br><span class="line"><span class="comment">--查询GPA最高的学生的名字</span></span><br><span class="line"><span class="keyword">select</span> sName</span><br><span class="line"><span class="keyword">from</span> student C1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Student C2 <span class="keyword">where</span> C2.GPA <span class="operator">&gt;</span> C1.GPA); </span><br><span class="line"><span class="comment">--不存在比C1的GPA要高的C2，即C1的GPA最高</span></span><br></pre></td></tr></table></figure><p>(3) op any / op all (op为运算符：&lt;, &gt;, =, …)：<br>   any相当于数学意义的存在符号$\exists$<br>   all相当于数学意义的任意符号$\forall$<br>   那么有，not exp1 op any(exp2) 等价于 exp1 op all(exp2)<br>   exp1 op any(exp2) 等价于 not exp1 op all(exp2)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询GPA最高的学生的名字及其GOA</span></span><br><span class="line"><span class="keyword">select</span> sName, GPA <span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> GPA <span class="operator">&gt;=</span> <span class="keyword">all</span>(<span class="keyword">select</span> GPA <span class="keyword">from</span> Student) <span class="comment">--这个学生的GPA大于任意其他学生的GPA</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查询注册人数最少的学校的名字</span></span><br><span class="line"><span class="keyword">select</span> cName</span><br><span class="line"><span class="keyword">from</span> College c1</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> enrollment <span class="operator">&lt;=</span> <span class="keyword">any</span>(<span class="keyword">select</span> enrollment <span class="keyword">from</span> College c2 </span><br><span class="line">        <span class="keyword">where</span> c2.cName <span class="operator">&lt;&gt;</span> c1.cName); <span class="comment">--不存在另一个学校注册人数大于等于这个学校的注册人数</span></span><br></pre></td></tr></table></figure></p><h3 id="3-2-from中的子查询"><a href="#3-2-from中的子查询" class="headerlink" title="3.2 from中的子查询"></a>3.2 from中的子查询</h3><p>在进行以下查询时，一些复杂的项，如GPA*(sizeHS/1000.0)，需要重复书写<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询GPA和scaledGPA相差超过1.0的学生的信息</span></span><br><span class="line"><span class="keyword">select</span> sID, sName, GPA, GPA<span class="operator">*</span>(sizeHS<span class="operator">/</span><span class="number">1000.0</span>) <span class="keyword">as</span> scaledGPA</span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> GPA<span class="operator">*</span>(sizeHs<span class="operator">/</span><span class="number">1000.0</span>) <span class="operator">-</span> GPA <span class="operator">&gt;</span> <span class="number">1.0</span> <span class="keyword">or</span> GPA<span class="operator">-</span>GPA<span class="operator">*</span>(sizeHS<span class="operator">/</span><span class="number">1000.0</span>) <span class="operator">&gt;</span> <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure></p><p>由于查询的结果也是一张表，我们可以将其命名，并嵌套用于新一轮的查询，改进如下<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询GPA和scaledGPA相差超过1.0的学生的信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> sID, sName, GPA, GPA<span class="operator">*</span>(sizeHS<span class="operator">/</span><span class="number">1000.0</span>) <span class="keyword">as</span> scaledGPA</span><br><span class="line"><span class="keyword">from</span> student) G</span><br><span class="line"><span class="keyword">where</span> <span class="built_in">abs</span>(G.GPA <span class="operator">-</span> G.scaledGPA) <span class="operator">&gt;</span> <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-select中的子查询"><a href="#3-3-select中的子查询" class="headerlink" title="3.3 select中的子查询"></a>3.3 select中的子查询</h3><p>当一个表达式恰好能返回一个结果时，可以将表达式置于select中，如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询每个学校申请的人当中的最高GPA</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> college.cName, state, GPA</span><br><span class="line"><span class="keyword">from</span> College, Apply, Student</span><br><span class="line"><span class="keyword">where</span> College.cName <span class="operator">=</span> Apply.cName <span class="keyword">and</span> Apply.sID <span class="operator">=</span> Student.sID</span><br><span class="line">    <span class="keyword">and</span> GPA <span class="operator">&gt;=</span> <span class="keyword">all</span>(<span class="keyword">select</span> GPA <span class="keyword">from</span> Student, Apply </span><br><span class="line">                    <span class="keyword">where</span> Student.sID <span class="operator">=</span> Apply.sID </span><br><span class="line">                        <span class="keyword">and</span> Apply.cName <span class="operator">=</span> College.cName);</span><br></pre></td></tr></table></figure><br>等价于<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询每个学校申请的人当中的最高GPA</span></span><br><span class="line"><span class="keyword">select</span> cName, state,</span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> GPA</span><br><span class="line"><span class="keyword">from</span> Apply, Student</span><br><span class="line"><span class="keyword">where</span> College.cName <span class="operator">=</span> Apply.cName <span class="keyword">and</span> Apply.sID <span class="operator">=</span> Student.sID</span><br><span class="line">    <span class="keyword">and</span> GPA <span class="operator">&gt;=</span> <span class="keyword">all</span>(<span class="keyword">select</span> GPA <span class="keyword">from</span> Student, Apply </span><br><span class="line">                    <span class="keyword">where</span> Student.sID <span class="operator">=</span> Apply.sID </span><br><span class="line">                        <span class="keyword">and</span> Apply.cName <span class="operator">=</span> College.cName)) <span class="keyword">as</span> GPA</span><br><span class="line"><span class="keyword">from</span> College;</span><br></pre></td></tr></table></figure></p><h2 id="4-连接运算符-Join-Operators"><a href="#4-连接运算符-Join-Operators" class="headerlink" title="4. 连接运算符(Join Operators)"></a>4. 连接运算符(Join Operators)</h2><p>JOIN需要接 ON E 或者 USING($A_1$, $A_2$, …, $A_n$ )，E为表达式，$A_1$, $A_2$, …, $A_n$为列名。通常ON和USING不能同时出现。</p><p>注意：所有的JOIN运算都不符合结合律</p><p><strong>INNER JOIN</strong></p><p>INNER可以省略</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> E_1 <span class="keyword">JOIN</span>  E_2   </span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><p>相当于$\theta$连接，即$ \Pi_{Shema_1 \cup Shema_2}(\sigma_{condition}(E_1 \times E_2) ) $</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> E_1 <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span>  E_2   </span><br></pre></td></tr></table></figure><p>相当于自然连接，即$\Pi_{Shema_1 \cup Shema_2} (\sigma_{E_1.A_1 = E_2.A_1, E_1.A_2 = E_2.A_2,…, E_1.A_n = E_2.A_n} ( E_1 \times E_2))$，会隐式合并相同列（不建议），于是可以用USING人为指定：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> E_1 <span class="keyword">JOIN</span>  E_2  <span class="keyword">USING</span>(A_1, A_2)</span><br></pre></td></tr></table></figure><p><strong>LEFT/RIGHT/FULL OUTER JOIN</strong></p><p>OUTER 可以省略<br>LEFT JOIN 保留左边，即使右边没有相匹配<br>RIGHT JOIN 保留右边。即使左边没有相匹配<br>FULL JOIN 左右都保留</p><h2 id="5-聚合查询-Aggregation"><a href="#5-聚合查询-Aggregation" class="headerlink" title="5. 聚合查询(Aggregation)"></a>5. 聚合查询(Aggregation)</h2><h3 id="5-1-聚合函数"><a href="#5-1-聚合函数" class="headerlink" title="5.1 聚合函数"></a>5.1 聚合函数</h3><ol><li>max：求最大值</li><li>min：求最小值</li><li>avg：求平均值</li><li>sum：求和</li><li>count：求计数</li></ol><h3 id="5-2-分组查询"><a href="#5-2-分组查询" class="headerlink" title="5.2 分组查询"></a>5.2 分组查询</h3><p>GROUP BY 将FROM得到的关系做分组，通常，使用了GROUP BY后，SELECT中只能出现<strong>聚合函数</strong>以及<strong>分组所用的属性</strong></p><p>HAVING 后接表达式对分组后的新关系再做限制，通常HAVING后的表达式是对聚合函数值得限制</p><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询每个学校申请每个专业的人的最低GPA和最高GPA</span></span><br><span class="line"><span class="keyword">select</span> cName, major, <span class="built_in">min</span>(GPA), <span class="built_in">max</span>(GPA)</span><br><span class="line"><span class="keyword">from</span> Student, Apply</span><br><span class="line"><span class="keyword">where</span> Student.sID <span class="operator">=</span> Apply.sID</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cName, major;</span><br></pre></td></tr></table></figure><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查询每个学生申请的学校的数量</span></span><br><span class="line"><span class="keyword">select</span> Student.sID, <span class="built_in">count</span>(<span class="keyword">distinct</span> cName) <span class="comment">--count distinct的组合很好用</span></span><br><span class="line"><span class="keyword">from</span> Student, Apply</span><br><span class="line"><span class="keyword">where</span> Student.sID <span class="operator">=</span> Apply.sID</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> student.sID;</span><br></pre></td></tr></table></figure></p><h2 id="6-NULL值"><a href="#6-NULL值" class="headerlink" title="6. NULL值"></a>6. NULL值</h2><p>在查询中要特别注意NULL值：当一个属性为NULL值时，不会被WHERE中的数学表达式所限定，故有is null 专门判断NULL值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sID, sName ,GPA</span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> GPA <span class="operator">&gt;</span> <span class="number">3.5</span> <span class="keyword">or</span> GPA <span class="operator">&lt;=</span> <span class="number">3.5</span> <span class="keyword">or</span> GPA <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>SELCET中能够查询到值为空的属性：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> GPA</span><br><span class="line"><span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+---+-------+</span><br><span class="line">|   |  GPA  |</span><br><span class="line">+---+-------+</span><br><span class="line">| 1 | NULL  |</span><br><span class="line">| 2 | 2.9   |</span><br><span class="line">| 3 | 3.5   |</span><br><span class="line">| 4 | 3.4   |</span><br><span class="line">| 5 | 3.1   |</span><br><span class="line">| 6 | 3.2   |     </span><br><span class="line">+---+-------+</span><br></pre></td></tr></table></figure></p><h2 id="7-Modification-Statements"><a href="#7-Modification-Statements" class="headerlink" title="7. Modification Statements"></a>7. Modification Statements</h2><p>对表作修改的语句有：</p><h3 id="7-1-插入操作"><a href="#7-1-插入操作" class="headerlink" title="7.1 插入操作"></a>7.1 插入操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tableName </span><br><span class="line"><span class="keyword">VALUE</span> (A_1, A_2, A_3, ...)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tableName () </span><br><span class="line"><span class="keyword">select</span><span class="operator">-</span>statement  <span class="comment">--将查询的结果插入到表中</span></span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将没有申请学校的学生设置为申请了Carnegie Mellon的CS</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Apply </span><br><span class="line"><span class="keyword">select</span> sID, <span class="string">&#x27;Carnegie Mellon&#x27;</span>, <span class="string">&#x27;CS&#x27;</span>, <span class="keyword">null</span> </span><br><span class="line"><span class="keyword">from</span> Student</span><br><span class="line"><span class="keyword">where</span> sID <span class="keyword">not</span> <span class="keyword">in</span>(<span class="keyword">select</span> sID <span class="keyword">from</span> Apply);</span><br></pre></td></tr></table></figure></p><h3 id="7-2-删除操作"><a href="#7-2-删除操作" class="headerlink" title="7.2 删除操作"></a>7.2 删除操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> tableName () </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>  <span class="comment">--删除满足条件的行</span></span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--删除申请表中申请专业超过两个的人</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">where</span> sID <span class="keyword">in</span> </span><br><span class="line">(<span class="keyword">select</span> sID</span><br><span class="line"><span class="keyword">from</span> Apply</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> sID</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> major) <span class="operator">&gt;</span> <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><h3 id="7-3-更新操作"><a href="#7-3-更新操作" class="headerlink" title="7.3 更新操作"></a>7.3 更新操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tableName</span><br><span class="line"><span class="keyword">SET</span> A_1 <span class="operator">=</span> E_1, A_2 <span class="operator">=</span> E_2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span> </span><br><span class="line"><span class="comment">--将满足条件的行中的属性修改为指定值，这个指定值也可以是只返回一个值的查询语句</span></span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--将所有申请Carnegie Mellon并且GPA小于3.6的申请修改为经济学economics</span></span><br><span class="line"><span class="keyword">update</span> Apply</span><br><span class="line"><span class="keyword">set</span> major <span class="operator">=</span><span class="string">&#x27;economics&#x27;</span></span><br><span class="line"><span class="keyword">where</span> cName <span class="operator">=</span><span class="string">&#x27;Carnegie Mellon&#x27;</span><span class="keyword">and</span> sID <span class="keyword">in</span> (<span class="keyword">select</span> sID <span class="keyword">from</span> student <span class="keyword">where</span> GPA <span class="operator">&lt;</span> <span class="number">3.6</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> SQL </tag>
            
            <tag> 关系代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS145 Intro to databases 学习笔记1——Relational Model、XML、JSON</title>
      <link href="/2024/01/25/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94Relational%20Model%E3%80%81XML%E3%80%81JSON/"/>
      <url>/2024/01/25/CS145%20Intro%20to%20databases%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%E2%80%94%E2%80%94Relational%20Model%E3%80%81XML%E3%80%81JSON/</url>
      
        <content type="html"><![CDATA[<h1 id="零、前言"><a href="#零、前言" class="headerlink" title="零、前言"></a>零、前言</h1><h2 id="1-碎碎念"><a href="#1-碎碎念" class="headerlink" title="1. 碎碎念"></a>1. 碎碎念</h2><p>前几天真是煎熬啊，也可能是没写博客输出内容，学的有些不安QwQ。。学计算机网络在哈工大和湖科大两个视频之间左右横跳，概念的东西有些太多了看的很不爽，耐心濒临崩溃。。又去做一下GAN的实战案例，自己是写不出来的，跑别人的代码也死慢死慢的。最后决定先放一放，来看数据库系统好了</p><h2 id="2-本文概述"><a href="#2-本文概述" class="headerlink" title="2. 本文概述"></a>2. 本文概述</h2><p>本文是学习<strong>standford CS145 Introduction to Databases</strong>系列视频的第一篇笔记，内容主要包括第二章第四章的三种数据模型：</p><ol><li>Relational Model</li><li>XML</li><li>JSON</li></ol><p>视频链接：<a href="https://www.youtube.com/playlist?list=PLroEs25KGvwzmvIxYHRhoGTz9w8LeXek0">Introduction to Databases - Jennifer Widom - Stanford</a></p><h1 id="一、Relational-Model"><a href="#一、Relational-Model" class="headerlink" title="一、Relational Model"></a>一、Relational Model</h1><h2 id="1-Relational-Model的介绍"><a href="#1-Relational-Model的介绍" class="headerlink" title="1. Relational Model的介绍"></a>1. Relational Model的介绍</h2><h3 id="1-1-Relational-Model的定义"><a href="#1-1-Relational-Model的定义" class="headerlink" title="1.1 Relational Model的定义"></a>1.1 Relational Model的定义</h3><p><strong>Schema</strong>是指对数据库结构的描述<br><strong>Instance</strong>是指在数据库运作时出现的真实数据</p><blockquote><p><strong>Schema</strong>——structural description of relations in database<br><strong>Instance</strong>——actual contents at given point in time</p></blockquote><p>在Relational Model中</p><ol><li>数据库是一些已命名的<strong>关系</strong>（或称为<strong>表</strong>）的集合。如，学生表，学校表</li><li>每个表包含已命名的<strong>属性</strong>（或称为<strong>列</strong>）。如学号，姓名</li><li>每个<strong>元组</strong>（或称为<strong>行</strong>）有对应属性的值。</li><li>每个属性应指定<strong>类型</strong> (或称为 <strong>范围</strong>)</li></ol><blockquote><ol><li>Database = set of named <strong>relations</strong> (or <strong>tables</strong></li><li>Each relation has a set of named <strong>attributes</strong> (or <strong>columns</strong></li><li>Each <strong>tuple</strong> (or <strong>row</strong>) has a value for each attribute</li><li>Each attribute has a <strong>type</strong> (or <strong>domain</strong>)</li></ol></blockquote><p>示例：</p><p>Student Table</p><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">name</th><th style="text-align:center">gender</th><th style="text-align:center">GPA</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Andrew</td><td style="text-align:center">male</td><td style="text-align:center">3.2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Shiroko</td><td style="text-align:center">female</td><td style="text-align:center">4.5</td></tr></tbody></table></div><h3 id="1-2-Relational-Model的应用"><a href="#1-2-Relational-Model的应用" class="headerlink" title="1.2 Relational Model的应用"></a>1.2 Relational Model的应用</h3><p><strong>字段的值允许不存在，即字段的值为NULL</strong></p><p><strong>NULL</strong>——special value for “unknown” or “undefined’</p><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">name</th><th style="text-align:center">gender</th><th style="text-align:center">GPA</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Andrew</td><td style="text-align:center">male</td><td style="text-align:center"><strong>NULL</strong></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Shiroko</td><td style="text-align:center"><strong>NULL</strong></td><td style="text-align:center">4.5</td></tr></tbody></table></div><p><strong>每一行需要有唯一标识</strong></p><p>唯一标识Key可以是一个unique的值，也可以是多个字段的组合是unique的值的组合</p><blockquote><p><strong>Key</strong>——attribute whose <strong>value is unique</strong> in each tuple Or <strong>set of attributes whose combined values are unique</strong></p></blockquote><p><strong>在SQL语句中创建表</strong></p><p>Create Table <strong>Student</strong>(<strong>ID</strong>, <strong>name</strong>, <strong>GPA</strong>, <strong>photo</strong>)</p><p>Create Table <strong>College</strong>(<strong>name string</strong>, <strong>state char(2)</strong>, <strong>enrollment integer</strong>)</p><h2 id="2-在Relational-Model中查询"><a href="#2-在Relational-Model中查询" class="headerlink" title="2. 在Relational Model中查询"></a>2. 在Relational Model中查询</h2><p>具体查询语言在后续学习，现展示两种语言的形式：</p><p>查找申请了斯坦福且GPA大于3.7的学生的ID：</p><p>1.关系代数(Relational Algebra)</p><script type="math/tex; mode=display">\Pi_{ID} \sigma_{GPA > 3.7 \wedge CNAME = 'Standford'} (Student \times Apply)</script><p>2.SQL</p><p>Select student.ID<br>From student, Apply<br>Where student.ID = Apply.ID<br>And GPA&gt;3.7 and college=’Stanford’</p><h1 id="二、XML-Extensible-Markup-Language"><a href="#二、XML-Extensible-Markup-Language" class="headerlink" title="二、XML(Extensible Markup Language)"></a>二、XML(Extensible Markup Language)</h1><h2 id="1-XML的介绍"><a href="#1-XML的介绍" class="headerlink" title="1. XML的介绍"></a>1. XML的介绍</h2><h3 id="1-1-XML的基本组成部分"><a href="#1-1-XML的基本组成部分" class="headerlink" title="1.1 XML的基本组成部分"></a>1.1 XML的基本组成部分</h3><ol><li>嵌套的标签元素</li><li>标签的属性</li><li>文本</li></ol><blockquote><p>Basic constructs</p><ol><li>Tagged elements(nested)</li><li>Attributes</li><li>Text</li></ol></blockquote><h3 id="1-2-well-formed-XML"><a href="#1-2-well-formed-XML" class="headerlink" title="1.2 well-formed XML"></a>1.2 well-formed XML</h3><p>well-formed XML满足的条件：</p><ul><li>根元素是唯一的</li><li>相互正确嵌套的标签（包括开始标志、结束标志）</li><li>元素内的参数是唯一的</li></ul><blockquote><p><strong>Adheres to basic structural requirements</strong></p><ul><li>Single root element</li><li>Matched tags, proper nesting</li><li>Unique attributes within elements</li></ul></blockquote><h3 id="1-3-“Valid”-XML"><a href="#1-3-“Valid”-XML" class="headerlink" title="1.3 “Valid” XML"></a>1.3 “Valid” XML</h3><p>“Valid” XML代表XML文件不仅满足well-formed XML的条件，同时也满足其他对内容的限制条件，这些条件主要有以下两种描述方式：</p><ol><li>Document Type Descriptor(DTD)</li><li>XML Schema (XSD)</li></ol><blockquote><p>Adheres to basic structural requirements<br>Also adheres to content-specific specification</p><ol><li>Document Type Descriptor(DTD)</li><li>XML Schema (XSD)</li></ol></blockquote><h2 id="2-DTD"><a href="#2-DTD" class="headerlink" title="2. DTD"></a>2. DTD</h2><p>根据视频中的DTD文件总结：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE rootName&gt;：定义根元素  </span><br><span class="line">&lt;!ELEMENT eleName&gt;：定义元素  </span><br><span class="line">&lt;!ATTLIST eleName attName1 attType1 #REQUIRED</span><br><span class="line">                  attName1 attType1 #IMPLIED&gt;</span><br><span class="line">定义元素下的属性，包括属性名，属性类型，#REQUIRED表示必要，#IMPLIED表示不必要</span><br><span class="line"></span><br><span class="line">通常用正则表达式中 | . * ? 等符号表示需要元素及其数量</span><br><span class="line"></span><br><span class="line">#PCDATA 表示需要被解析的数据</span><br><span class="line">CDATA 表示不需要被解析的数据</span><br><span class="line">IDREFS 元素的ID组成的列表</span><br><span class="line">ID 元素的ID</span><br></pre></td></tr></table></figure><br>更多关于DTD：<a href="https://www.runoob.com/dtd/dtd-tutorial.html">DTD 教程 | 菜鸟教程 (runoob.com)</a></p><p>示例（注释是自己写的QwQ）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">Bookstore</span> [</span></span><br><span class="line"><span class="meta">    &lt;!-- 可包含多个Book和多个Magazine的Bookstore--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Bookstore</span> (<span class="keyword">Book</span>*, <span class="keyword">Magazine</span>*)&gt;</span></span></span><br><span class="line"><span class="meta">    </span></span><br><span class="line"><span class="meta">    &lt;!-- 包含一个Title和零/一个Remark的Book--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Book</span> (<span class="keyword">Title</span>, <span class="keyword">Remark</span>?)&gt;</span></span></span><br><span class="line"><span class="meta">    &lt;!-- Book的属性必须两个字符类型数据，以及作者的ID列表--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ATTLIST <span class="keyword">Book</span> <span class="keyword">ISBN</span> <span class="keyword">CDATA</span> <span class="keyword">#REQUIRED</span></span></span></span><br><span class="line"><span class="meta"><span class="meta">                  <span class="keyword">Price</span> <span class="keyword">CDATA</span> <span class="keyword">#REQUIRED</span></span></span></span><br><span class="line"><span class="meta"><span class="meta">                  <span class="keyword">Authors</span> <span class="keyword">IDREFS</span> <span class="keyword">#IMPLIED</span>&gt;</span></span></span><br><span class="line"><span class="meta">                  </span></span><br><span class="line"><span class="meta">    &lt;!-- 包含一个Title的Magazine--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Magazine</span> (<span class="keyword">Title</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ATTLIST <span class="keyword">Magazine</span> <span class="keyword">Month</span> <span class="keyword">CDATA</span> <span class="keyword">#REQUIRED</span></span></span></span><br><span class="line"><span class="meta"><span class="meta">                       <span class="keyword">Year</span> <span class="keyword">CDATA</span> <span class="keyword">#REQUIRED</span>&gt;</span></span></span><br><span class="line"><span class="meta">                       </span></span><br><span class="line"><span class="meta">    &lt;!-- Title包含PCDATA Remark包含多个PCDATA或书的ID--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Title</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Remark</span> (<span class="keyword">#PCDATA</span> | <span class="keyword">BookRef</span>)*&gt;</span></span></span><br><span class="line"><span class="meta">    </span></span><br><span class="line"><span class="meta">    &lt;!-- 只包含属性的空元素--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">BookRef</span> <span class="keyword">EMPTY</span>&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ATTLIST <span class="keyword">BoookRef</span> <span class="keyword">book</span> <span class="keyword">IDREF</span> <span class="keyword">#REQUIRED</span>&gt;</span></span></span><br><span class="line"><span class="meta">    </span></span><br><span class="line"><span class="meta">    &lt;!-- Author由 First_Name 和 LastName组成，同时必须一个属性作为ID--&gt;</span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Author</span> (<span class="keyword">First_Name</span>, <span class="keyword">Last_Name</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ATTLIST <span class="keyword">Author</span> <span class="keyword">Ident</span> <span class="keyword">ID</span> <span class="keyword">#REQUIRED</span>&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">First_Name</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">    <span class="meta">&lt;!ELEMENT <span class="keyword">Last_Name</span> (<span class="keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="3-XSD"><a href="#3-XSD" class="headerlink" title="3. XSD"></a>3. XSD</h2><p>参考：<a href="https://www.w3school.com.cn/schema/schema_example.asp">一个 XSD 实例 (w3school.com.cn)</a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件头定义标准的xml声明，使其符合基本的xml结构--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- -复杂类型的元素定义 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;eleName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;complexTypeName&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:complexType</span> <span class="attr">name</span>=<span class="string">&quot;complexTypeName&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">xs:attribute</span> <span class="attr">name</span>=<span class="string">&quot;attName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 简单类型的元素定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&quot;eleName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xs:string&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">minOccurs</span>=<span class="string">&quot;0&quot;</span> <span class="attr">maxOccurs</span>=<span class="string">&quot;unbounded&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 元素的主键 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:key</span> <span class="attr">name</span>=<span class="string">&quot;eleNameKey&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:selector</span> <span class="attr">xpath</span>=<span class="string">&quot;eleName&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:field</span> <span class="attr">xpath</span>&quot;@<span class="attr">attName</span>&quot; /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:key</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 其他元素主键的引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:key</span> <span class="attr">name</span>=<span class="string">&quot;eleName3KeyRef&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;eleName3Key&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:selector</span> <span class="attr">xpath</span>=<span class="string">&quot;eleName1/eleName2/eleName3&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:field</span> <span class="attr">xpath</span>&quot;@<span class="attr">attName</span>&quot; /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:key</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="三、JSON-JavaScript-Object-Notation"><a href="#三、JSON-JavaScript-Object-Notation" class="headerlink" title="三、JSON(JavaScript Object Notation)"></a>三、JSON(JavaScript Object Notation)</h1><h2 id="1-JSON的介绍"><a href="#1-JSON的介绍" class="headerlink" title="1. JSON的介绍"></a>1. JSON的介绍</h2><h3 id="1-1-JSON的特点"><a href="#1-1-JSON的特点" class="headerlink" title="1.1 JSON的特点"></a>1.1 JSON的特点</h3><ol><li>是用于序列化数据对象的标准</li><li>可读性强，便于交流数据</li><li>能很好地表达和存储结构不那么严格的数据</li><li>不再于JavaScript绑定，并且能在许多编程语言中转换</li></ol><blockquote><ol><li>Standard for “serializing” data objects, usually in files</li><li>Human-readable, useful for data interchange</li><li>Also useful for representing &amp; storing semistructured data</li><li>No longer tied to JavaScript</li><li>Parsers for many languages</li></ol></blockquote><h3 id="1-2-JSON的基本组成部分"><a href="#1-2-JSON的基本组成部分" class="headerlink" title="1.2 JSON的基本组成部分"></a>1.2 JSON的基本组成部分</h3><p>JSON由以下成分递归定义</p><ol><li>基本类型<br>number, string, boolean, ..</li><li>对象 {}<br>对象包含键值对的集合，值可以是基本类型，也可以是数组和对象。</li><li>数组 []<br>数组包括一列表的值，可以是基本类型，也可以是数组和对象。</li></ol><blockquote><p>Basic constructs(recursive)</p><ol><li>Base values<br>number, string, boolean, ..</li><li>Objects {}<br>sets of label-value pairs</li><li>Arrays []<br>lists of values</li></ol></blockquote><h2 id="2-JSON-Schema"><a href="#2-JSON-Schema" class="headerlink" title="2. JSON Schema"></a>2. JSON Schema</h2><p>从示例看如何使用JSON Schema规范JSON的内容：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;object&quot;</span><span class="punctuation">,</span> <span class="comment">//&quot;type&quot;: &quot;属性类型&quot;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span>  <span class="comment">//object接properties</span></span><br><span class="line">      <span class="attr">&quot;Books&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;array&quot;</span><span class="punctuation">,</span> <span class="comment">// array接items</span></span><br><span class="line">          <span class="attr">&quot;items&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;object&quot;</span><span class="punctuation">,</span> </span><br><span class="line">              <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">                  <span class="attr">&quot;ISBN&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">                      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">                      <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISBN*&quot;</span> <span class="comment">//正则表达式匹配</span></span><br><span class="line">                  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;Price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">                      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                      <span class="attr">&quot;minimum&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span>  <span class="comment">//最小数量</span></span><br><span class="line">                      <span class="attr">&quot;maximum&quot;</span><span class="punctuation">:</span> <span class="number">200</span> <span class="comment">//最大数量</span></span><br><span class="line">                  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                  <span class="attr">&quot;Edition&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span> </span><br><span class="line">                      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;integer&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                      <span class="attr">&quot;optional&quot;</span><span class="punctuation">:</span><span class="literal"><span class="keyword">true</span></span> <span class="comment">//表示属性可选</span></span><br><span class="line">                  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="comment">// 省略</span></span><br></pre></td></tr></table></figure></p><h1 id="四、三种数据模型之间的比较"><a href="#四、三种数据模型之间的比较" class="headerlink" title="四、三种数据模型之间的比较"></a>四、三种数据模型之间的比较</h1><h2 id="1-Relational-Model、XML和JSON"><a href="#1-Relational-Model、XML和JSON" class="headerlink" title="1. Relational Model、XML和JSON"></a>1. Relational Model、XML和JSON</h2><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Relational</th><th style="text-align:center">XML</th><th style="text-align:center">JSON</th></tr></thead><tbody><tr><td style="text-align:center">Structure</td><td style="text-align:center">Tables <br/> 表</td><td style="text-align:center">hierarchical tree, or graph <br/> 多层次的树或图</td><td style="text-align:center">Nested Sets of Objects and Arrays <br/> 嵌套的对象和数组</td></tr><tr><td style="text-align:center">Schema</td><td style="text-align:center">Fixed in advance <br/> 固定</td><td style="text-align:center">“self-describing” Flexible <br/> 灵活</td><td style="text-align:center">“self-describing” Flexible <br/> 灵活</td></tr><tr><td style="text-align:center">Queries</td><td style="text-align:center">Some simple expressive languages <br/> 有容易表述的查询语言</td><td style="text-align:center">Less so <br/> 比关系模型要少</td><td style="text-align:center">None widely used till 2012-2 <br/> 到2012-2仍未有盛行的JSON查询语言</td></tr><tr><td style="text-align:center">Ordering</td><td style="text-align:center">None</td><td style="text-align:center">Implied</td><td style="text-align:center">Arrays</td></tr><tr><td style="text-align:center">Implementation</td><td style="text-align:center">Native systems <br/> 有原生实现关系模型的系统</td><td style="text-align:center">Add-on <br/> 作为关系型数据库的上一层的附加组件</td><td style="text-align:center">Coupled with programming language,<br/> used in NOSQL systems <br/> 常在编程语言中出现，或用于NOSQL系统</td></tr></tbody></table></div><h2 id="2-XML和JSON"><a href="#2-XML和JSON" class="headerlink" title="2. XML和JSON"></a>2. XML和JSON</h2><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">XML</th><th style="text-align:center">JSON</th></tr></thead><tbody><tr><td style="text-align:center">Verbosity <br/> 冗长程度</td><td style="text-align:center">More <br/> 带结束标签</td><td style="text-align:center">Less</td></tr><tr><td style="text-align:center">Complexity <br/> 复杂性</td><td style="text-align:center">More <br/> 属性、子元素和文本</td><td style="text-align:center">Less</td></tr><tr><td style="text-align:center">Validity <br/> 校验器</td><td style="text-align:center">DTDs XSDs 常用</td><td style="text-align:center">JSON Schema 不常用</td></tr><tr><td style="text-align:center">Prog. Interface <br/> 编程语言接口</td><td style="text-align:center">Clunky “Impedence mismatch” <br/> 与编程语言中的数据结构不直接匹配</td><td style="text-align:center">More direct</td></tr><tr><td style="text-align:center">Querying <br/> 查询</td><td style="text-align:center">XPath XQuery XSLT</td><td style="text-align:center">不常用的各种提案</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 关系型数据库 </tag>
            
            <tag> XML </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>挑战杯网申培训讲座</title>
      <link href="/2024/01/23/%E6%8C%91%E6%88%98%E6%9D%AF%E7%BD%91%E7%94%B3%E5%9F%B9%E8%AE%AD%E8%AE%B2%E5%BA%A7/"/>
      <url>/2024/01/23/%E6%8C%91%E6%88%98%E6%9D%AF%E7%BD%91%E7%94%B3%E5%9F%B9%E8%AE%AD%E8%AE%B2%E5%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>听了个学校双创训练营的挑战杯网申培训讲座，把截下来的ppt整理一下水一篇博客咦嘻嘻嘻</p><p>侵删</p><h1 id="一、赛道盘点"><a href="#一、赛道盘点" class="headerlink" title="一、赛道盘点"></a>一、赛道盘点</h1><h2 id="1-往届“挑战杯”获奖盘点"><a href="#1-往届“挑战杯”获奖盘点" class="headerlink" title="1. 往届“挑战杯”获奖盘点:"></a>1. 往届“挑战杯”获奖盘点:</h2><ol><li><p>共有来自3011所高校的142.4万名学生参赛，<br>累计提交33万余个创新创业项目，其中金奖项目154个，银奖项目309个，铜奖项目1079个  </p></li><li><p>各赛道获奖情况：<br>1、科技创新和未来产业: 42项金奖 (职业院校8项);<br>2、乡村振兴和农业农村现代化:31项(院校6项)<br>3、社会治理和公共服务: 36项 (职业院校6项);<br>无人机检测防控2、桥梁/山区弯道/基建3、医疗项目5(胃肠道检测/病理诊断/用药/癌症预防等)、乡村健康/女性健康3、留守儿童/孤独症2、防火减灾2、海洋河流检测2数据隐私1、中小学科普1、非遗1<br>4、生态环保和可持续发展: 25项 (院校4项)<br>双碳4、防生阻燃、催化剂4、结构纤维、水下机器人、喷雾、新能源、固废、降解及再生循环<br>5、文化创意和区城合作:20项 (业院校4项)</p></li><li><p>高校获奖情况<br>共有113所高校荣获金奖，北京理工大学以7金1银，金奖总数第一、总分第一的优异成绩捧得“挑战杯”，问鼎中国大学生创新创业竞赛最高集体荣誉5、华中科技大学、浙江大学、南京航空航天大学和天津大学各获得4项金奖，并列金奖数第二;浙江工业大学、西安交大3;北航/东北大学/广工/四川大学2</p></li></ol><h2 id="2-挑战杯参赛组别"><a href="#2-挑战杯参赛组别" class="headerlink" title="2. 挑战杯参赛组别"></a>2. 挑战杯参赛组别</h2><p><strong>科技创新和未来产业</strong>:突出科技创新，在人工智能、网络信息、生命科学、新材料新能源等领域;乡村振兴和农业农村现代化: 围绕实施乡村振兴战略，在农林牧渔、旅游休闲、电子商务、城乡融合等领域;</p><p><strong>城市治理和社会服务</strong>:围绕国家治理体系和治理能力现代化建设，政务服务、消费生活、公共卫生与医疗服务、金融与法律服务、教育培训、交通物流、金融服务等;</p><p><strong>生态环保和可持续发展</strong>:围绕可持续发展战略，在环境治理、可持续资源开发、生态环保、清洁能源应用等领域;</p><p><strong>文化创意和区域合作</strong>:突出共融、共享，围绕“一带一路”和京津冀、长三角、成渝经济圈及粤港澳大湾区等经济合作带建设，在工艺与设计、动漫广告、体育竞技和国际文化传播、对外交流培训、对外经贸等领域。</p><p>科创未来产业：看重专利、软著、产品的测试<br>乡村振兴和农业现代化：看重社会实践和案例<br>城市治理和社会服务：关注社会热点和共性问题，效果前vs效果后<br>生态环保可持续发展：展现应用场景应用效果<br>文创和区域合作：难衡量，突出合同订单营收  </p><h1 id="二、网申材料"><a href="#二、网申材料" class="headerlink" title="二、网申材料"></a>二、网申材料</h1><h2 id="1-网评提交材料"><a href="#1-网评提交材料" class="headerlink" title="1. 网评提交材料"></a>1. 网评提交材料</h2><p>1、申报书:社会价值、实践过程、创新意义、发展前景等</p><p>2、商业计划书: 市场背景、痛点、解决方案等(图表结合) <strong>省赛基本五十页+，大部分90-120</strong></p><p>3、附加材料(可不加，有更好<br>项目PPT、专利软著、合同订单、财务流水、到账证明等</p><p>4、图片视频(可不加，有更好</p><p>tip: 技术类要侧重于自己的专利和软著，老师的跟自己的悬殊不能太大</p><h2 id="2-评审要点"><a href="#2-评审要点" class="headerlink" title="2. 评审要点"></a>2. 评审要点</h2><p>1、社会价值</p><p><strong>核心点</strong>:社会贡献，社会价值，社会成效和社会影响力。<br><strong>概述</strong>:在科技创新、扶贫助困、社会民生、生态环保、交流合作等方面的社会贡献度，未来在持续吸纳、带动就业等方面的能力等。</p><p>2、实践过程  </p><p><strong>核心点</strong>:对于关键的时间点、实践过程要重点描述，可以时间点+事迹;<br><strong>概述</strong>:说明项目过程中进行的各项主要实践活动，尤其是深入一线的调研过程，包括产品研发、营销策略、调研实践、技术迭代、社会服务等。</p><p>3、创新意义</p><p><strong>核心点</strong>:技术、模式、管理、内容的创新性，凸显竞争性和不可替代性。<br><strong>概述</strong>:突出核心创新点和技术支撑材料，项目在科学技术、社会服务形式、商业模式、管理运营、应用场景等方面的创新程度</p><p>4、发展前景</p><p><strong>核心点</strong>:技术或模式有优势、市场规模和容量、政策背景支持、资金和人员可持续<br><strong>概述</strong>:项目商业模式、营销策略、财务管理、发展战略等方面设计完整合理。目标定位及市场分析清晰，盈利能力推导过程合理，能够实现可持续发展。</p><p>5、团队协作 </p><p><strong>核心点</strong>:团队成员 简要介绍，学生、指导老师、外部顾问，专创融合(专业教育和创新创业教育的契合度)等。<br><strong>概述</strong>:团队成员具体分工、专业特长、相关领域有什么成绩(核心成员和指导老师取得的成绩都是要和项目研究的领域有关)</p><h1 id="三、商业计划书"><a href="#三、商业计划书" class="headerlink" title="三、商业计划书"></a>三、商业计划书</h1><h2 id="0、-商业计划书要点"><a href="#0、-商业计划书要点" class="headerlink" title="0、 商业计划书要点"></a>0、 商业计划书要点</h2><p>1、项目概述项目简介等执行概要<br>2、市场分析:市场背景、市场痛点、市场需求、客户描述<br>3、产品服务:项目源起、产品介绍等<br>4、商业模式销售模式、盈利模式、推广策略<br>5、竞争分析:对手分析、竞争优势等<br>6、团队介绍:核心团队、专家顾问<br>7、财务分析:营收来源、财务预测<br>8、风险与对策:潜在风险、解决方案<br>9、发展规划:时间/产品维度、未来三年规划<br>10、附件:营业执照、合同、证书等</p><h2 id="1、发展前景-市场分析"><a href="#1、发展前景-市场分析" class="headerlink" title="1、发展前景/市场分析"></a>1、发展前景/市场分析</h2><p>主要内容:</p><p>1、描述项目<strong>直接</strong>相关的市场背景(行业背景、市场发展趋势市场空间等)<br>2、发现一个什么样的<strong>痛点(市场需求点 机会点)</strong> <strong>用数据讲痛点</strong><br>3、解决痛点的项目<strong>目标客户</strong>精准画像，(特征、数量、分布购买动机、购买能力等)</p><p>注意:<br>1、图文并茂、言简意骇。<br>2、数据精准详实，要求最新数据。</p><p>例：</p><p>项目背景/行业分析/市场分析/市场调查等</p><p>1、找出问题 (社会痛点)<br>2、问题的市场(作证材料)<br>第二章 市场痛点与规模<br>2.1 市场痛点<br>2.2 市场现状与规模<br>2.3 竞争分析<br>2.4 SWOT 分析  </p><h2 id="2、产品-服务内容"><a href="#2、产品-服务内容" class="headerlink" title="2、产品/服务内容"></a>2、产品/服务内容</h2><p>1、产品服务及内容:产品功能、组成或结构、服务对象、服务内容;<br>2、技术原理或核心技术:生产工艺流程、核心技术、知识产权(专利软著、商标等)<br>3、产品运用/解决思路: 产品前期测试、如何解决问题、实际效果如何  </p><p>注意:<br>图文并茂。产品设计图、产品实物图、产品模型图、手稿、服务流程图、服务实景图,产业链结构图等。</p><h2 id="3、商业模式及盈利模式"><a href="#3、商业模式及盈利模式" class="headerlink" title="3、商业模式及盈利模式"></a>3、商业模式及盈利模式</h2><p>1、目标客户:客户细分、不同客户的购买特点、相应产品<br>2、盈利模式:关键业务梳理、实现盈利方式、定价策略等<br>3、营收来源:主业务是什么、辅助业务有哪些<br>4、营销与推广模式:营销策略是什么，推广方式与渠道有哪些?比如是线上还是线下?To B还是ToC?要说清楚采用的模式的内在商业逻辑。<br>关键词:<strong>销售来源、盈利模式、目标客户、定价、销售推广渠道</strong>等。  </p><p>例：</p><p>盈利模式(能给我带来什么)</p><p>1、有哪些收入来源渠道<br>第四章商业模式与营销<br>4.1 商业模式<br>4.2 产品策略<br>4.3 价格策略<br>4.4 目标市场设定<br>4.5 销售策略与渠道建设<br>4.6 售后服务  </p><p>商业维度：</p><p>简单版: 代加工+研发渠道+产品服务+目标客户<br>进阶版:代加工+研发渠道+产品服务+目标客户+盈利模式+营销模式</p><h2 id="4、核心竞争力"><a href="#4、核心竞争力" class="headerlink" title="4、核心竞争力"></a>4、核心竞争力</h2><p>主要内容:<br><strong>商业项目</strong>:技术壁垒(专利、技术秘密、AMSL)、非遗、文化(同仁堂、周村烧饼)、服务(海底涝)、模式(华为全面持股) 、价格(小米)、市场空档(滴滴)、客户规模 (滴滴)、人力成本等。<br>关键词:<strong>竞争对手、核心竞争力、竞争壁垒、渠道优势、差异化</strong></p><p><strong>竞争分析/竞争优势等</strong></p><p>1、你能做别人不能做的<br>2、你能做的比别人做的更好的</p><h2 id="5、团队介绍"><a href="#5、团队介绍" class="headerlink" title="5、团队介绍"></a>5、团队介绍</h2><p>1、讲清楚创始团队<strong>背景</strong>及擅长的<strong>专业方向</strong><br>2、岗位职责匹配明确:人员背景、知识结构、个人能力等要<br><strong>符合</strong>岗位要求<br>3、组织<strong>架构</strong>严谨，各部门分工明确，配合有序<br>4、外部<strong>背书</strong>:有专业经验的导师、专家、高管背书</p><h2 id="6、财务分析"><a href="#6、财务分析" class="headerlink" title="6、财务分析"></a>6、财务分析</h2><p>主要内容:</p><p><strong>财务预算和计划投入、财务预测及报表、财务指标与盈利能力分析</strong></p><p>报表:资产负债表、损益表、现金流量表等。财务指标:偿债能力(资产负债率、流动比率等)、运营能力(应收账款周转率存货周转率)、盈利能力(资本金利润率、成本费用利润率)等。</p><p>注意:<br>1、和计划书其他内容保持一致，年份一致，预测基础一致。<br>2、数据来源真实，假设合理(预估的增长率要合理)、计算准备。  </p><p><strong>对于创意组—-重在预算和支撑材料<br>对于创业组: 重在已知推未知</strong></p><p>例：</p><p>财务分与融资计划/投资计划</p><p>1、对于创意组—-重在预算和支撑材料<br>2、已经创业有收入的重在已知推未知<br>第七章 财务分析与融资计划<br>7.1 预测销售与实际销售<br>7.2 利润总结<br>7.3 会计报表<br>7.4 盈利能力<br>7.5 财务明细及用途<br>7.6 融资管理<br>7.7融资风险资本退出  </p><h2 id="7、风险与对策"><a href="#7、风险与对策" class="headerlink" title="7、风险与对策"></a>7、风险与对策</h2><p>主要内容:技术、管理、市场、经营、财务等  </p><p>注意:<br>1、风险分析要结合项目实际场景。<br><strong>2、讲完风险就得提出相应的对策</strong><br>3、对策能切实解决或者降低风险。</p><p>例：</p><p>风险分析与应对策略<br>1、风险分析要切合项目本身的实际场景<br>2、给出风险就得给出解决方式  </p><p>第八章风险与对策  </p><p>8.1 风险预测<br>8.2 风险防御与降低决策<br>8.3 融资风险  </p><h2 id="8、经营现状与规划"><a href="#8、经营现状与规划" class="headerlink" title="8、经营现状与规划"></a>8、经营现状与规划</h2><p>主要内容:<br>从<strong>产品销售</strong>角度看:产品模式、样品试制、已经量产、稳定运营等<br>从<strong>外界评价</strong>角度看:税收、就业、获奖、视察、报道等。<br>从<strong>社会价值贡献</strong>看:带动增收脱贫、消减污染总量，弘扬社会正气等。未来发展计划要分时间和空间两个维度。</p><p>1、时间上一般1-3年的详尽定量规划、中长期战略规划。<br>2、空间上包括产品品类的扩张，产品销售地域的扩张。</p><p>注意:<br>1、<strong>现状很重要，注重已经做出的成绩。</strong><br>2、规划更重要，没有足够市场和发展前景的项目没法吸引投资人的注意。<br>3、<strong>评审规则重点着重介绍</strong>。比如注重就业的，那就多提就业现状和未来。</p><h2 id="9、附件"><a href="#9、附件" class="headerlink" title="9、附件"></a>9、附件</h2><p>主要内容:<br>营业执照、商标等<br>专利、软著、作品版权<br>科技查新报告、质量检测报告、行业分析报告、专家教授推荐信等<br>政府、行业协会、创业大赛的奖励、证书等<br>商务合作照片、意向销售协议、到账证明等<br>领导肯定、用户认可、媒体报道等<br>融资合同、融资进账单据调研问卷、调研报告</p><p>注意:<br>1、规范、清晰、扫描不要拍照。<br>2、以前比赛获奖要结合实效性来斟酌考虑实际效果。<br>3、要在正文插入编号，以便查询。  </p><h2 id="10、格式修改"><a href="#10、格式修改" class="headerlink" title="10、格式修改"></a>10、格式修改</h2><p><img src="/img/2024/01/格式修改1.png" alt="格式修改1"></p><p><img src="/img/2024/01/格式修改2.png" alt="格式修改2"></p>]]></content>
      
      
      <categories>
          
          <category> 学园生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习笔记——卷积神经网络、自编码器</title>
      <link href="/2024/01/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E3%80%81%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/"/>
      <url>/2024/01/22/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E3%80%81%E8%87%AA%E7%BC%96%E7%A0%81%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>发现虽然玩了一次卷积神经网络，但还没有写文章分析下它在干什么。</p><p>and今天瞅了眼自编码器和深度生成模型，生成宝可梦感觉真好玩啊（x</p><p>视频链接：<a href="https://study.163.com/course/courseMain.htm?courseId=1208946807">李宏毅机器学习中文课程 - 网易云课堂 (163.com)</a></p><h1 id="一、卷积神经网络"><a href="#一、卷积神经网络" class="headerlink" title="一、卷积神经网络"></a>一、卷积神经网络</h1><h2 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h2><ol><li>在图片处理中，我们想要捕捉的特征远比整张图片的尺寸要小，无需对所有像素作线性组合</li><li>我们想要捕捉的特征可以在图片的不同位置出现，因此一些hidden layer的参数会相等导致冗余</li><li>降低图片的分辨率几乎不会影响判断结果，可以降低数据维度加快计算</li></ol><p>我们将以上三点更加抽象地描述为：</p><p><strong>1. 特定信息只存在于完整数据中的一部分</strong><br><strong>2. 特定信息在完整数据中多次出现</strong><br><strong>3. 降采样对结果不会有影响</strong></p><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><ol><li>在<strong>卷积层</strong>：<br>利用卷积核抽取我们需要的特定信息，卷积核只作用于输入数据中的一定区域（解决了<strong>问题1</strong>），并以一定步长在输入数据上移动（解决了<strong>问题2</strong>）。</li></ol><ol><li>在<strong>池化层</strong>：<br>用某个数值代表特定区域的数值，成倍地降低数据地空间大小（解决了<strong>问题3</strong>）</li></ol><h2 id="3-更多示例"><a href="#3-更多示例" class="headerlink" title="3. 更多示例"></a>3. 更多示例</h2><p>当一个问题满足上述的三个条件时，就可以利用卷积神经网络来train一个合适的模型。</p><p>实际上，卷积和池化不一定要同时出现。</p><p>比如，在下五子棋时，判断当前棋局的问题<strong>满足问题1和问题2</strong>，但是<strong>不满足问题3</strong></p><p>由2可知，卷积层解决的是问题1和问题2，池化层解决的是问题3。</p><p>因此，我们只需要使用卷积来处理五子棋的问题。</p><h1 id="二、自编码器"><a href="#二、自编码器" class="headerlink" title="二、自编码器"></a>二、自编码器</h1><h2 id="1-何为自编码器"><a href="#1-何为自编码器" class="headerlink" title="1. 何为自编码器"></a>1. 何为自编码器</h2><p>在使用PCA时，我们得到一个矩阵$M$将原始的高维数据$x$转换为低维数据$z$，同时可以利用$M^T$对低维数据$z$作逆变换得到$\widehat{x}$。但是在高维向低维投影的过程中出现了损失，所以逆变换得到的$\widehat{x}$与原来的$x$存在<strong>不小的偏差</strong></p><p>PCA原理参考：<a href="https://juejin.cn/post/7324200561917378579#heading-12">机器学习笔记——机器学习系统设计、支持向量机(SVM)、K-Means算法、主成分分析法(PCA) - 掘金 (juejin.cn)</a></p><p>在神经网络中，一个hidden layer的参数就是一个矩阵，所以我们可以将上述过程描述为:</p><script type="math/tex; mode=display">Input Layer(x) \rightarrow Hidden Layer(参数为M, 得到z) \rightarrow Output Layer(参数为 M^T 得到,  \widehat{x} )</script><p>我们将前面的过程称作编码(Encode)，后面的过程称作(解码)，中间输出的编码后的低维数据称作code</p><p>我们现在希望编码和解码的过程，能够<strong>尽可能地减小损失，最大程度地还原数据</strong></p><p>不妨分别将编码和解码过程抽象为神经网络，然后在训练的过程最小化$x$ 和 $ \widehat{x} $之间的偏差：</p><script type="math/tex; mode=display">x  \rightarrow NN\space Encoder \rightarrow code \rightarrow NN\space Decoder \rightarrow \widehat{x}</script><p>于是我们就利用了没有任何标签的数据，训练了一个能自动解码和编码的神经网络，而且解码和编码模块都能单独拎出来用，这就是自编码器</p><h2 id="2-自编码器的神奇之处"><a href="#2-自编码器的神奇之处" class="headerlink" title="2. 自编码器的神奇之处"></a>2. 自编码器的神奇之处</h2><h3 id="2-1-CNN与自编码器"><a href="#2-1-CNN与自编码器" class="headerlink" title="2.1 CNN与自编码器"></a>2.1 CNN与自编码器</h3><p>在卷积神经网络中，我们可以将卷积和池化操作也看作是编码过程，本质是提取低维的特定信息。</p><p>对应地，将解码过程称作反卷积和反池化：</p><ol><li>反卷积的操作与卷积一致</li><li>反池化将数据扩大时，多出来的空间可以置零，或取相同的值</li></ol><h3 id="2-2-预训练-Pre-training"><a href="#2-2-预训练-Pre-training" class="headerlink" title="2.2 预训练(Pre-training)"></a>2.2 预训练(Pre-training)</h3><p>在神经网络层次比较深时，需要拟合大量的参数。</p><p>我们可以将每个Hidden Layer（注意：不包括输出层）视作一个编码器，先利用<strong>大量的无标签数据</strong>依次对每个Hidden Layer的参数作初始化，这个过程叫预训练(Pre-training)。</p><p>最后在随机初始化输出层的参数，再利用<strong>少量标签数据</strong>训练模型。在这里，大部分的参数已经被预训练确定了七七八八，所以训练阶段只是在做微调(fine-tuning)</p><h3 id="2-3-生成新数据"><a href="#2-3-生成新数据" class="headerlink" title="2.3 生成新数据"></a>2.3 生成新数据</h3><p>特别有趣的是，我们可以自己设定一些code，丢进解码器中，这样就得到许多新数据。</p><p>将真的原始数据生成的code作Normalization，然后划定真code比较密集的一个范围作为我们的假code，可以使我们选择的code更有意义。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> CNN </tag>
            
            <tag> 自编码器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入分解机器学习实战作业模板代码——二分类、卷积神经网络</title>
      <link href="/2024/01/20/%E6%B7%B1%E5%85%A5%E5%88%86%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E4%BD%9C%E4%B8%9A%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/01/20/%E6%B7%B1%E5%85%A5%E5%88%86%E8%A7%A3%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E4%BD%9C%E4%B8%9A%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E7%B1%BB%E3%80%81%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>刷完理论课去找实战打，找了李宏毅的课程实战，教的是Keras，代码能一行行分析明白，但是是真的一点都不会写。于是去b站找视频补了点实战知识。</p><p>本篇文章将分解作业2和作业3提供的模板代码，提炼出模型训练时的常用操作，包括csv文件的输入输出，numpy的数组操作，keras训练模型的步骤等。</p><p>实战来自李宏毅的机器学习课程：<a href="https://study.163.com/course/courseMain.htm?courseId=1208946807">李宏毅机器学习中文课程 - 网易云课堂 (163.com)</a></p><p>Keras实战视频链接：<a href="https://www.bilibili.com/video/BV15K411k7nD">深度学习框架【Keras项目实战】</a></p><p>作业Kaggle链接：</p><ol><li>收入预测：<a href="https://www.kaggle.com/competitions/ml2019spring-hw2">ML2019SPRING-hw2 | Kaggle</a></li><li>图片情绪分类：<a href="https://www.kaggle.com/competitions/ml2019spring-hw3">ML2019SPRING-hw3 | Kaggle</a></li></ol><h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><h2 id="1-收入预测"><a href="#1-收入预测" class="headerlink" title="1. 收入预测"></a>1. 收入预测</h2><p>根据给定的个人资讯，预测此人的收入能否大于50K。</p><p>数据集X_train包含许多个人信息，Y_train对应他们年收入是否大于50K。训练一个二分类模型，对X_test作预测。</p><p>模板代码：</p><p>概率生成模型(Probabilistic Generative Model)： <a href="https://ntumlta2019.github.io/ml-web-hw2/ProbabilisticGenerativeModel.html">ProbabilisticGenerativeModel (ntumlta2019.github.io)</a></p><p>逻辑回归(Logistic Regression)：<a href="https://ntumlta2019.github.io/ml-web-hw2/LogisticRegression.html">LogisticRegression (ntumlta2019.github.io)</a></p><h2 id="2-图片情绪分类"><a href="#2-图片情绪分类" class="headerlink" title="2. 图片情绪分类"></a>2. 图片情绪分类</h2><p>给定48$*$48像素的图片，判断该图片所表达的情绪，包括0：生气, 1：厌恶, 2：恐惧, 3：高兴, 4：难过, 5：惊讶, 6：中立）</p><p>训练集x_train.csv每一行有两列，第一列label为图片的情绪，第二列为48$*$48个像素值，范围从0~255。训练一个卷积神经网络，对x_test.csv作预测</p><p>模板代码：<a href="https://hackmd.io/hlJAABuoRJa0tzpD8UUHvw">2019 Spring ML HW3 - 手把手教學 - HackMD</a></p><h1 id="二、处理输入输出"><a href="#二、处理输入输出" class="headerlink" title="二、处理输入输出"></a>二、处理输入输出</h1><h2 id="1-读取csv文件"><a href="#1-读取csv文件" class="headerlink" title="1. 读取csv文件"></a>1. 读取csv文件</h2><ul><li><p>利用np.genfromtxt() 需要添加参数delimeter=’,’ 返回的结果是<strong>列表</strong>而不是ndarray对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raw_train = np.genfromtxt(path, delimiter=<span class="string">&#x27;,&#x27;</span>, dtype=<span class="built_in">str</span>, skip_header=<span class="number">1</span>) <span class="comment"># skip_header=1</span></span><br></pre></td></tr></table></figure></li><li><p>引入python自带的csv包，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    raw_train = np.array(<span class="built_in">list</span>(csv.reader(csvfile))[<span class="number">1</span>:], dtype=<span class="built_in">float</span>) <span class="comment"># 取下标[1:]表示去掉表头</span></span><br></pre></td></tr></table></figure><h2 id="2-归一化-标准化-离散化"><a href="#2-归一化-标准化-离散化" class="headerlink" title="2. 归一化/标准化/离散化"></a>2. 归一化/标准化/离散化</h2><p>归一化：$x = \frac{x - x_{min}}{x_{max} - x_{min}}$</p></li></ul><p>标准化：$x = \frac{x - \mu}{\sigma}$</p><p>离散化：将数据标签1，2, …, n转化为[1, 0, …, 0], [0, 1, …, 0], …, [0, 0, …, 1]</p><h3 id="2-1-手动处理"><a href="#2-1-手动处理" class="headerlink" title="2.1 手动处理"></a>2.1 手动处理</h3><ol><li><p>归一化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.<span class="built_in">min</span> = np.<span class="built_in">min</span>(rows, axis=<span class="number">0</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">self.std = np.std(rows, axis=<span class="number">0</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">self.theta = np.ones((rows.shape[<span class="number">1</span>] + <span class="number">1</span>, <span class="number">1</span>), dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows.shape[<span class="number">0</span>]):</span><br><span class="line">    rows[i, :] = (rows[i, :] - self.<span class="built_in">min</span>) / self.std</span><br></pre></td></tr></table></figure></li><li><p>标准化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.mean = np.mean(rows, axis=<span class="number">0</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">self.std = np.std(rows, axis=<span class="number">0</span>).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">self.theta = np.ones((rows.shape[<span class="number">1</span>] + <span class="number">1</span>, <span class="number">1</span>), dtype=<span class="built_in">float</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows.shape[<span class="number">0</span>]):</span><br><span class="line">    rows[i, :] = (rows[i, :] - self.mean) / self.std</span><br></pre></td></tr></table></figure></li></ol><p><strong>对于axis的理解</strong>：axis=i，操作沿着第i个下标变化的方向进行<br>参考：<a href="https://zhuanlan.zhihu.com/p/31275071">Numpy:对Axis的理解 - 知乎 (zhihu.com)</a></p><h3 id="2-2-利用sklearn"><a href="#2-2-利用sklearn" class="headerlink" title="2.2 利用sklearn"></a>2.2 利用sklearn</h3><ol><li>归一化：MinMaxScaler<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler, StandardScaler</span><br><span class="line">data = np.array([[-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">minMaxScaler = MinMaxScaler()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在处理训练数据时使用fit_transform</span></span><br><span class="line">data = minMaxScaler.fit_transform(data)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">[[0.  0.  0.  0.  0. ]</span></span><br><span class="line"><span class="string"> [0.5 0.5 0.5 0.5 0.5]</span></span><br><span class="line"><span class="string"> [1.  1.  1.  1.  1. ]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">test_data = np.array([[-<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>, -<span class="number">6</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="comment"># 在处理测试数据时使用transform</span></span><br><span class="line">test_data = minMaxScaler.transform(test_data)</span><br></pre></td></tr></table></figure></li><li><p>标准化：StandardScaler</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">data = np.array([[-<span class="number">1</span>, -<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">stdScaler = StandardScaler()</span><br><span class="line"><span class="comment"># 在处理训练数据时使用fit_transform</span></span><br><span class="line">data = stdScaler.fit_transform(data)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">[[-1.22474487 -1.22474487 -1.22474487 -1.22474487 -1.22474487]</span></span><br><span class="line"><span class="string"> [ 0.          0.          0.          0.          0.        ]</span></span><br><span class="line"><span class="string"> [ 1.22474487  1.22474487  1.22474487  1.22474487  1.22474487]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在处理测试数据时使用transform</span></span><br><span class="line">test_data = np.array([[-<span class="number">2</span>, -<span class="number">3</span>, -<span class="number">4</span>, -<span class="number">5</span>, -<span class="number">6</span>],</span><br><span class="line">                    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">                    [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">test_data = stdScaler.transform(test_data)</span><br></pre></td></tr></table></figure></li><li><p>离散化：LabelBinarizer</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelBinarizer</span><br><span class="line"></span><br><span class="line">train_label = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">lb = LabelBinarizer()</span><br><span class="line"><span class="comment"># 在处理训练数据时使用fit_transform</span></span><br><span class="line">train_label = lb.fit_transform(train_label)</span><br><span class="line"><span class="built_in">print</span>(train_label)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">[[1 0 0 0 0 0]</span></span><br><span class="line"><span class="string"> [0 1 0 0 0 0]</span></span><br><span class="line"><span class="string"> [0 0 1 0 0 0]</span></span><br><span class="line"><span class="string"> [0 0 0 1 0 0]</span></span><br><span class="line"><span class="string"> [0 0 0 0 1 0]</span></span><br><span class="line"><span class="string"> [0 0 0 0 0 1]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">test_label = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># 在处理测试数据时使用transform</span></span><br><span class="line">test_label = lb.transform(test_label)</span><br><span class="line"><span class="built_in">print</span>(test_label)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">输出结果</span></span><br><span class="line"><span class="string">[[0 1 0 0 0 0]</span></span><br><span class="line"><span class="string"> [0 0 1 0 0 0]</span></span><br><span class="line"><span class="string"> [0 0 0 1 0 0]</span></span><br><span class="line"><span class="string"> [0 0 0 0 1 0]</span></span><br><span class="line"><span class="string"> [0 0 0 0 0 1]</span></span><br><span class="line"><span class="string"> [1 0 0 0 0 0]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="3-数据分割"><a href="#3-数据分割" class="headerlink" title="3. 数据分割"></a>3. 数据分割</h2><p>原始数据如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x_train = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">                   <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)])</span><br><span class="line">y_train = np.array([i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>)])</span><br><span class="line"><span class="built_in">print</span>(x_train.shape[<span class="number">0</span>], y_train.shape[<span class="number">0</span>])</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">10000 10000</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-1-手动分割"><a href="#3-1-手动分割" class="headerlink" title="3.1 手动分割"></a>3.1 手动分割</h3><p>按照比例分割<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">segmentation</span>(<span class="params">x_train, y_train, proportion</span>):</span><br><span class="line">    train_data = []</span><br><span class="line">    train_label = []</span><br><span class="line">    val_data = []</span><br><span class="line">    val_label = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(x_train.shape[<span class="number">0</span>]):</span><br><span class="line">        <span class="keyword">if</span> i % proportion == <span class="number">0</span>:</span><br><span class="line">            val_data.append(x_train[i])</span><br><span class="line">            val_label.append(y_train[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            train_data.append(x_train[i])</span><br><span class="line">            train_label.append(y_train[i])</span><br><span class="line">    train_data = np.array(train_data, dtype=<span class="built_in">float</span>)</span><br><span class="line">    train_label = np.array(train_label, dtype=<span class="built_in">float</span>)</span><br><span class="line">    val_data = np.array(val_data, dtype=<span class="built_in">float</span>)</span><br><span class="line">    val_label = np.array(val_label, dtype=<span class="built_in">float</span>)</span><br><span class="line">    <span class="keyword">return</span> train_data, train_label, val_data, val_label</span><br><span class="line"></span><br><span class="line">train_data, train_label, val_data, val_label = segmentation(x_train, y_train, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(train_data), <span class="built_in">len</span>(train_label), <span class="built_in">len</span>(val_data), <span class="built_in">len</span>(val_label))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">9000 9000 1000 1000</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-2-利用sklearn"><a href="#3-2-利用sklearn" class="headerlink" title="3.2 利用sklearn"></a>3.2 利用sklearn</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SEED = <span class="number">12</span>   <span class="comment"># 指定随机数种子以便再现</span></span><br><span class="line">train_data, train_label, val_data, val_label = (</span><br><span class="line">    train_test_split(x_train, y_train, test_size=<span class="number">0.2</span>, random_state=SEED))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(train_data), <span class="built_in">len</span>(train_label), <span class="built_in">len</span>(val_data), <span class="built_in">len</span>(val_label))</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">8000 2000 8000 2000</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="三、模型构建"><a href="#三、模型构建" class="headerlink" title="三、模型构建"></a>三、模型构建</h1><h2 id="1-概率生成模型"><a href="#1-概率生成模型" class="headerlink" title="1. 概率生成模型"></a>1. 概率生成模型</h2><p>相关文章：<a href="https://juejin.cn/post/7325652953540739083">机器学习笔记——概率生成模型 - 掘金 (juejin.cn)</a></p><p>1.概率生成模型要求先将数据集分割为两部分：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class_0_id = []</span><br><span class="line">class_1_id = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.data[<span class="string">&#x27;Y_train&#x27;</span>].shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">if</span> self.data[<span class="string">&#x27;Y_train&#x27;</span>][i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">        class_0_id.append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        class_1_id.append(i)</span><br><span class="line"></span><br><span class="line">class_0 = self.data[<span class="string">&#x27;X_train&#x27;</span>][class_0_id]</span><br><span class="line">class_1 = self.data[<span class="string">&#x27;X_train&#x27;</span>][class_1_id]</span><br></pre></td></tr></table></figure><br>这里用到了高级索引，参考：<a href="https://www.runoob.com/numpy/numpy-advanced-indexing.html">NumPy 高级索引 | 菜鸟教程 (runoob.com)</a></p><p>2.分别求两部分的均值和协方差矩阵，共享协方差矩阵是两者的加权平均和：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mean_0 = np.mean(class_0, axis=<span class="number">0</span>)</span><br><span class="line">mean_1 = np.mean(class_1, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">n = class_0.shape[<span class="number">1</span>]</span><br><span class="line">cov_0 = np.zeros((n, n))</span><br><span class="line">cov_1 = np.zeros((n, n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(class_0.shape[<span class="number">0</span>]):</span><br><span class="line">    cov_0 += np.dot(np.transpose([class_0[i] - mean_0]), [(class_0[i] - mean_0)]) / class_0.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(class_1.shape[<span class="number">0</span>]):</span><br><span class="line">    cov_1 += np.dot(np.transpose([class_1[i] - mean_1]), [(class_1[i] - mean_1)]) / class_1.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">cov = (cov_0 * class_0.shape[<span class="number">0</span>] + cov_1 * class_1.shape[<span class="number">0</span>]) / (class_0.shape[<span class="number">0</span>] + class_1.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><p>3.由概率生成模型的参数为：</p><script type="math/tex; mode=display">\omega = (\mu^0 - \mu^1)^T \Sigma^{-1}</script><script type="math/tex; mode=display">b = - \frac{1}{2} (\mu^0)^T \Sigma^{-1} \mu^0 + \frac{1}{2} (\mu^1)^T \Sigma^{-1} \mu^1 + \ln{ \frac{m_0}{m_1}}</script><p>得到<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">self.w = np.transpose(((mean_0 - mean_1)).dot(inv(cov)))</span><br><span class="line">self.b = (- <span class="number">0.5</span>) * (mean_0).dot(inv(cov)).dot(mean_0) \</span><br><span class="line">         + <span class="number">0.5</span> * (mean_1).dot(inv(cov)).dot(mean_1) \</span><br><span class="line">         + np.log(<span class="built_in">float</span>(class_0.shape[<span class="number">0</span>]) / class_1.shape[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><h2 id="2-逻辑回归"><a href="#2-逻辑回归" class="headerlink" title="2. 逻辑回归"></a>2. 逻辑回归</h2><p>1.打乱数据集：利用高级索引，将特征和标签同时打乱且仍然能够互相对应：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> shuffle</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_shuffle</span>(<span class="params">X, Y</span>):</span><br><span class="line">    randomize = np.arange(X.shape[<span class="number">0</span>])</span><br><span class="line">    shuffle(randomize)</span><br><span class="line">    <span class="keyword">return</span> X[randomize], Y[randomize]</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X = np.array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">              [<span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">              [<span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">              [<span class="number">9</span>, <span class="number">10</span>]])</span><br><span class="line">Y = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">X, Y = _shuffle(X, Y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(X)</span><br><span class="line"><span class="built_in">print</span>(Y)</span><br></pre></td></tr></table></figure><br>输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[ 5  6]</span><br><span class="line"> [ 9 10]</span><br><span class="line"> [ 1  2]</span><br><span class="line"> [ 7  8]</span><br><span class="line"> [ 3  4]]</span><br><span class="line">[2 4 0 3 1]</span><br></pre></td></tr></table></figure></p><p>2.batch划分：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>(np.floor(<span class="built_in">len</span>(Y_train)/batch_size))):</span><br><span class="line">           X = X_train[idx*batch_size:(idx+<span class="number">1</span>)*batch_size]</span><br><span class="line">           Y = Y_train[idx*batch_size:(idx+<span class="number">1</span>)*batch_size]</span><br></pre></td></tr></table></figure></p><p>3.求梯度：根据梯度公式$\frac{\partial J(\theta) }{\partial \theta_j}= \frac{1}{m} [ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} + \lambda \theta_j]$，得到：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_gradient_regularization</span>(<span class="params">X, Y_label, w, b, lamda</span>):</span><br><span class="line">    <span class="comment"># return the mean of the graident</span></span><br><span class="line">    y_pred = get_prob(X, w, b)</span><br><span class="line">    pred_error = Y_label - y_pred</span><br><span class="line">    w_grad = -np.mean(np.multiply(pred_error.T, X.T), <span class="number">1</span>)+lamda*w</span><br><span class="line">    b_grad = -np.mean(pred_error)</span><br><span class="line">    <span class="keyword">return</span> w_grad, b_grad</span><br></pre></td></tr></table></figure><br>详解：梯度$w$和$b$合起来就是公式中的$\theta$，为一个$n + 1$维列向量<br>pred_error 和 X 都是$m \times n$维矩阵，两者作内积后需要对$m$所在维度求平均值，可以有以下两种实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先转置得到n*m维矩阵，再在第二个维度，即axis=1上求平均值</span></span><br><span class="line">w_grad = -np.mean(np.multiply(pred_error.T, X.T), axis=<span class="number">1</span>) + lamda*w </span><br><span class="line"><span class="comment"># 对m*n维矩阵在第一个维度求平均值，即axis=0，再转置</span></span><br><span class="line">w_grad = -np.mean(np.multiply(pred_error, X), axis=<span class="number">0</span>).T + lamda*w </span><br></pre></td></tr></table></figure></p><h2 id="3-卷积神经网络"><a href="#3-卷积神经网络" class="headerlink" title="3. 卷积神经网络"></a>3. 卷积神经网络</h2><p>搭建网络那就要按李宏毅说的三步走了！</p><ol><li>打开冰箱：定义网络结构，即选定一批函数</li><li>把大象放进冰箱里：确定损失函数和优化方法，即定义评价函数优劣的方法</li><li>关冰箱门：拟合数据集，找到最优的函数</li></ol><p>建议多查阅api文档：<a href="https://keras.io/api">Keras API文档</a></p><h3 id="3-1-定义网络结构：model-add"><a href="#3-1-定义网络结构：model-add" class="headerlink" title="3.1 定义网络结构：model.add"></a>3.1 定义网络结构：model.add</h3><h4 id="3-1-1-卷积层"><a href="#3-1-1-卷积层" class="headerlink" title="3.1.1 卷积层"></a>3.1.1 卷积层</h4><p>后面常接BatchNormalization，能加快训练和提升性能（未考究）</p><ul><li>在torch中：torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0.dilation=1, groups=1, bias=True, padding_mode=’zeros’),示例：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">nn.BatchNorm2d(<span class="number">64</span>)</span><br></pre></td></tr></table></figure></li><li>在keras中：keras.layers.Conv2D(<br>filters,<br>kernel_size,<br>strides=(1, 1),<br>padding=”valid”,<br>kernel_initializer=”glorot_uniform”,<br>bias_initializer=”zeros”,<br>…<br>)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.add(Conv2D(input_shape=(<span class="number">48</span>, <span class="number">48</span>, <span class="number">1</span>), filters=<span class="number">64</span>, kernel_size=(<span class="number">4</span>, <span class="number">4</span>), strides=<span class="number">2</span>, padding=<span class="string">&#x27;same&#x27;</span>,</span><br><span class="line">                 kernel_initializer=RandomNormal(mean=<span class="number">0.0</span>, stddev=<span class="number">0.05</span>, seed=SEED)))</span><br><span class="line">model.add(BatchNormalization())</span><br></pre></td></tr></table></figure><h4 id="3-1-2-激活层"><a href="#3-1-2-激活层" class="headerlink" title="3.1.2 激活层"></a>3.1.2 激活层</h4><ul><li>在torch中：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.LeakyReLU(<span class="number">0.2</span>)</span><br></pre></td></tr></table></figure><ul><li>在keras中：不太理解，有的是在layers引入，有的在activations引入，也可以在layer的参数中指定<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(LeakyReLU(alpha=<span class="number">0.2</span>))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(layers.Activation(activations.relu))</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-3-池化层"><a href="#3-1-3-池化层" class="headerlink" title="3.1.3 池化层"></a>3.1.3 池化层</h4><ul><li>在torch中：torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>)  <span class="comment"># kernel_size=2, stride=2, padding=0</span></span><br></pre></td></tr></table></figure></li><li>在keras中：<br>keras.layers.MaxPooling2D(<br>pool_size=(2, 2), strides=None, padding=”valid”, …<br>)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(MaxPooling2D((<span class="number">2</span>, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-1-4-全连接层"><a href="#3-1-4-全连接层" class="headerlink" title="3.1.4 全连接层"></a>3.1.4 全连接层</h4><ul><li>在torch中：torch.nn.Linear(in_features, out_features, bias=True)<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nn.Linear(<span class="number">256</span>*<span class="number">3</span>*<span class="number">3</span>, <span class="number">1024</span>)</span><br></pre></td></tr></table></figure></li><li>在keras中：<br>keras.layers.Dense(<br>units,<br>activation=None,<br>use_bias=True,<br>kernel_initializer=”glorot_uniform”,<br>bias_initializer=”zeros”,<br>…<br>)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(Dense(units=<span class="number">1024</span>, activation=<span class="string">&#x27;relu&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="3-1-5-一些优化"><a href="#3-1-5-一些优化" class="headerlink" title="3.1.5 一些优化"></a>3.1.5 一些优化</h4><p><strong>1. 添加kernel_initialization:</strong></p><ul><li>在torch中：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian_weights_init</span>(<span class="params">m</span>):</span><br><span class="line">    classname = m.__class__.__name__</span><br><span class="line">    <span class="keyword">if</span> classname.find(<span class="string">&#x27;Conv&#x27;</span>) != -<span class="number">1</span> <span class="keyword">and</span> classname.find(<span class="string">&#x27;Conv&#x27;</span>) == <span class="number">0</span>:</span><br><span class="line">        m.weight.data.normal_(<span class="number">0.0</span>, <span class="number">0.02</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">self.cnn = nn.Sequential(</span><br><span class="line">           <span class="comment"># 省略大量代码</span></span><br><span class="line">        )</span><br><span class="line">self.fc = nn.Sequential(</span><br><span class="line">           <span class="comment"># 省略大量代码</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">self.cnn.apply(gaussian_weights_init)</span><br><span class="line">self.fc.apply(gaussian_weights_init)</span><br></pre></td></tr></table></figure></li><li>在keras中：在带参数的layer中添加参数kernel_initalization（好麻烦）</li></ul><p>问了gpt，他说可以这样，还没试过：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initializer = RandomNormal(mean=<span class="number">0.0</span>, stddev=<span class="number">0.05</span>)</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> layer <span class="keyword">in</span> model.layers: </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">hasattr</span>(layer, <span class="string">&#x27;kernel_initializer&#x27;</span>): </span><br><span class="line">        layer.kernel_initializer = initializer</span><br></pre></td></tr></table></figure></p><p><strong>2. 添加Dropout层:</strong></p><p>丢弃部分神经网络的输入，减少过拟合（好像不能跟BatchNormalization一起用）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.add(Dropout(rate=<span class="number">0.5</span>))</span><br></pre></td></tr></table></figure></p><h3 id="3-2-选择优化方法：model-complie"><a href="#3-2-选择优化方法：model-complie" class="headerlink" title="3.2 选择优化方法：model.complie"></a>3.2 选择优化方法：model.complie</h3><p>源码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&quot;rmsprop&quot;</span>,</span><br><span class="line">    loss=<span class="literal">None</span>,</span><br><span class="line">    loss_weights=<span class="literal">None</span>,</span><br><span class="line">    metrics=<span class="literal">None</span>,</span><br><span class="line">    weighted_metrics=<span class="literal">None</span>,</span><br><span class="line">    run_eagerly=<span class="literal">False</span>,</span><br><span class="line">    steps_per_execution=<span class="number">1</span>,</span><br><span class="line">    jit_compile=<span class="string">&quot;auto&quot;</span>,</span><br><span class="line">    auto_scale_loss=<span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><br>optimizer: 优化器, 包括SGD, RMSprop, Adam等<br>metrics: 评价标准, 包括accuracy(准确率), binary_accuracy(二分类)、categorical_accuracy(多分类) 等<br>loss: 损失函数, 包括mse, binary_crossentropy, categorical_crossentropy等<br>verbose: 日志显示，verbose=0不显示, verbose=1为每个verbose显示进度条, verbose=2每个verbose输出一次</p><p>示例:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.<span class="built_in">compile</span>(loss=<span class="string">&#x27;categorical_crossentropy&#x27;</span>,</span><br><span class="line">              optimizer=Adam(learning_rate=<span class="number">0.001</span>),</span><br><span class="line">              metrics=[keras.metrics.CategoricalAccuracy()])</span><br></pre></td></tr></table></figure></p><h3 id="3-3-拟合数据集：model-fit"><a href="#3-3-拟合数据集：model-fit" class="headerlink" title="3.3 拟合数据集：model.fit"></a>3.3 拟合数据集：model.fit</h3><p>fit的参数如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.fit(x, y, batch_size, epochs, verbose, validation_split, validation_data, validation_freq)</span><br></pre></td></tr></table></figure><br>fit返回一个History对象记录了每一个epoch的数据，可用于绘图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">H = model.fit(x_data, x_label,</span><br><span class="line">              epochs=EPOCHS,</span><br><span class="line">              batch_size=BATCH_SIZE,</span><br><span class="line">              validation_data=(val_data, val_label),</span><br><span class="line">              verbose=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plot</span></span><br><span class="line">N = np.arange(<span class="number">0</span>, EPOCHS)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(N, H.history[<span class="string">&quot;loss&quot;</span>], label=<span class="string">&quot;train loss&quot;</span>)</span><br><span class="line">plt.plot(N, H.history[<span class="string">&quot;val_loss&quot;</span>], label=<span class="string">&quot;val loss&quot;</span>)</span><br><span class="line">plt.plot(N, H.history[<span class="string">&quot;accuracy&quot;</span>], label=<span class="string">&quot;train_acc&quot;</span>)</span><br><span class="line">plt.plot(N, H.history[<span class="string">&quot;val_accuracy&quot;</span>], label=<span class="string">&quot;val_acc&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Training Loss and Accuracy (Simple NN)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Epoch #&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss/Accuracy&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><br>fit后的模型可以对测试数据作预测<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pred_raw = model.predict(test_data)</span><br></pre></td></tr></table></figure><br>及时保存模型，我可不想白练了一晚<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存模型</span></span><br><span class="line">save_path = <span class="string">&#x27;./model_0120&#x27;</span></span><br><span class="line">model.save(save_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><blockquote><p>还有看到fit_generator的，之后再看一下</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记——概率生成模型</title>
      <link href="/2024/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>吴恩达的视频里没提到概率生成模型，在李宏毅的作业2看到了，感觉挺有必要理解的，可以很自然而然地引出逻辑回归的模型。</p><p>参考：<a href="https://study.163.com/course/courseLearn.htm?courseId=1208946807">李宏毅机器学习中文课程 - 网易云课堂：分类：概率生成模型</a></p><h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>已知m组数据$x^{(1)}, x^{(2)}, …, x^{(m)}$，每组数据表示n个特征,可写为一个n维的向量<br>即：<script type="math/tex">(x^{(i)})^T = ( x^{(i)}_1, ..., x^{(i)}_n)</script><br>且每组数据的真实值$y^{(i)}$只能为0或1</p><p>给定一个数据$x$，预测$x$对应的$y$值。</p><h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><h2 id="1-贝叶斯公式求概率表达式"><a href="#1-贝叶斯公式求概率表达式" class="headerlink" title="1. 贝叶斯公式求概率表达式"></a>1. 贝叶斯公式求概率表达式</h2><p>由题可知，我们根据真实值将$m$组数据分为两类$C_0$和$C_1$，其中$C_0$代表真实值为$0$的数据的集合，一共有$m_0$组，$C_1$代表真实值为$1$的数据的集合，一共有$m_1$组</p><p>那么给定数据$x$，由贝叶斯公式，$x$出现在$C_0$的概率为</p><script type="math/tex; mode=display">P(C_0 | x) = \frac{P(x | C_0) P(C_0)} { P(x | C_0) P(C_0) + P(x | C_1) P(C_1) }</script><script type="math/tex; mode=display">P(C_0 | x) = \frac{1} { 1 + \frac{P(x | C_1) P(C_1)}{P(x | C_0) P(C_0)} }</script><p>其中，$P(x | C_0)$代表给定集合$C_0$，出现数据为$x$的概率，即</p><script type="math/tex; mode=display">P(x | C_0) = f_{\mu^0, \Sigma^0}(x)</script><p>其中$ \mu^0 $ 和 $ \Sigma^0 $为$ C_0 $的均值和协方差矩阵，由$C_0$确定。</p><p>同理，$ P(x | C_1) = f_{\mu^1, \Sigma^1}(x) $</p><p>而$P(C_0)$代表随机取一组数据在$C_0$的概率，即$ P(C_0) = \frac{m_0}{m_0 + m_1} $</p><p>同理，$ P(C_1) = \frac{m_1}{m_0 + m_1} $</p><h2 id="2-由数据集求概率密度函数"><a href="#2-由数据集求概率密度函数" class="headerlink" title="2. 由数据集求概率密度函数"></a>2. 由数据集求概率密度函数</h2><p>当数据足够大时，由中心极限定理，$C_0$服从正态分布</p><script type="math/tex; mode=display">f_{\mu^0, \Sigma^0}(x) = \frac{1}{ (2\pi)^{\frac{n}{2}} |\Sigma^0|^{ \frac{1}{2}}} exp(-\frac{1}{2} (x - \mu^0)^T (\Sigma^0)^{-1} (x - \mu^0))</script><p>由已有数据求$ \mu^0 $和 $\Sigma^0$的最大似然估计为</p><script type="math/tex; mode=display">\mu^0 = \frac{1}{m_0} \sum_{i: y^{(i)} = 0} x^{(i)}</script><script type="math/tex; mode=display">\Sigma^0 = \frac{1}{m_0} \sum_{i: y^{(i)} = 0} (x^{(i)} - \mu^0) (x^{(i)} - \mu^0)^T</script><p>同理，由$C_1$确定的概率分布函数、均值、协方差矩阵为</p><script type="math/tex; mode=display">f_{\mu^1, \Sigma^1}(x) = \frac{1}{ (2\pi)^{\frac{n}{2}} |\Sigma^1|^{ \frac{1}{2}}} exp(-\frac{1}{2} (x - \mu^1)^T (\Sigma^1)^{-1} (x - \mu^1))</script><script type="math/tex; mode=display">\mu^1 = \frac{1}{m_1} \sum_{i: y^{(i)} = 1} x^{(i)}</script><script type="math/tex; mode=display">\Sigma^1 = \frac{1}{m_1} \sum_{i: y^{(i)} = 1} (x^{(i)} - \mu^1) (x^{(i)} - \mu^1)^T</script><h2 id="3-公式整理"><a href="#3-公式整理" class="headerlink" title="3. 公式整理"></a>3. 公式整理</h2><p>对1中表达式做变形，令</p><script type="math/tex; mode=display">\frac{P(x | C_1) P(C_1)}{P(x | C_0) P(C_0)}  = e^{-z}</script><p>得</p><script type="math/tex; mode=display">P(C_0 | x) =  \frac{1} { 1 + e^{-z} } = g(z)</script><script type="math/tex; mode=display">z = -\ln {\frac{P(x | C_1) P(C_1)}{P(x | C_0) P(C_0)} } = \ln {\frac{P(x | C_0) }{ P(x | C_1)} } + \ln { \frac{ P(C_0) }{ P(C_1) } }</script><p>将2中概率分布函数代入到表达式中，得</p><script type="math/tex; mode=display">z = \ln{\frac{ |\Sigma|^1}{ | \Sigma|^0 } } - \frac{1}{2} (x - \mu^0)^T (\Sigma^0)^{-1} (x - \mu^0) + \frac{1}{2} (x - \mu^1)^T (\Sigma^1)^{-1} (x - \mu^1)) + \ln{ \frac{m_0}{m_1}}</script><p>若将$\Sigma^0$和$\Sigma^1$等同为一个值$\Sigma$（未考究），可继续化简得：</p><script type="math/tex; mode=display">z = (\mu^0 - \mu^1)^T \Sigma^{-1} x - \frac{1}{2} (\mu^0)^T \Sigma^{-1} \mu^0 + \frac{1}{2} (\mu^1)^T \Sigma^{-1} \mu^1 + \ln{ \frac{m_0}{m_1}}</script><p>令$ z = \omega x + b$，则有</p><script type="math/tex; mode=display">\omega = (\mu^0 - \mu^1)^T \Sigma^{-1}</script><script type="math/tex; mode=display">b = - \frac{1}{2} (\mu^0)^T \Sigma^{-1} \mu^0 + \frac{1}{2} (\mu^1)^T \Sigma^{-1} \mu^1 + \ln{ \frac{m_0}{m_1}}</script><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>既然预测$x$在一个分类中的概率$P(C_0 | x)$，能被关于$x$与某一向量的线性组合的函数，即$\omega x+ b$，$g(\omega x + b) = \frac{1}{1+ e^{\omega x+ b}}$，我们不妨假设向量</p><script type="math/tex; mode=display">\theta^T x = \omega x + b</script><p>这就很好的解释了为什么要引入$g(\theta^T x)$作为逻辑回归的假设。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建hexo博客时，deploy出现ssh连接超时的问题</title>
      <link href="/2024/01/17/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E6%97%B6%EF%BC%8Cdeploy%E5%87%BA%E7%8E%B0ssh%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/01/17/%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E6%97%B6%EF%BC%8Cdeploy%E5%87%BA%E7%8E%B0ssh%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>hexo cl和hexo g都没有问题，但是在hexo d步骤出现了：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ssh: <span class="title">connect</span> <span class="title">to</span> <span class="title">host</span> <span class="title">github.com</span> <span class="title">port</span> 22: <span class="title">Connection</span> <span class="title">timed</span> <span class="title">out</span>  </span></span><br><span class="line"><span class="function"><span class="title">fatal</span>: <span class="title">Could</span> <span class="title">not</span> <span class="title">read</span> <span class="title">from</span> <span class="title">remote</span> <span class="title">repository</span>. <span class="title">Please</span> <span class="title">make</span> <span class="title">sure</span> <span class="title">you</span> <span class="title">have</span> <span class="title">the</span> <span class="title">correct</span> <span class="title">access</span> <span class="title">rights</span> <span class="title">and</span> <span class="title">the</span> <span class="title">repository</span> <span class="title">exists</span>.   </span></span><br><span class="line"><span class="function"><span class="title">FATAL</span>  <span class="title">Something</span>&#x27;<span class="title">s</span> <span class="title">wrong</span>. <span class="title">Maybe</span> <span class="title">you</span> <span class="title">can</span> <span class="title">find</span> <span class="title">the</span> <span class="title">solution</span> <span class="title">here</span>: <span class="title">https</span>://<span class="title">hexo.io</span>/<span class="title">docs</span>/<span class="title">troubleshooting.html</span> </span></span><br><span class="line"><span class="function"><span class="title">Error</span>: <span class="title">Spawn</span> <span class="title">failed</span></span></span><br></pre></td></tr></table></figure><h1 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h1><p>参考：<a href="https://blog.csdn.net/the__future/article/details/130038818">关于本地git通过ssh链接github时 time out问题的解决方法_github timeout-CSDN博客</a>)</p><p>在C:\Users\YourUserName\ .ssh目录下找到config文件，没有就新建一个<br>(其中，YourUserName是你的用户名，因人而异)</p><p>在windows中，这个config文件没有后缀，即没有指定类型，而在文件管理器中创建文件需要指定类型。有两种办法解决：</p><ol><li>我们可以复制同一目录下，类型仅为“文件”二字的其他文件，然后右键重命名为config</li><li>在平时写代码的IDE下可以直接创建没有指定类型的File(我知道IDEA可以)</li></ol><p>右键config文件，选择打开方式，选择记事本，将内建内容修改为如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com HostName </span><br><span class="line">ssh.github.com </span><br><span class="line">User git Port 22</span><br><span class="line">PreferredAuthentications publickey </span><br><span class="line">IdentityFile C:\Users\YourUserName\.ssh\id_rsa # 解决问题的关键</span><br></pre></td></tr></table></figure><br>与引用的文章不同，我们解决问题的关键是第五行，将IdentityFile后面的文件路径修改为自己电脑下id_rsa的路径就好了</p><p>注意：ssh默认连接22端口，如果第三行将端口号修改成了443，应该在博客文件夹主配置文件_config.yaml中在deploy下指定端口，如：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span>  </span><br><span class="line">    <span class="attr">type:</span> <span class="string">git</span>  </span><br><span class="line">    <span class="attr">repo:</span> <span class="string">git@github.com:andreww1219/andreww1219.github.com.git</span>  </span><br><span class="line">    <span class="attr">branch:</span> <span class="string">master</span>  </span><br><span class="line">    <span class="attr">port:</span> <span class="number">443</span> <span class="comment"># 这句话指定端口</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 踩坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记——异常检测、推荐系统、大规模机器学习、图片OCR</title>
      <link href="/2024/01/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E3%80%81%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E3%80%81%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%81%E5%9B%BE%E7%89%87OCR/"/>
      <url>/2024/01/16/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E3%80%81%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E3%80%81%E5%A4%A7%E8%A7%84%E6%A8%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%81%E5%9B%BE%E7%89%87OCR/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>完结撒花！！！但是感觉只是了解了部分算法的思想，具体的实现还得找东西练一练。</p><p>该篇笔记包括：</p><ol><li>第十五章————异常检测</li><li>第十六章————推荐系统</li><li>第十七章————大规模机器学习</li><li>第十八章————图片OCR</li></ol><p>视频链接：<a href="https://www.bilibili.com/video/BV164411b7dx">[中英字幕]吴恩达机器学习系列课程</a></p><h1 id="一、异常检测-Anomaly-Detection"><a href="#一、异常检测-Anomaly-Detection" class="headerlink" title="一、异常检测(Anomaly Detection)"></a>一、异常检测(Anomaly Detection)</h1><h2 id="1-问题动机"><a href="#1-问题动机" class="headerlink" title="1. 问题动机"></a>1. 问题动机</h2><p>在<strong>正常和异常的数据集都很大</strong>的时候，我们可以使用<strong>监督学习</strong>的算法，对正常类别以及出现各种异常类别进行区分。</p><p>但是，当<strong>异常的数据集较小而且异常种类很多</strong>时，监督学习很难对异常有明确的感觉，我们更倾向于使用接下来要提到的<strong>异常检测</strong>算法。</p><h2 id="2-异常检测算法"><a href="#2-异常检测算法" class="headerlink" title="2. 异常检测算法"></a>2. 异常检测算法</h2><h3 id="2-1-数据划分"><a href="#2-1-数据划分" class="headerlink" title="2.1 数据划分"></a>2.1 数据划分</h3><p>已知数据集有较大量的正常样本，以及少量异常样本，例如：10000正常样本，20异常样本。我们将其划分为：</p><ol><li>训练集：6000正常样本</li><li>验证集：2000正常样本，10异常样本</li><li>测试集：2000正常样本，10异常样本</li></ol><h3 id="2-2-算法描述"><a href="#2-2-算法描述" class="headerlink" title="2.2 算法描述"></a>2.2 算法描述</h3><p>给定训练集$(x^{(1)}, x^{(2)}, …, x^{(m)})$，样本的每一特征都互相独立且满足正态分布，即$x_j \sim N(\mu_j, \sigma_j^2)$</p><p>得到样本每个特征的均值和方差：</p><script type="math/tex; mode=display">\mu_j = \frac{1}{m} \sum_{i=1}^m x_j^{(i)}</script><script type="math/tex; mode=display">\sigma_j^2 = \frac{1}{m} \sum_{i=1}^m (x_j^{(i)} - \mu_j)^2</script><p>给定需要预测的样本$x$，计算该样本在已有均值和方差的情况下出现的概率，也就是正常的概率为：</p><script type="math/tex; mode=display">p(x) = p(x_1; \mu_1, \sigma_1^2) \times p(x_2; \mu_2, \sigma_2^2) \times... \times p(x_n; \mu_n, \sigma_n^2) = \prod_{j=1}^n p(x_j; \mu_j, \sigma_j^2)</script><p>该式子成立的隐含条件为样本的每一个特征互相独立</p><p>我们人为设置一个边界$ \epsilon $用于判断当$p(x) &lt; \epsilon $是，$ x $为异常点</p><h3 id="2-3-优化方法"><a href="#2-3-优化方法" class="headerlink" title="2.3 优化方法"></a>2.3 优化方法</h3><ol><li><p>选择合适的$\epsilon$：使用$F_1 = 2\frac{PR}{P+R}$评估异常检测系统，其中$P$为查准率，$R$为召回率，使用交叉验证集对$ \epsilon $作选择</p></li><li><p>对不服从正态分布的特征$x$做操作如：$x \leftarrow log(x + C)$、$ x \leftarrow x^C$ ，使其近似呈正态分布</p></li><li><p>当不同特征如$x_1$和$x_2$之间有相关性时，构造特征$x_3 = f(x_1, x_2)$如$x_3 = \frac{x_1}{x_2}$来鉴别新样本中$x_1$和$x_2$之间的关系正常</p></li><li><p>人工检查预测错误的异常点，增加对应的特征</p></li></ol><h2 id="3-多元高斯分布的异常检测"><a href="#3-多元高斯分布的异常检测" class="headerlink" title="3. 多元高斯分布的异常检测"></a>3. 多元高斯分布的异常检测</h2><h3 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h3><p>对每一特征都满足正态分布的训练集$(x^{(1)}, x^{(2)}, …, x^{(m)})$，求多元高斯分布的均值和协方差矩阵为</p><script type="math/tex; mode=display">\mu = \frac{1}{m} \sum_{i=1}^m x^{(i)}</script><script type="math/tex; mode=display">\Sigma = \frac{1}{m} \sum_{i=1}^m (x^{(i)} - \mu)(x^{(i)} - \mu)^T</script><p>给定需要预测的样本$x$，计算该样本是正常的概率为：</p><script type="math/tex; mode=display">p(x) = \frac{1}{(2\pi)^{\frac{n}{2}} |\Sigma|^{\frac{1}{2}} } exp(-\frac{1}{2} (x - \mu)^T \Sigma^{-1} (x - \mu))</script><h3 id="3-2-与原本的模型比较"><a href="#3-2-与原本的模型比较" class="headerlink" title="3.2 与原本的模型比较"></a>3.2 与原本的模型比较</h3><ol><li>多元高斯分布能自动检测到各特征之间的相关性</li><li>多元高斯分布需要计算$n \times n$维矩阵$\Sigma$的逆，在$n$即特征数量很多时表现不好</li><li>多元高斯分布只有在$m \gt n$或者说矩阵$\Sigma$可逆时可以使用(未考究)</li></ol><h1 id="二、推荐系统-Recommender-Systems"><a href="#二、推荐系统-Recommender-Systems" class="headerlink" title="二、推荐系统(Recommender Systems)"></a>二、推荐系统(Recommender Systems)</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>已知用户的数量$n_u$，作品的数量$n_m$，<br>$r(i, j)$表示用户$j$对作品$i$打过分，$y^{(i,j)}$表示用户用户$j$对作品$i$打的分，可记作$n_m \times n_u$维矩阵$Y$<br>$x^{(j)}$表示作品$j$的特征，可记作$n_m \times n$维矩阵$X$，$n$为特征的数量<br>$\theta^{(i)}$表示用户的偏好，即$(\theta^{(i)})^T x^{(i)}$可以用于预测$y^{(i,j)}$，可记作$n_u \times n$维矩阵$X\Theta^1T$<br>那么$X\Theta^T$可用于预测$Y$</p><ol><li>已知<strong>用户对部分作品的打分</strong>和<strong>作品的的特征</strong>，求<strong>用户的偏好</strong>，预测用户对其他作品的打分</li><li>已知<strong>用户对部分作品的打分</strong>和<strong>用户的偏好</strong>，推断<strong>作品的特征</strong></li></ol><h2 id="2-基于内容的推荐算法"><a href="#2-基于内容的推荐算法" class="headerlink" title="2. 基于内容的推荐算法"></a>2. 基于内容的推荐算法</h2><p>基于内容的推荐算法，适用的问题是：<br>已知<strong>用户对部分作品的打分</strong>和<strong>作品的的特征</strong>，求<strong>用户的偏好</strong>，预测用户对其他作品的打分</p><p>基于内容的推荐算法本质是梯度下降求解线性回归的问题，优化目标为</p><p>对于每个用户$j$，找到$\theta^{(j)}$，最小化损失函数如下</p><script type="math/tex; mode=display">J(\theta^{(j)}) = \frac{1}{2} \sum_{i: r(i, j) = 1} ((\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \frac{\lambda}{2} \sum_{k=1}^{n}( \theta_k^{(j)} )^2</script><p>由于每个用户之间互不相关，可以对每个用户的优化目标的加和作为总的优化目标，即最小化</p><script type="math/tex; mode=display">J(\theta^{(1)}, ..., \theta^{(n_u)}) = \frac{1}{2} \sum_{j=1}^{n_u} \sum_{i: r(i, j) = 1} ((\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \frac{\lambda}{2} \sum_{j=1}^{n_u} \sum_{k=1}^{n}( \theta_k^{(j)} )^2</script><p>得到梯度下降的迭代式如下：</p><script type="math/tex; mode=display">\theta_k^{(j)} = \theta_k^{(j)} - \alpha \sum_{i: r(i, j) = 1} (\theta^{(j)})^T x^{(i)} - y^{(i, j)})x_k^{(i)} when \space k = 0</script><script type="math/tex; mode=display">\theta_k^{(j)} = \theta_k^{(j)} - \alpha ( \sum_{i: r(i, j) = 1} (\theta^{(j)})^T x^{(i)} - y^{(i, j)})x_k^{(i)} + \lambda \theta_k^{(j)})when \space k \ne 0</script><h2 id="3-协同过滤"><a href="#3-协同过滤" class="headerlink" title="3. 协同过滤"></a>3. 协同过滤</h2><p>同理可得，已知<strong>用户对部分作品的打分</strong>和<strong>用户的偏好</strong>，推断<strong>作品的特征</strong>可以转化为：</p><p>对于每个作品$i$，找到$x^{(i)}$，最小化损失函数如下：</p><script type="math/tex; mode=display">J(x^{(i)}) = \frac{1}{2} \sum_{j: r(i, j) = 1} ((\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \frac{\lambda}{2} \sum_{k=1}^{n}( x_k^{(i)} )^2</script><p>同理可得总的优化目标为最小化</p><script type="math/tex; mode=display">J(x^{(1)}, ..., x^{(n_m)}) = \frac{1}{2} \sum_{i=1}^{n_m} \sum_{j: r(i, j) = 1} ((\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \frac{\lambda}{2} \sum_{i=1}^{n_m} \sum_{k=1}^{n}( x_k^{(i)} )^2</script><p>与基于内容的推荐算法相结合，可以在随机初始化$\Theta$或$X$的情况下，对它们依次作梯度下降，比如：</p><script type="math/tex; mode=display">\Theta \rightarrow X \rightarrow \Theta \rightarrow X \rightarrow \Theta \cdots</script><p>或者，抽象出它们共同的优化目标，即最小化以下损失函数：</p><script type="math/tex; mode=display">J(\theta^{(1)}, ..., \theta^{(n_u)}, x^{(1)}, ..., x^{(n_m)}) = \frac{1}{2}  \sum_{(i, j): r(i, j) = 1} ((\theta^{(j)})^T x^{(i)} - y^{(i, j)})^2 + \frac{\lambda}{2} \sum_{j=1}^{n_u} \sum_{k=1}^{n}( \theta_k^{(j)} )^2  + \frac{\lambda}{2} \sum_{i=1}^{n_m} \sum_{k=1}^{n}( x_k^{(i)} )^2</script><p>在<strong>仅有用户对部分作品打分</strong>的情况下，同时求解$\Theta$和$X$，其梯度下降的迭代式为</p><script type="math/tex; mode=display">x_k^{(i)} = x_k^{(i)} - \alpha ( \sum_{j: r(i, j) = 1} (\theta^{(j)})^T x^{(i)} - y^{(i, j)})\theta_k^{(j)} + \lambda x_k^{(i)})</script><script type="math/tex; mode=display">\theta_k^{(j)} = \theta_k^{(j)} - \alpha ( \sum_{i: r(i, j) = 1} (\theta^{(j)})^T x^{(i)} - y^{(i, j)})x_k^{(i)} + \lambda \theta_k^{(j)})</script><h2 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4. 实现细节"></a>4. 实现细节</h2><ol><li>对矩阵$Y$作均值化，可以使模型对未曾打分的用户的预测有意义</li><li>可以用$|x^{(i)} - x^{(j)}|$表示两个作品的相似程度</li></ol><h1 id="三、大规模机器学习-Large-Scale-Machine-Learning"><a href="#三、大规模机器学习-Large-Scale-Machine-Learning" class="headerlink" title="三、大规模机器学习(Large Scale Machine Learning)"></a>三、大规模机器学习(Large Scale Machine Learning)</h1><h2 id="1-随机梯度下降、Min-Batch梯度下降和在线学习"><a href="#1-随机梯度下降、Min-Batch梯度下降和在线学习" class="headerlink" title="1. 随机梯度下降、Min-Batch梯度下降和在线学习"></a>1. 随机梯度下降、Min-Batch梯度下降和在线学习</h2><p>不同于原本的批量梯度下降(Batch Gradient Descend)每次迭代需要遍历并减去每个样本的偏导数的加和，随机梯度下降(Stochastic Gradient Descend, or SGD)的步骤为：</p><ol><li>打乱数据的顺序</li><li>遍历样本，每次迭代只减去一个样本的偏导数</li><li>重复以上步骤直到模型收敛</li></ol><p>注意：随机梯度下降只能使模型在最优解周围徘徊</p><p>Min-Batch梯度下降介于Batch梯度下降和随机梯度下降之间，需要选择每轮迭代使用的样本数$b$，步骤为：</p><ol><li>遍历样本，每次迭代减去$b$个样本求偏导数的加和</li><li>重复以上步骤直到模型收敛</li></ol><p>在线学习(Online Learning)应用在有不断涌入的用户流和数据流的情况，直接对每个用户提供的数据作拟合</p><h2 id="2-优化技巧"><a href="#2-优化技巧" class="headerlink" title="2. 优化技巧"></a>2. 优化技巧</h2><ol><li>画出学习曲线，预先检查模型是否是低偏差，是否能在大数据集的情况下被优化</li><li>设定随机梯度下降的学习率$\alpha = \frac{const_1}{iterationsCounts + cosnt_2}$，在迭代次数增加时，学习率下降，模型会收敛到最优解</li><li>Map-reduce：将数据分散到多个计算机或者内核去并行处理，最后汇总到中心服务器。</li></ol><h1 id="四、图片OCR-Photo-Optical-Character-Recognition"><a href="#四、图片OCR-Photo-Optical-Character-Recognition" class="headerlink" title="四、图片OCR(Photo Optical Character Recognition)"></a>四、图片OCR(Photo Optical Character Recognition)</h1><p>从Photo OCR去看设计复杂的机器学习系统的一些理念</p><ol><li>将一个复杂的机器学习系统分解为流水线上多个机器学习模块。例如，将图片OCR分解为：文本检测、字符分割、字符识别。滑动窗口+监督学习实现文本检测，监督学习完成字符分割和字符识别</li><li>人工数据：人工合成全新的数据 或者 在已有的数据上添加噪声</li><li>上限分析(Ceiling Analysis)：人为提高某个模块的准确率，观察其对整个系统的准确率的影响，评估出最值得优化的一个模块</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 梯度下降 </tag>
            
            <tag> 异常检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习笔记——机器学习系统设计、支持向量机(SVM)、K-Means算法、主成分分析法(PCA)</title>
      <link href="/2024/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%81%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA(SVM)%E3%80%81K-Means%E7%AE%97%E6%B3%95%E3%80%81%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E6%B3%95(PCA)/"/>
      <url>/2024/01/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%81%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA(SVM)%E3%80%81K-Means%E7%AE%97%E6%B3%95%E3%80%81%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90%E6%B3%95(PCA)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这两天刷了四章视频，再来复盘一下：</p><ol><li>第十一章————机器学习系统设计</li><li>第十二章————支持向量机</li><li>第十三章————K-Means算法</li><li>第十四章————主成分分析法</li></ol><p>视频链接：<a href="https://www.bilibili.com/video/BV164411b7dx">[中英字幕]吴恩达机器学习系列课程</a></p><h1 id="一、机器学习系统设计"><a href="#一、机器学习系统设计" class="headerlink" title="一、机器学习系统设计"></a>一、机器学习系统设计</h1><ol><li>快速构建一个较为简单的模型，然后对模型进行验证，再决定下一步应该怎么优化，而不是过早地去优化。</li><li>在引入新的想法时，可对有无引入该想法地不同模型作验证，由<strong>单一指标</strong>确定引入新想法是否有效</li><li>在对偏斜类（或者 不对称类）作误差评估时，应该考虑到<strong>查准率</strong>(Percision, or P)和<strong>召回率</strong>(Recall, or R)，定义$F = 2\frac{PR}{P+R}$，通过比较$F$值选择模型保证两者处于较高的水平</li><li>在模型低偏差的情况下，增大数据集保证低方差，能有效提高模型效能。</li></ol><h1 id="二、支持向量机-Support-Vector-Machine-or-SVM"><a href="#二、支持向量机-Support-Vector-Machine-or-SVM" class="headerlink" title="二、支持向量机(Support Vector Machine, or SVM)"></a>二、支持向量机(Support Vector Machine, or SVM)</h1><h2 id="1-逻辑回归的局限性"><a href="#1-逻辑回归的局限性" class="headerlink" title="1. 逻辑回归的局限性"></a>1. 逻辑回归的局限性</h2><p>在分类问题中，当两个类别之间间隔较大时，我们能够得到许多不同的决策边界将其正确划分。但是不同的决策边界之间也有优劣性：<br>当决策边界与样本点相隔很近时，新的样本稍微有点不同就可能导致模型对其错误分类，也就是模型的<strong>泛化性</strong>不强。</p><p>因此，我们的优化目标就是找到一个最优决策边界，使得<strong>样本点到决策边界的间隔最大</strong>。</p><p><strong>为什么逻辑回归不能得到最优决策边界</strong></p><p>我们知道逻辑回归的损失函数为</p><script type="math/tex; mode=display">J(\theta) = -\frac{1}{m} \sum_{i=1}^m y_i\ln h_\theta(x^{(i)}) + (1-y_i)\ln (1-h_\theta(x^{(i)})) + \lambda \sum_{j=1}^n \theta_j^2</script><p>当模型已经能够正确分类时，前一项几乎为0，我们的的优化目标就是最小化后一项，即最小化$\lambda \sum_{j=1}^n \theta_j^2 = \lambda | \theta |^2$</p><p>在逻辑回归中，决策边界为$\theta^T x = 0$，那么$\theta = (\theta_0, \theta_1, …, \theta_n)$为决策边界的法向量。</p><blockquote><p>二维的例子就是，当$\theta = (0, A, B)$，决策边界为直线$Ax + By = 0$时，直线方向向量$l = (-B, A)$与向量$\theta$互相垂直。</p></blockquote><p>那么样本点到决策边界的间隔可表示为向量$x$在向量$\theta$上的投影的绝对值，记投影</p><script type="math/tex; mode=display">p = \| x\| cos<\theta, x></script><p>其中$cos&lt;\theta, x&gt;$为向量$\theta$和向量$x$之间夹角的cos值。</p><p>决策边界的两边分别满足，$\theta^T x \ge 0$和$\theta^T x \lt 0$，又$\theta^T x = | \theta | | x| cos&lt;\theta, x&gt;$，得到</p><p>$ | \theta |  p\ge 0$ 和 $ | \theta |  p \lt 0$</p><p>这是$p$和$|\theta|$之间的限定关系，可知$p$的变化对$|\theta|$的减少没有什么帮助，于是逻辑回归自然就不会选择$p$更大的结果，也就是不会选择最优决策边界。</p><h2 id="2-SVM的引入"><a href="#2-SVM的引入" class="headerlink" title="2. SVM的引入"></a>2. SVM的引入</h2><p>由1可知，如果改变$p$和$|\theta|$之间的限定关系为</p><p>$ | \theta |  p\ge 1$ 和 $ | \theta |  p \lt -1$</p><p>为了使$|\theta|$减小，模型就会自动地去使$p$的绝对值增大，即选择最优决策边界。</p><p>为了实现这一目标，我们需要在原先的逻辑回归上做些手脚，修改损失函数为：</p><script type="math/tex; mode=display">J(\theta) = C\sum_{i=1}^m [y^{(i)} cost_1(\theta^T x^{(i)}) + (1-y^{(i)})cost_0(\theta^T x^{(i)}] + \frac{1}{2} \sum_{j=1}^n \theta_j^2</script><p>其中，</p><p>$cost_1(\theta^T x^{(i)}) 与 -\ln h_\theta(x^{(i)})$相似，但是在自变量$z$属于$(1,+\infty)$时，$cost_1(z)$的值为0</p><p>$cost_0(\theta^T x^{(i)}) 与 -\ln (1-h_\theta(x^{(i)}))$相似，但是在自变量$z$属于$(-\infty, -1)$时，$cost_0(z)$的值为0</p><p>也就是说，当$y = 1$时，我们希望$\theta^T x^{(i)} &gt;= 1$，当$y = 0$时，我们希望$\theta^T x^{(i)} &lt; -1$</p><p>这就是SVM之所以被叫做大间隔分类器的数学原理</p><h2 id="3-核函数-Kernel-Function"><a href="#3-核函数-Kernel-Function" class="headerlink" title="3. 核函数(Kernel Function)"></a>3. 核函数(Kernel Function)</h2><p>参考文献：<a href="https://zhuanlan.zhihu.com/p/261061617">详解SVM模型——核函数是怎么回事 - 知乎 (zhihu.com)</a></p><p>在实际问题中，我们在已有的维度无法找到一个线性的边界将两个类别划分开。所以我们需要通过一个映射关系，将低维的数据映射到高维，再从高维找到一个超平面将不同类别的样本划分。</p><p>所以核函数就是为了得到非线性决策边界，<strong>实现低维到高维映射关系</strong>且<strong>不增加运算的复杂度</strong>的函数。也有译作Kernel Trick，所有核函数本质是一种运算技巧。</p><p>一个使用频率很高的核函数是高斯核：<script type="math/tex">similarity(x_i, x_j) = exp(- \frac{\|x_i - x_j\|^2}{2\sigma^2})</script></p><p>由于SVM的数学性质(未考究)，把核函数与SVM结合在一起的表现特别出色。</p><p>例如，将高斯核与SVM相结合：</p><p>定义特征$f = (f_1, f_2, …, f_m)^T$取代损失函数中的$x$，其中$f_j = similarity(x, l^{(j)})$，$l^{(j)}$为样本中的某一点，那么有</p><script type="math/tex; mode=display">J(\theta) = C\sum_{i=1}^m [y^{(i)} cost_1(\theta^T f^{(i)}) + (1-y^{(i)})cost_0(\theta^T f^{(i)}] + \frac{1}{2} \sum_{j=1}^n \theta_j^2</script><blockquote><p>呜呜写不下去了，不知道SVM是怎么求解的</p></blockquote><h1 id="三、K-Means算法"><a href="#三、K-Means算法" class="headerlink" title="三、K-Means算法"></a>三、K-Means算法</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>已知我们要将没有标签的数据分为$K$类，要怎么分才最合理？</p><p>设每个$c^{i}$为样本点$x^{(i)}$被分配到的聚类的下标<br>每个聚类中心的坐标为$\mu_k$<br>则$\mu_{c^{(i)}}$为样本点$x^{(i)}$被分配到的聚类的坐标</p><p>我们可以用<strong>样本点到其分配到的聚类中心的距离</strong>作为衡量分类合理性的标准，将问题转化为</p><p>如何最小化损失函数$J(c^{(1)}, …, c^{(m)}, \mu_1, …, \mu_K) = \frac{1}{m} \sum_{i=1}^m | x^{(i)} - \mu_{c^{(i)}}|^2$</p><p>我们也将它叫作失真代价函数(Cost Distortion)</p><h2 id="2-迭代过程"><a href="#2-迭代过程" class="headerlink" title="2. 迭代过程"></a>2. 迭代过程</h2><ol><li>修改每一个$c^{(i)}$为离x$^{(i)}$最近的聚类中心的下标，$1\le i \le m$</li><li>修改每一个$\mu_k$为聚类$k$中所有点的均值，$1\le k \le K$</li><li>重复以上两个步骤直到聚类中心不变</li></ol><h2 id="3-优化方法"><a href="#3-优化方法" class="headerlink" title="3. 优化方法"></a>3. 优化方法</h2><h3 id="3-1-随机初始化"><a href="#3-1-随机初始化" class="headerlink" title="3.1 随机初始化"></a>3.1 随机初始化</h3><p>不同的初始化结果会导致不同的聚类结果，我们可以选择其中损失函数最小的值作为最终的结果:  </p><p>进行一定次数：随机初始化聚类中心为$m$个点中的任意$k$点</p><ol><li>修改每一个$c^{(i)}$为离x$^{(i)}$最近的聚类中心的下标，$1\le i \le m$ </li><li>修改每一个$\mu_k$为聚类$k$中所有点的均值，$1\le k \le K$ </li><li>重复1、2步骤直到聚类中心不变 </li><li>计算$J(c^{(1)}, …, c^{(m)}, \mu_1, …, \mu_K) = \frac{1}{m} \sum_{i=1}^m | x^{(i)} - \mu_{c^{(i)}}|^2$</li></ol><p>从中找出$J$值最小的情况作为结果</p><h3 id="3-2-选择聚类数量"><a href="#3-2-选择聚类数量" class="headerlink" title="3.2 选择聚类数量"></a>3.2 选择聚类数量</h3><ol><li>手肘法: 画出聚类数量K与失真代价函数J的关系曲线，选择开始变平缓的第一个点</li><li>当手肘发不管用时，根据实际业务需求选择K的值</li></ol><h1 id="四、主成分分析法-Priciple-Component-Analysis-or-PCA"><a href="#四、主成分分析法-Priciple-Component-Analysis-or-PCA" class="headerlink" title="四、主成分分析法(Priciple Component Analysis, or PCA)"></a>四、主成分分析法(Priciple Component Analysis, or PCA)</h1><h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>在使用原始数据需要的内存和计算量过于庞大以至于模型工作效率低的情况下，我们考虑对高维的数据$x^{(i)}$压缩为低维$z^{(i)}$：过$x^{(i)}$作一低维的超平面，将$x^{(i)}$投影到超平面上得到对应$z^{(i)}$。</p><p>对数据压缩应该尽可能保留原来的信息，$x^{(i)}$距超平面的距离越远将丢失越多的信息。将均值点与$x^{(i)}$连线，为使$x^{(i)}$距超平面的距离减小，那么$x^{(i)}$到超平面的垂足到均值点的距离应该更大，也就是要保证投影后的数据<strong>方差</strong>更大。</p><p>于是我们的优化目标为：找到一个新的坐标系，使得在新坐标系下数据的<strong>方差最大</strong>，为了减少数据的冗余，我们希望数据在每个方向上都是不相关的，也就是<strong>协方差为零</strong>。</p><h2 id="2-数据压缩"><a href="#2-数据压缩" class="headerlink" title="2. 数据压缩"></a>2. 数据压缩</h2><h3 id="2-1-数据预处理"><a href="#2-1-数据预处理" class="headerlink" title="2.1 数据预处理"></a>2.1 数据预处理</h3><ol><li>为了方便求协方差矩阵，我们将所有数据减去其均值</li><li>由于我们是用方差度量优化结果，为了防止方差较大的特征主导度量结果，应该做特征缩放。</li></ol><h3 id="2-2-PCA算法"><a href="#2-2-PCA算法" class="headerlink" title="2.2 PCA算法"></a>2.2 PCA算法</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/7751308">【机器学习】降维——PCA（非常详细） - 知乎 (zhihu.com)</a></p><p>参考：<a href="https://www.zhihu.com/question/330814299/answer/2540307765">怎么通俗地解释svd奇异值分解以及作用？ - 石溪的回答 - 知乎</a></p><p>已知原有的数据$X$为$n \times m$维的矩阵，其协方差矩阵$C = \frac{1}{m} XX^T$<br>求压缩后的矩阵$Y=PX$，且$Y$的协方差矩阵$D$是对角矩阵(协方差为零)，且对角线的元素尽可能大(方差最大化)</p><p>则有$ D = \frac{1}{m} (PX)(PX)^T$</p><p>$ D = \frac{1}{m} PX X^T P^T $</p><p>$ D = P \frac{1}{m}  X X^T P^T = PCP^T$</p><p>又协方差矩阵$C$是对称矩阵，设$E$为$C$的特征向量组成的矩阵，$\Lambda$为以特征值为对角线的矩阵，则有</p><p>$CE = E\Lambda$</p><p>由于对称矩阵的不同特征值对应的特征向量互相正交，则有$E^T = E^{-1}$，得</p><p>$E^T CE = \Lambda $</p><p>我们发现矩阵$\Lambda$正是我们需要的$D$，而取$E^T$的前$k$列正是我们需要的变换$P$</p><p>另一种方法是对$X$求奇异值分解:$[U, S, V] = svd(X)$，其中，<br>$U$表示变换后新坐标系的标准正交向量，其前$k$列的转置正是我们需要的变换$P$，<br>奇异值矩阵$S$相当于上述矩阵$\Lambda$的开方，<br>$V$表示变换前坐标系的标准正交向量的转置</p><h2 id="3-主成分数量选择"><a href="#3-主成分数量选择" class="headerlink" title="3. 主成分数量选择"></a>3. 主成分数量选择</h2><p>主成分数量越少，丢失的信息量越多。保留的信息量可用2.2中奇异值分解得到的矩阵$S$表示：</p><script type="math/tex; mode=display">\frac{\sum_{j=1}^k S_{j, j}} {\sum_{i=1}^n S_{i, i}}</script><p>可人为要求该值大于一定比例，如0.99，0.95等，确保数据压缩能保留足够多的信息</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> SVM </tag>
            
            <tag> PCA </tag>
            
            <tag> K-Means </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文讲清楚机器学习中的正则化、神经网络、机器学习诊断法</title>
      <link href="/2024/01/14/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85%E6%A5%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%E3%80%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%8A%E6%96%AD%E6%B3%95/"/>
      <url>/2024/01/14/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85%E6%A5%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%E3%80%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%8A%E6%96%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>学习吴恩达机器学习视频的第二篇笔记，内容包括：</p><ol><li>第七章————正则化</li><li>第八、九章————神经网络</li><li>第十章————机器学习诊断法</li></ol><p>个人博客页：<a href="https://andreww1219.github.io/2024/01/14/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85%E6%A5%9A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%96%E3%80%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E3%80%81%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%8A%E6%96%AD%E6%B3%95/">一文讲清楚机器学习中的正则化、神经网络、机器学习诊断法 | Andrew的个人博客 (andreww1219.github.io)</a></p><h1 id="一、正则化"><a href="#一、正则化" class="headerlink" title="一、正则化"></a>一、正则化</h1><h2 id="1-应用背景"><a href="#1-应用背景" class="headerlink" title="1. 应用背景"></a>1. 应用背景</h2><p>在前面对线性回归、逻辑回归的学习中，我们都是构造一个假设$h_\theta(x)$，然后得到他的损失函数$J(\theta)$，对其进行梯度下降操作使损失函数的值尽可能小。总而言之，就是对我们的训练集作出最好的拟合。</p><p>然而，当我们增加特征的维度，完美地去拟合我们的训练集时，会得到一条相当扭曲，不具有泛化性地曲线，这就是过拟合的问题。解决过拟合问题主要有以下两个手段：</p><ol><li>减少特征的数量$n$</li><li>采用正则化（也就是我们今天要介绍的内容）</li></ol><h2 id="2-什么是正则化？"><a href="#2-什么是正则化？" class="headerlink" title="2. 什么是正则化？"></a>2. 什么是正则化？</h2><p>我们采集了许多特征，并且相信这些特征对假设的预测值是有用的，并不想去舍弃它，又担心过拟合的问题。所以我们尽可能减小每个特征或某个特征对整体预测值的影响，在损失函数中增加<strong>对高特征值的惩罚</strong>，这就是正则化的思想。</p><h2 id="3-线性回归中的正则化"><a href="#3-线性回归中的正则化" class="headerlink" title="3. 线性回归中的正则化"></a>3. 线性回归中的正则化</h2><h3 id="3-1-梯度下降中的正则化"><a href="#3-1-梯度下降中的正则化" class="headerlink" title="3.1 梯度下降中的正则化"></a>3.1 梯度下降中的正则化</h3><p>由2可知，我们要在损失函数$J(\theta)$增加对高特征值的惩罚，得到：</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{2m} [ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})^2 + \lambda \sum_{j=1}^n \theta_j^2]</script><p>得到 <script type="math/tex">\frac{\partial J(\theta) }{\partial \theta_j}= \frac{1}{m} [ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} + \lambda \theta_j]</script></p><p>那么有：  </p><script type="math/tex; mode=display">\begin{cases}\theta_0 = \theta_0 - \frac{\alpha}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) \\\theta_j = \theta_j - \frac{\alpha}{m} [ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} + \lambda \theta_j] = \theta_j(1 - \frac{\alpha\lambda}{m}) - \frac{\alpha}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)}\end{cases}</script><h3 id="3-2-正规方程中的正则化"><a href="#3-2-正规方程中的正则化" class="headerlink" title="3.2 正规方程中的正则化"></a>3.2 正规方程中的正则化</h3><p>将损失函数表示为矩阵形式，可得：</p><p>$J(\theta) = \frac{1}{2m} [(X\theta - Y)^T(X\theta - Y) + \lambda \theta^T \theta]$</p><p>得到 <script type="math/tex">\frac{\partial J(\theta) }{\partial \theta}= \frac{1}{m} [X^TX\theta - X^TY + \lambda \theta]</script></p><p>令  <script type="math/tex">\frac{\partial J(\theta) }{\partial \theta} = 0</script>，得</p><script type="math/tex; mode=display">\theta = (X^TX - \lambda E)X^TY</script><p>由于约定俗成的规则，$\theta_0$不参与正则化（实际参与得到的结果也差别不大），所以将上述式子中$E_{i,j}$的位置修改为0，就是正规方程带正则化的表达式。</p><h2 id="4-逻辑回归中的正则化"><a href="#4-逻辑回归中的正则化" class="headerlink" title="4. 逻辑回归中的正则化"></a>4. 逻辑回归中的正则化</h2><p>同线性回归中的梯度下降，我们可以得到相同的结果即：</p><script type="math/tex; mode=display">\begin{cases}\theta_0 = \theta_0 - \frac{\alpha}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)})\\\theta_j = \theta_j - \frac{\alpha}{m} [ \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)} + \lambda \theta_j] = \theta_j(1 - \frac{\alpha\lambda}{m}) - \frac{\alpha}{m} \sum_{i=1}^m (h_\theta(x^{(i)}) - y^{(i)}) x_j^{(i)}\end{cases}</script><h1 id="二、神经网络"><a href="#二、神经网络" class="headerlink" title="二、神经网络"></a>二、神经网络</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>输入层(Input Layer)：已知m组数据$x^{(1)}, x^{(2)}, …, x^{(m)}$，每组数据表示n个特征,可写为一个n+1维的向量<br>即：<script type="math/tex">(x^{(i)})^T = (x^{(i)}_0, x^{(i)}_1, ..., x^{(i)}_n)</script>，其中，$x^{(i)}_0=1$。</p><p>隐层(Hidden Layer)：介于输入层和输出层之间，每个隐层的每个结点接收上一个隐层（或输入层）的信号，经过一定处理后得到新的信号并传递给下一个隐层（或输出层）</p><p>输出层(Output Layer)：接受最后一个隐层的信号，经过加权处理后输出$y^{(i)}$。在多元分类问题中，向量$y^{(i)}$的维度就是所需要区分的类别的数量。</p><h2 id="2-前向传播-Forward-Propagation"><a href="#2-前向传播-Forward-Propagation" class="headerlink" title="2. 前向传播(Forward Propagation)"></a>2. 前向传播(Forward Propagation)</h2><p>我们用$z_i^{(j)}$表示第$j$层的第$i$个结点接收到的前一层的值加权后的总和，$a_i^{(j)}$表示第$j$层的第$i$个结点的输出，矩阵$\Theta^{(j)}$表示从第$j$层到第$j+1$层的权值，行数为$j+1$层的节点数，列数为$j$层的节点数+1（存在常数固定层，可看作激活阈值），即</p><p>$z_i^{(j+1)} = \sum_{k=0}^{第j层的结点数} \Theta_{i, k}^{(j)} a_k^j$</p><p>$a_i^{(j+1)} = g(z_i^{(j+1)})$</p><p>写成矩阵形式，则有 $ a^{(j+1)} = g( \Theta^{(j)} a^{(j)} )$</p><p>于是我们可以写出神经网络的假设$h_\theta(x^{(i)}) = g( \Theta^{(L-1)} a^{(L-1)} ))$，其中$L$为神经网络的层数。</p><h2 id="3-反向传播-Back-Propagation"><a href="#3-反向传播-Back-Propagation" class="headerlink" title="3. 反向传播(Back Propagation)"></a>3. 反向传播(Back Propagation)</h2><h3 id="3-1-定义损失函数"><a href="#3-1-定义损失函数" class="headerlink" title="3.1 定义损失函数"></a>3.1 定义损失函数</h3><p>有了假设，我们想要优化现有的模型，就需要对原有参数进行梯度下降，需要定义损失函数$J(\Theta)$，并对每一个参数即$\Theta_{i, k}^{(j)}$求偏导数$ \frac{\partial J(\Theta)}{\partial \Theta_{i, k}^{(j)}} $</p><p>于是我们有预测值$h_\theta(x) = a^{(L)}$，真实值$y$，第$j$层的节点数为$s_j$，则有</p><p>每个样本的均方误差 $E = \frac{1}{2} \sum_{i=1}^{s_L} (a_i^{(L)} - y_i)^2$</p><p>损失函数$J(\Theta) = \frac{1}{m} \sum_{i=1}^m E^{(i)} $</p><p>损失函数对参数的偏导数$\frac{\partial J(\Theta)}{\partial \Theta^{(j)}} = \frac{1}{m} \sum_{i=1}^m \frac{\partial  E^{(i)}}{\partial \Theta^{(j)}} $</p><h3 id="3-2-引入链式求导法"><a href="#3-2-引入链式求导法" class="headerlink" title="3.2 引入链式求导法"></a>3.2 引入链式求导法</h3><p>我们想要直接求$E$对$\Theta_{i, k}^{(j)}$的偏导数不太容易，因为我们的预测值是前面一步一步传递过来的，离输出层越远，$E$和$\Theta_{i, k}^{(j)}$的关系就越复杂。但是其中项之间的关系简单，偏导数易求，所以我们可以通过链式求导法则，由中间项之间的偏导数累乘得到$E$对$\Theta_{i, k}^{(j)}$的偏导数。</p><p>对输出层的参数，则有$ \frac{\partial E}{\partial \Theta_{i, k}^{(L-1)}}  =<br>\frac{\partial E}{\partial a_i^{(L)}}<br>\frac{\partial a_i^{(L)}}{\partial z_i^{(L)}}<br>\frac{\partial z_i^{(L)}}{\partial \Theta_{i, k}^{(L-1)}}$</p><p>其中，$\frac{\partial E}{\partial a_i^{(L)}} = a_i^{(L)} - y_i,<br>\frac{\partial a_i^{(L)}}{\partial z_i^{(L)}} = g’(z_i^{(L)}) = a_i^{(L)}(1 - a_i^{(L)}),<br>\frac{\partial z_i^{(L)}}{\partial \Theta_{i, k}^{(L-1)}} =a_k^{(L-1)} $</p><p>得$ \frac{\partial E}{\partial \Theta_{i, k}^{(L-1)}}  =<br>(a_i^{(L)} - y_i) a_i^{(L)}(1 - a_i^{(L)}) a_k^{(L-1)}$</p><p>我们将$\frac{\partial E}{\partial z_i^{(L)}} =<br>\frac{\partial E}{\partial a_i^{(L)}}<br>\frac{\partial a_i^{(L)}}{\partial z_i^{(L)}}  =<br>(a_i^{(L)} - y_i) a_i^{(L)}(1 - a_i^{(L)})$ 记作输出层的误差(error)为$\delta_i^{(L)}$，即</p><p>$\delta^{(L)} = (a^{(L)} - y) .* g’(z^{(L)})$</p><p><strong>(存疑，视频中取的$\delta^{(L)} = a^{(L)} - y$)</strong></p><p>于是我们用$\delta^{(l)}$表示<strong>均方误差$E$对第$l$层$z$的偏导</strong></p><h3 id="3-3-矩阵形式"><a href="#3-3-矩阵形式" class="headerlink" title="3.3 矩阵形式"></a>3.3 矩阵形式</h3><p>矩阵/向量/标量之间求导参考：<a href="https://zhuanlan.zhihu.com/p/262751195?utm_id=0">机器学习中的数学理论1：三步搞定矩阵求导</a></p><p>我们希望得到$E$对结果层参数$\Theta^{(L-1)}$的偏导数，即标量对矩阵的求导，使用<strong>分母布局</strong>，得到与$\Theta^{(L-1)}$相同维度的矩阵，方便减法运算作梯度下降。</p><p>由链式求导法则，有</p><p>$ \frac{\partial E}{\partial \Theta^{(L-1)}}  =<br>\frac{\partial E}{\partial z^{(L)}}<br>\frac{\partial z^{(L)}}{\partial \Theta^{(L-1)}}$</p><p>由于$\frac{\partial E}{\partial z^{(L)}} = \delta^{(L)}$，</p><p>又$z^{(L)} = \Theta^{(L-1)} a^{(L-1)}$，则有$ \frac{\partial z^{(L)}}{\partial \Theta^{(L-1)}} =<br>\frac{\partial \Theta^{(L-1)} \alpha^{(L-1)}}{\partial \Theta^{(L-1)}} = (\alpha^{(L-1)})^T<br>$（使用分母布局）</p><p>综上所述，$ \frac{\partial E}{\partial \Theta^{(L-1)}}  = \delta^{(L)} (\alpha^{(L-1)})^T$</p><p>记均方误差$E$对$\Theta^{(j)}$的偏导为$\Delta^{(j)}$，则有$ \Delta^{(L-1)} = \delta^{(L)} (\alpha^{(L-1)})^T$</p><h3 id="3-4-推导递推公式"><a href="#3-4-推导递推公式" class="headerlink" title="3.4 推导递推公式"></a>3.4 推导递推公式</h3><p>已知$\delta^{(l-1)} =<br>\frac{\partial E}{\partial z^{(l-1)}}$，那么</p><p>$\delta^{(l-1)} =<br>\frac{\partial E}{\partial z^{(l)}}<br>\frac{\partial z^{(l)}}{\partial z^{(l-1)}} =<br>\delta^{(l)}<br>\frac{\partial z^{(l)}}{\partial a^{(l-1)}}<br>\frac{\partial a^{(l-1)}}{\partial z^{(l-1)}} =<br>(\Theta^{(l-1)})^T \delta^{(l)} .* g’(z^{(l-1)})<br>$</p><p>即$\delta^{(l-1)} =<br>(\Theta^{(l-1)})^T \delta^{(l)} .* g’(z^{(l-1)})<br>$ ，这就是误差反向传导的递推公式</p><p>又$\frac{\partial z^{(l-1)}}{\partial \Theta^{(l-1)}} =<br>(a^{(l-1)})^T<br>$<br>同理</p><p>$\Delta^{(l-1)} = \frac{\partial E}{\partial \Theta^{(l-1)}}  = \delta^{(l)} (a^{(l-1)})^T$</p><h3 id="3-5-小结"><a href="#3-5-小结" class="headerlink" title="3.5 小结"></a>3.5 小结</h3><p>记损失函数对$\Theta^{(l)}$的偏导数为$D^{(l)} = \frac{\partial J(\Theta)}{\partial \Theta^{(l)}}$，则有</p><p>$D_{i, j}^{(l)} = \frac{1}{m} \sum^m \Delta_{i, j}^{(l)} =<br>\frac{1}{m} \sum^m \delta_i^{(l)} a_j^{(l-1)}$</p><p>若引入正则化项，则有</p><p>$D_{i, j}^{(l)} = \frac{1}{m} \sum^m \Delta_{i, j}^{(l)} =<br>\frac{1}{m} \sum^m \delta_i^{(l)} a_j^{(l-1)} + \lambda \Theta_{i, j}^{(l)}$</p><h1 id="三、机器学习诊断法"><a href="#三、机器学习诊断法" class="headerlink" title="三、机器学习诊断法"></a>三、机器学习诊断法</h1><h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>我们需要评估我们训练出来的模型，判断是否过拟合，即高方差(variance)，还是欠拟合，即高偏差(bias)。通常情况下，我们有许多方式去改进模型，但是不知道应该选哪一种。我们将讨论各个参数与偏差、方差的关系，帮助我们确定模型是处于高方差还是高偏差，应该怎样采取调整策略。</p><h2 id="2-讨论变量"><a href="#2-讨论变量" class="headerlink" title="2.讨论变量"></a>2.讨论变量</h2><p>我们将遵循同一分布的数据集划分为训练集和验证集，训练集用来训练得到某一变量在不同值下的模型，由验证集对该变量进行选择。</p><p>记训练集误差为$J_{train}(\theta)$，验证集误差为$J_{cv}(\theta)$</p><p>我们选择测试集误差最小的模型作为结果</p><p>但是，要如何验证我们模型的泛化能力？即模型对不同但具有相似分布的数据集(测试集)的表现。</p><p>所以我们一开始将数据集划分为训练集、验证集和测试集，由验证集对变量进行选择，由测试集对模型的泛化能力进行评估，<strong>不能将测试集用于调整参数，否则会导致过拟合</strong></p><h3 id="2-1-特征数-d"><a href="#2-1-特征数-d" class="headerlink" title="2.1 特征数$d$"></a>2.1 特征数$d$</h3><p>我们记参数的多项式次数（相当于特征数）为d</p><p>当特征数过少时，训练集误差$J_{train}(\theta)$和验证集误差$J_{cv}(\theta)$都很大，模型欠拟合；<br>当特征数过多时，训练集误差$J_{train}(\theta)$很小，而验证集误差$J_{cv}(\theta)$较大，模型过拟合</p><h3 id="2-2-正则化参数-lambda"><a href="#2-2-正则化参数-lambda" class="headerlink" title="2.2 正则化参数$\lambda$"></a>2.2 正则化参数$\lambda$</h3><p>当$\lambda$很小时，训练集误差$J_{train}(\theta)$很小，而验证集误差$J_{cv}(\theta)$较大，模型过拟合;<br>当$\lambda$很大时，训练集误差$J_{train}(\theta)$和验证集误差$J_{cv}(\theta)$都很大，模型欠拟合</p><h3 id="2-3-数据集规模-m"><a href="#2-3-数据集规模-m" class="headerlink" title="2.3 数据集规模$m$"></a>2.3 数据集规模$m$</h3><p>我们将数据集规模$m$与误差关系的曲线叫做学习曲线</p><p>在高偏差即欠拟合的情况下，随着数据集规模$m$的增大，训练集误差将非常接近于验证集误差<br>在高方差即过拟合的情况下，随着数据集规模$m$的增大，验证集误差能有效减小，说明在过拟合情况下，增大数据规模是有效的</p><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h2><p>当模型高方差时，我们可以选择：</p><ol><li>增大数据集规模</li><li>减小特征数$d$</li><li>增大正则化参数$\lambda$</li></ol><p>当模型高偏差时，我们可以选择：</p><ol><li>增加特征数$d$</li><li>减小正则化参数$\lambda$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
            <tag> 逻辑回归 </tag>
            
            <tag> BP神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文讲清楚线性回归(Linear Regression)、逻辑回归（Logistic Regression）</title>
      <link href="/2024/01/11/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85%E6%A5%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92(Linear%20Regression)%E3%80%81%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%EF%BC%88Logistic%20Regression%EF%BC%89/"/>
      <url>/2024/01/11/%E4%B8%80%E6%96%87%E8%AE%B2%E6%B8%85%E6%A5%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92(Linear%20Regression)%E3%80%81%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%EF%BC%88Logistic%20Regression%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>被各种ddl加上期末考试耽搁了一段时间，准备继续肝机器学习了，对前面学的东西做个阶段性总结。<br>刷的是吴恩达的课：<a href="https://www.bilibili.com/video/BV164411b7dxZ0">[中英字幕]吴恩达机器学习系列课程</a></p><h1 id="一、线性回归-Linear-Regression"><a href="#一、线性回归-Linear-Regression" class="headerlink" title="一、线性回归(Linear Regression)"></a>一、线性回归(Linear Regression)</h1><h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>已知m组数据$x^{(1)}, x^{(2)}, …, x^{(m)}$，每组数据表示n个特征,可写为一个n+1维的向量<br>即：<script type="math/tex">(x^{(i)})^T = (x^{(i)}_0, x^{(i)}_1, ..., x^{(i)}_n)</script>，其中，$x^{(i)}_0=1$<br>每组数据对应一个真实值$y^{(i)}$，所有$y$值在一块可表示为一个m维向量$y$<br>我们需要构造一个预测值：$\widehat{y}=\theta_0+\theta_1x_1+…+\theta_nx_n$<br>该函数叫做我们的hypothesis(假设)，记为$h_\theta(x)$，<br>那么有$h_\theta(x)=\theta^Tx$，其中$\theta^T$和$x$都为n+1维的向量，我们要求解的就是<strong>使预测值最准确的$\theta$值</strong></p><h2 id="2-梯度下降-Gradient-Descend"><a href="#2-梯度下降-Gradient-Descend" class="headerlink" title="2. 梯度下降(Gradient Descend)"></a>2. 梯度下降(Gradient Descend)</h2><p>那么要怎么表示我们的预测和真实值的误差呢？我们引入cost function(代价函数 或 <strong>损失函数</strong>)，记为$J(\theta)$，在线性回归中，我们通常使用平方误差作为损失函数，即：</p><script type="math/tex; mode=display">J(\theta) = \frac{1}{2m}\sum_{i=1}^m (h_\theta(x^{(i)})-y)^2</script><p>现在我们要做的，就是找到一个$\theta$值，使得损失函数的值最小，最直接的方法就是求导找极值点，故有：<br>$\frac{\partial J(\theta)}{\partial\theta} = \frac{1}{m}\sum_{i=1}^m (h_\theta(x^{(i)})-y)x^{(i)}$，前面取$x^{(i)}_0=1$是为了使这里的偏导都符合同一形式。</p><p>在这里，当$\frac{\partial J(\theta)}{\partial\theta}&gt;0$时，我们的损失函数会随着$\theta$的增大而增大，当$\frac{\partial J(\theta)}{\partial\theta}&lt;0$时，我们的们的损失函数会随着$\theta$的增大而减小。</p><p>故只要将$\theta$减去偏导数的一定倍数（我们称之为<strong>学习率$\alpha$</strong>），就可保证我们的$\theta$更优。之后重复这一过程，直到$\theta$收敛到一定区间，说明我们的$\theta$达到局部最优，这就是梯度下降法。</p><p><strong>需要注意的是</strong>：$\theta$会达到全局最优的条件是：我们的损失函数$J(\theta)$是<strong>凹函数</strong>，即$\frac{\partial^2 J(\theta)}{\partial\theta^2}&gt;0$。在使用平方误差作为我们的预测值时，能保证这一条件，故可使用梯度下降。</p><p>梯度下降中$\theta$的迭代公式为: $\theta_j = \theta_j - \alpha\frac{\partial J(\theta)}{\partial\theta}, j = 1, 2, …, n$<br>使用平方误差时: $\theta_j = \theta_j - \alpha\frac{1}{m}\sum_{i=1}^m (h_\theta(x^{(i)})-y)x_j^{(i)}$</p><h3 id="2-1-特征缩放-Feature-Scaling"><a href="#2-1-特征缩放-Feature-Scaling" class="headerlink" title="2.1 特征缩放(Feature Scaling)"></a>2.1 特征缩放(Feature Scaling)</h3><p>每组数据$x$包含m个维度，每个维度的数据范围不尽相同，例如$-200&lt;x_1&lt;400$，而$-3&lt;x_2&lt;3$，对他们的预测值求平方误差后，对$\theta_j$的影响幅度不同，这导致了$\theta$之间形成的等高线会相当陡峭，拟合的过程相对曲折。</p><p>所以，我们最好将每个维度的数据都放缩到接近$-1&lt;x_j&lt;1$的范围，下面有个示例：<br>已知：$-200&lt;x_1&lt;400$，取$x_1 = \frac{x_1 - 100}{600} (100 = \frac{-200+400}{2}, 600 = 400-(-200))$，得到新的$-0.5&lt;x_1&lt;0.5$</p><h3 id="2-2-学习率-Learning-Rate"><a href="#2-2-学习率-Learning-Rate" class="headerlink" title="2.2 学习率(Learning Rate)"></a>2.2 学习率(Learning Rate)</h3><p>选择学习率是一件需要技巧的事情，过低的学习率会使$\theta$收敛较慢，过高的学习率可能会使$\theta$无法准确收敛，甚至出现发散。</p><p>吴恩达的视频里只是讨论了学习率过高和学习率过低的影响，我就在想既然$\theta$是在计算中一步一步迭代的，那有没有方法也能对$\alpha$进行迭代。网上果然能搜到许多方案，后面再深入了解一下吧。<br><a href="https://zhuanlan.zhihu.com/p/390261440">可能是深度学习中最重要的超参数：学习率 - 知乎 (zhihu.com)</a></p><h2 id="3-正规方程-Normal-Equation"><a href="#3-正规方程-Normal-Equation" class="headerlink" title="3. 正规方程(Normal Equation)"></a>3. 正规方程(Normal Equation)</h2><p>将m组数据表示为$m*(n+1)$维的矩阵，记为$X$，每组数据对应的真实值表示为一个m维向量$y$<br>则我们所需要的最优的$\theta=(X^T X)^{-1}X^Ty$<br>视频中没有给出证明，根据<a href="https://zhuanlan.zhihu.com/p/60719445">详解正规方程（Normal Equation） - 知乎 (zhihu.com)</a>，先用矩阵形式表示损失函数即$Cost(\theta) = \frac{1}{2m} (X\theta - Y)^T(X\theta - Y)$,对其求偏导，经过很多多多步化简，得到$\Delta = \frac{\partial Cost(\theta)}{\partial \theta} = \frac{1}{m}(X^T X\theta - X^TY)$ 令$\Delta = 0$，得到正规方程$\theta=(X^T X)^{-1}X^Ty$</p><h2 id="4-梯度下降和正规方程的比较"><a href="#4-梯度下降和正规方程的比较" class="headerlink" title="4. 梯度下降和正规方程的比较"></a>4. 梯度下降和正规方程的比较</h2><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><ol><li>需要选择学习率</li><li>需要多步迭代，且每一步迭代都需要对每个维度的偏导数进行计算</li><li>在$n$较大，即数据维度很大时表现很好</li></ol><h3 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h3><ol><li>不需要选择学习率，不需要迭代，一步算出答案</li><li>矩阵的逆的计算复杂度很高，在$n$较大，即数据维度很大时表现不好</li></ol><h1 id="二、逻辑回归-Logistic-Regression"><a href="#二、逻辑回归-Logistic-Regression" class="headerlink" title="二、逻辑回归(Logistic Regression)"></a>二、逻辑回归(Logistic Regression)</h1><h2 id="1-问题描述-1"><a href="#1-问题描述-1" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>已知m组数据$x^{(1)}, x^{(2)}, …, x^{(m)}$，每组数据表示n个特征,可写为一个n+1维的向量<br>即：<script type="math/tex">(x^{(i)})^T = (x^{(i)}_0, x^{(i)}_1, ..., x^{(i)}_n)</script>，其中，$x^{(i)}_0=1$<br>且每组数据的真实值$y^{(i)}$只能为0或1<br>现在我们需要构造一个预测值$h_\theta(x)$，同时求解使预测值最准确的$\theta$值</p><h2 id="2-Sigmoid函数的引入"><a href="#2-Sigmoid函数的引入" class="headerlink" title="2. Sigmoid函数的引入"></a>2. Sigmoid函数的引入</h2><p>更加自然的引入请见：<a href="https://andreww1219.github.io/2024/01/20/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E6%A6%82%E7%8E%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B/">机器学习笔记——概率生成模型 | Andrew的个人博客 (andreww1219.github.io)</a></p><p>————————分割线——————————</p><p>以下是未了解概率生成模型时的解释</p><p>前面说到的线性回归，是对$x$的每一个维度$x_j$引入一个权值$\theta_j$，简单来说就是，通过$\theta$作用于$x$中每个维度的信息，得到预测值，而我们想要的预测值范围可以是实数域上任意的数，所以就直接用$\theta^Tx$作为预测值。</p><p>而现在，真实值是离散的，只能为0或1，使用$h_\theta(x)=\theta^Tx$可能会得到$\infty$这样的结果。我们需要的是一个关于$\theta^Tx$的函数，即$h_\theta(x)=g(\theta^Tx)$，且函数$g(z)$是能够表示离散值取值的函数</p><p>因此引入sigmoid函数$g(z)=\frac{1}{1+e^{-z}}$，这个函数有很好的性质如$0&lt;g(z)=\frac{1}{1+e^{-z}}&lt;1$，可以用它来表示某一事件的概率。我们将$z$替换为$h_\theta(x)=\theta^Tx$，可得$h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}$，表示在给定$\theta$的情况下，数据$x$使y值得到1的概率。</p><h2 id="3-用概率论引出损失函数"><a href="#3-用概率论引出损失函数" class="headerlink" title="3. 用概率论引出损失函数"></a>3. 用概率论引出损失函数</h2><p>参考文献：<a href="https://blog.csdn.net/github_39421713/article/details/89213747">伯努利分布的最大似然估计_伯努利分布的似然函数-CSDN博客</a></p><p>上文中我们定义了$h_\theta(x)$为y值等于1的概率，我们将其记为$p$<br>在伯努利分布中：$P(Y=0) = 1 - p， P(Y=1) = p$<br>由于Y只能取0和1，我们可以将其概率分布用一个式子表示：$P(Y=y) = p^y(1-p)^{(1-y)}$</p><p>我们记$f(y_i |p)=P(Y=y_i)$表示给定p下，我们取到真实值的概率，及预测的准确率<br>我们将取到所有真实值的概率累乘，得到关于p的似然函数$L(p) = \prod_{i=1}^m{f(y_i|p)}$<br>那么当似然函数$L(p)$即$L(h_\theta(x)$的取值越大时，我们的预测越准确，<br>反之，$-L(p)$即$-L(h_\theta(x))$的取值越大时，我们的预测越不准确，是的你没听错，这个函数反映了我们预测的误差，这正是我们要找的损失函数……的雏形。<br>先别着急，我们想要的损失函数应该方便求导之后做梯度下降，而似然函数是许多$p$的指数形式连乘，不方便求导，于是对两边取对数<br>则有$-\ln L(p) = -\sum_{i=1}^m y_i\ln p+(1-y_i)\ln (1-p)$<br>即$-\ln L(h_\theta(x)) = -\sum_{i=1}^m y_i\ln h_\theta(x^{(i)}) + (1-y_i)\ln (1-h_\theta(x^{(i)}))$<br>两边再除以$m$取个平均值，得到损失函数得表达式如下：</p><p>$J(\theta) = -\frac{1}{m} \sum_{i=1}^m y_i\ln h_\theta(x^{(i)}) + (1-y_i)\ln (1-h_\theta(x^{(i)}))$</p><p>之后就是进入梯度下降的步骤了</p><p>$\theta_j = \theta_j - \alpha\frac{\partial J(\theta)}{\partial\theta}, j = 1, 2, …, n$</p><p><strong>为什么我们费了这么大劲就是为了找这个损失函数，用平方误差不好吗？</strong><br>还记得我们前面说的吗？：<br>$\theta$会达到全局最优的条件是：我们的损失函数$J(\theta)$是凹函数<br>之前我们的预测值$h_\theta(x) = \theta^Tx$时，平方误差确实是凹函数，而我们现在的预测值改成了Sigmoid函数，即$h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}}$，平方误差就不再是凹函数了，这点是是很致命的。</p><p><strong>那为什么我们现在的损失函数就是凹函数呢</strong><br>这点可以通过求$\frac{\partial^2 J(\theta)}{\partial\theta^2}&gt;0$去证明<br>可以参考：<a href="https://blog.csdn.net/lafengxiaoyu/article/details/109916750">为什么不用平方误差（MSE）作为Logistic回归的损失函数？_平方误差成本函数不适用于逻辑回归-CSDN博客</a></p><p>最终得到逻辑回归中梯度下降的表达式：<br>$\theta_j = \theta_j - \alpha\sum_{i=1}^m (h_\theta(x^{(i)})-y)x_j^{(i)}$<br>我们惊奇地发现！！它长得居然跟原来线性回归的梯度下降一样<br>不过特别要注意，这里的$h_\theta(x^{(i)})$跟线性回归有本质上的区别</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
            <tag> 逻辑回归 </tag>
            
            <tag> 梯度下降 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DS图-最小生成树</title>
      <link href="/2024/01/05/DS%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2024/01/05/DS%E5%9B%BE-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>复习数据结构打OJ顺便梳理一下Prim和Kruskal求最小生成树的思路</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据输入创建无向网。分别用Prim算法和Kruskal算法构建最小生成树。（假设：输入数据的最小生成树唯一。）</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>顶点数n\<br>n个顶点\<br>边数m\<br>m条边信息,格式为：顶点1顶点2权值\<br>Prim算法的起点v</p><blockquote><p>6\<br>v1 v2 v3 v4 v5 v6 \<br>10\<br>v1 v2 6\<br>v1 v3 1\<br>v1 v4 5\<br>v2 v3 5\<br>v2 v5 3\<br>v3 v4 5\<br>v3 v5 6\<br>v3 v6 4\<br>v4 v6 2\<br>v5 v6 6\<br>v1</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>输出最小生成树的权值之和\<br>对两种算法，按树的生长顺序，输出边信息(Kruskal中边顶点按数组序号升序输出)<br>15\<br>prim:\<br>v1 v3 1\<br>v3 v6 4\<br>v6 v4 2\<br>v3 v2 5\<br>v2 v5 3\<br>kruskal:\<br>v1 v3 1\<br>v4 v6 2\<br>v2 v5 3\<br>v3 v6 4\<br>v2 v3 5</p></blockquote><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><ol><li>维护一个数组dis，表示节点到最小生成树直接距离（有相邻节点在最小生成树中，否则为正无穷，初始为正无穷），已放到最小生成树中则为0。<blockquote><p>当有相邻节点被放入最小生成树中，且与该节点直接距离小于原本dis数组中保存的值时，更新dis中的值</p></blockquote></li><li>维护一个数组parent，表示节点与最小生成树相连时，直接连接的另一节点<blockquote><p>无需初始化，当dis更新时同步更新parent</p></blockquote></li><li>从起点开始，初始化各点的dis值为各点到起点的直接距离（如有），同时更新parent值也为起点，将起点放入最小生成树（dis值设为0）。</li><li>进入循环，每次取出dis值最小且非0的节点，将该节点与其父节点相连的边纳入最小生成树，并更新相邻节点的dis值和parent值。当最小生成树的边为节点数-1时退出循环<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Edge* <span class="title">Prim</span><span class="params">(<span class="type">const</span> string&amp; start)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> startIndex = <span class="built_in">strToIndex</span>(start);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        dis[i] = INF;</span><br><span class="line">    dis[startIndex] = <span class="number">0</span>;                    <span class="comment">//将起点放入最小生成树（dis值设为0）。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mat[i][startIndex])&#123;</span><br><span class="line">            dis[i] = mat[i][startIndex];    <span class="comment">//初始化各点的dis值为各点到起点的直接距离（如有）</span></span><br><span class="line">            parent[i] = startIndex;         <span class="comment">//同时更新parent值也为起点，</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Edge *mst = <span class="keyword">new</span> Edge[n<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt != n<span class="number">-1</span>)&#123;<span class="comment">//当最小生成树的边为节点数-1时退出循环</span></span><br><span class="line">        <span class="comment">//每次取出dis值最小且非0的节点</span></span><br><span class="line">        <span class="type">int</span> minIndex, min = INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[i] &amp;&amp; dis[i] &lt; min)</span><br><span class="line">                minIndex = i, min = dis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将该节点与其父节点相连的边纳入最小生成树</span></span><br><span class="line">        mst[cnt++] = <span class="built_in">Edge</span>(parent[minIndex], minIndex, min);</span><br><span class="line">        dis[minIndex] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//更新相邻节点的dis值和parent值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mat[i][minIndex] &amp;&amp; mat[i][minIndex] &lt; dis[i])&#123;</span><br><span class="line">                dis[i] = mat[i][minIndex];</span><br><span class="line">                parent[i] = minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruscal"><a href="#Kruscal" class="headerlink" title="Kruscal"></a>Kruscal</h3></li><li>维护一个优先队列pq，在初始化边的时候将每一条边放入优先队列，边的权值越小越靠前。</li><li>维护一个并查集set，当有边被纳入最小生成树时，将该边两点作并操作。一条边的两个点在同一集合中时,说明再将该边纳入最小生成树会使树成环，故丢弃该边。</li><li>进入循环，每次循环取出pq的队头（未纳入最小生成树的最短的一条边），判断该边是否合法（是否会使最小生成树成环），合法则将其纳入最小生成树，否则丢弃。当最小生成树的边为节点数-1时退出循环<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Set</span>&#123;</span><br><span class="line">    <span class="type">int</span> *parent;</span><br><span class="line">    <span class="built_in">Set</span>(<span class="type">int</span> range)&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="type">int</span>[range];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;range;++i)</span><br><span class="line">            parent[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">join</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        parent[a] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">root</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[a] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">root</span>(parent[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_same</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">root</span>(a) == <span class="built_in">root</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Kruskal</span></span><br><span class="line"><span class="function">Edge *<span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Edge *mst = <span class="keyword">new</span> Edge[n<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>() &amp;&amp; cnt != n<span class="number">-1</span>)&#123;</span><br><span class="line">        Edge temp = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!set-&gt;<span class="built_in">is_same</span>(temp.index1, temp.index2))&#123;</span><br><span class="line">            mst[cnt++] = temp;</span><br><span class="line">            set-&gt;<span class="built_in">join</span>(temp.index1, temp.index2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="处理输入输出"><a href="#处理输入输出" class="headerlink" title="处理输入输出"></a>处理输入输出</h3><ol><li>节点：string类型数组nodes保存所有节点，下标表示节点的id，方便用二维数组表示节点间的权值</li><li>最小生成树：自定义Edge类型表示一条边，成员变量int index1, index2, val 分别表示边的两个端点下标及边的权重。最小生成树为Edge类型的数组，即一组边。</li><li>int类型二维数组mat(matrix)保存保存节点间的权值(Prim中用于更新dis数组)\<br>Edge类型数组保存输入的每一条边，在初始化时push到优先队列中(Kruskal中用于贪心)<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3F3F3F3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 10000</span></span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string nodes[MAX];</span><br><span class="line">    <span class="comment">//用于Prim算法的mat二维数组，dis数组和parent数组</span></span><br><span class="line">    <span class="type">int</span> mat[MAX][MAX];</span><br><span class="line">    <span class="type">int</span> dis[MAX];  </span><br><span class="line">    <span class="type">int</span> parent[MAX];    </span><br><span class="line">    <span class="comment">//用于Kruskal算法的最小堆（优先队列）和并查集</span></span><br><span class="line">    priority_queue&lt;Edge&gt; pq;    </span><br><span class="line">    Set *set;    </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// init nodes</span></span><br><span class="line">       std::cin&gt;&gt;n;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">           std::cin&gt;&gt;nodes[i];</span><br><span class="line">        <span class="comment">//init edges</span></span><br><span class="line">       <span class="built_in">memset</span>(mat, <span class="number">0</span>, <span class="built_in">sizeof</span>(mat));</span><br><span class="line">       std::cin&gt;&gt;m;</span><br><span class="line">       string node1, node2;</span><br><span class="line">       <span class="type">int</span> val;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">           std::cin&gt;&gt;node1&gt;&gt;node2&gt;&gt;val;</span><br><span class="line">           <span class="type">int</span> index1 = <span class="built_in">strToIndex</span>(node1), index2 = <span class="built_in">strToIndex</span>(node2);</span><br><span class="line">           /初始化mat二维数组</span><br><span class="line">           mat[index1][index2] = val;</span><br><span class="line">           mat[index2][index1] = val;</span><br><span class="line">           <span class="comment">//初始化优先队列</span></span><br><span class="line">           pq.<span class="built_in">push</span>(<span class="built_in">Edge</span>(index1, index2, val));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// init union-find-set</span></span><br><span class="line">       set = <span class="keyword">new</span> <span class="built_in">Set</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strToIndex</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>&#123;</span><br><span class="line">        <span class="comment">//找到字符串对应id</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            <span class="keyword">if</span>(str == nodes[i])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Edge* <span class="title">Prim</span><span class="params">(<span class="type">const</span> string&amp; start)</span></span>&#123;</span><br><span class="line">        <span class="comment">//上面已实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Edge *<span class="title">Kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//上面已实现</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">FindMST</span><span class="params">(<span class="type">const</span> string &amp;start)</span></span>&#123;</span><br><span class="line">        Edge *mst1 = <span class="built_in">Prim</span>(start);</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)</span><br><span class="line">            sum += mst1[i].val;</span><br><span class="line">        std::cout&lt;&lt;sum&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;prim:&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            std::cout&lt;&lt;nodes[mst1[i].index1]&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">                     &lt;&lt;nodes[mst1[i].index2]&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">                     &lt;&lt;mst1[i].val&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;kruskal:&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        Edge *mst2 = <span class="built_in">Kruskal</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;++i)&#123;</span><br><span class="line">            std::cout&lt;&lt;nodes[mst2[i].index1]&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">                     &lt;&lt;nodes[mst2[i].index2]&lt;&lt;<span class="string">&quot; &quot;</span></span><br><span class="line">                     &lt;&lt;mst2[i].val&lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Graph *graph = <span class="keyword">new</span> Graph;</span><br><span class="line">    graph-&gt;<span class="built_in">init</span>();</span><br><span class="line">    </span><br><span class="line">    string start;</span><br><span class="line">    std::cin&gt;&gt;start;</span><br><span class="line">    graph-&gt;<span class="built_in">FindMST</span>(start);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prim算法 </tag>
            
            <tag> Kruskal算法 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI导论实验之网格游戏（马尔可夫决策）</title>
      <link href="/2023/12/22/AI%E5%AF%BC%E8%AE%BA%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%BD%91%E6%A0%BC%E6%B8%B8%E6%88%8F%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%EF%BC%89/"/>
      <url>/2023/12/22/AI%E5%AF%BC%E8%AE%BA%E5%AE%9E%E9%AA%8C%E4%B9%8B%E7%BD%91%E6%A0%BC%E6%B8%B8%E6%88%8F%EF%BC%88%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="问题1：价值迭代"><a href="#问题1：价值迭代" class="headerlink" title="问题1：价值迭代"></a>问题1：价值迭代</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>实验来源于<a href="https://inst.eecs.berkeley.edu/~cs188/fa19/project3/">伯克利CS188</a>\<br>项目已将问题形式化为<strong>马尔可夫决策过程</strong>（Markov decision process，MDP），即MDP\<br>在 valueIterationAgents.py 中，ValueIterationAgent 类构造方法接收MDP（无折扣因子）及折扣因子\<br>我们需要做的是实现以下方法包括：</p><ul><li>runValueIteration: 执行价值迭代</li><li>computeActionFromValues(state)：根据self.values给出的值函数计算最佳行动</li><li>computeQValueFromValues(state, action)：返回根据self.values给出的值函数给出的（状态, 动作）对的Q值<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2></li></ul><p><a href="https://hrl.boyuai.com/chapter/1/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/#34-%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B">马尔可夫决策过程</a>由五元组$<S,A,P,r,γ>$构成，项目的MDP已经提供了以下接口：</p><ul><li>mdp.getStates()：获取MDP的所有状态</li><li>mdp.getPossibleActions(state)：当状态确定时，可能发生的所有动作</li><li>mdp.getTransitionStatesAndProbs(state, action)：当状态和动作确定时，所有可能的下一状态及其发生的概率</li><li>mdp.getReward(state, action, nextState)：当状态，动作及下一状态确定时，得到的即时回报</li><li>mdp.isTerminal(state)：判断状态是否为终止状态</li></ul><p>价值迭代算法\<br>对每个状态$s$, 找到动作$a$使动作价值最大为$Q_m$, 更新s对应的状态价值$V=Q_m$及对应的策略为$a$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 价值迭代模板</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runValueIteration</span>(<span class="params">self</span>):</span><br><span class="line">    delta = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        new_values = util.Counter()     <span class="comment"># new values after iteration</span></span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> self.mdp.getStates():</span><br><span class="line">            max_value = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> action <span class="keyword">in</span> self.mdp.getPossibleActions(state):</span><br><span class="line">                value = self.computeQValueFromValues(state=state, action=action)</span><br><span class="line">                max_value = <span class="built_in">max</span>(value, max_value)</span><br><span class="line">            new_values[state] = max_value <span class="keyword">if</span> max_value != -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            delta = <span class="built_in">max</span>(<span class="built_in">abs</span>(new_values[state] - self.values[state]), delta))</span><br><span class="line">        self.values = new_values        <span class="comment"># update values, also policy</span></span><br><span class="line">        <span class="keyword">if</span> self.theta &lt; delta:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 实验要求命令行输入迭代次数 -i &lt;iterations&gt;, 故修改为</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">runValueIteration</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.iterations):</span><br><span class="line">        new_values = util.Counter()     <span class="comment"># new values after iteration</span></span><br><span class="line">        <span class="keyword">for</span> state <span class="keyword">in</span> self.mdp.getStates():</span><br><span class="line">            max_value = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">            <span class="keyword">for</span> action <span class="keyword">in</span> self.mdp.getPossibleActions(state):</span><br><span class="line">                value = self.computeQValueFromValues(state=state, action=action)</span><br><span class="line">                max_value = <span class="built_in">max</span>(value, max_value)</span><br><span class="line">            new_values[state] = max_value <span class="keyword">if</span> max_value != -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>) <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            delta = <span class="built_in">max</span>(<span class="built_in">abs</span>(new_values[state] - self.values[state]), delta))</span><br><span class="line">        self.values = new_values        <span class="comment"># update values, also policy</span></span><br></pre></td></tr></table></figure><p>计算动作价值Q<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据公式应该使用的函数模板</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computeQValueFromValues</span>(<span class="params">self, state, action</span>):</span><br><span class="line">    <span class="built_in">sum</span> = self.mdp.getReward(state, action)</span><br><span class="line">    <span class="keyword">for</span> nextState, prob <span class="keyword">in</span> self.mdp.getTransitionStatesAndProbs(state=state, action=action):</span><br><span class="line">        <span class="built_in">sum</span> += self.discount * prob * self.getValue(nextState)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"><span class="comment"># 由于mdp提供的getReward需要三个参数state, action, nextState, 故修改为</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computeQValueFromValues</span>(<span class="params">self, state, action</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> nextState, prob <span class="keyword">in</span> self.mdp.getTransitionStatesAndProbs(state=state, action=action):</span><br><span class="line">        <span class="built_in">sum</span> += prob * </span><br><span class="line">            (self.mdp.getReward(state, action) + self.discount * self.getValue(nextState) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><br>根据state得到最好的action<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">computeActionFromValues</span>(<span class="params">self, state</span>):</span><br><span class="line">    max_value = -<span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">    best_action = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> action <span class="keyword">in</span> self.mdp.getPossibleActions(state):</span><br><span class="line">        <span class="comment"># 与价值迭代中求Q值最大的action类似</span></span><br><span class="line">        value = self.computeQValueFromValues(state=state, action=action)</span><br><span class="line">        <span class="keyword">if</span> value &gt; max_value:</span><br><span class="line">            best_action = action</span><br><span class="line">            max_value = value</span><br><span class="line">    <span class="keyword">return</span> best_action</span><br></pre></td></tr></table></figure></p><h1 id="问题2：过桥分析"><a href="#问题2：过桥分析" class="headerlink" title="问题2：过桥分析"></a>问题2：过桥分析</h1><p>由题，noise表示智能体在执行操作时以意外的后继状态结束的频率，有一定概率不遵循我们计算得到的策略。故将noise设置为0.0，即可通过测试。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">question2</span>():</span><br><span class="line">    answerDiscount = <span class="number">0.9</span></span><br><span class="line">    answerNoise = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">return</span> answerDiscount, answerNoise</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 强化学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java利用RMI实现http请求服务</title>
      <link href="/2023/12/17/Java%E5%88%A9%E7%94%A8RMI%E5%AE%9E%E7%8E%B0http%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1/"/>
      <url>/2023/12/17/Java%E5%88%A9%E7%94%A8RMI%E5%AE%9E%E7%8E%B0http%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、题目描述"><a href="#一、题目描述" class="headerlink" title="一、题目描述"></a>一、题目描述</h1><p>编写Java程序，实现RMI远程调用。客户端指定某个http网站，把这个网址传递给服务器端，服务器端提供http下载服务，通过http get 请求访问http网站，把对应的html文件返回给客户端</p><h1 id="二、实现思路"><a href="#二、实现思路" class="headerlink" title="二、实现思路"></a>二、实现思路</h1><h2 id="1-客户端"><a href="#1-客户端" class="headerlink" title="1. 客户端"></a>1. 客户端</h2><p>在GUI界面输入访问的网址，按下按钮提交请求\<br>监听按钮点击事件，引用远程访问的类，将处理结果反馈到文本框中</p><h2 id="2-服务器端"><a href="#2-服务器端" class="headerlink" title="2. 服务器端"></a>2. 服务器端</h2><p>定义服务接口，需要继承自Remote类\<br>定义实现服务接口的类，在类中编写业务逻辑，需要继承 UnicastRemoteObject 类\<br>在主函数中注册服务</p><h1 id="三、实现过程"><a href="#三、实现过程" class="headerlink" title="三、实现过程"></a>三、实现过程</h1><h2 id="1-客户端-1"><a href="#1-客户端-1" class="headerlink" title="1. 客户端"></a>1. 客户端</h2><p>编写基本的GUI界面(不熟。。要是写前端三件套就好了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">RMIClient</span>(<span class="string">&quot;Client&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RMIClient</span><span class="params">(String <span class="keyword">var</span>)</span>&#123;  </span><br><span class="line">        <span class="built_in">super</span>(<span class="keyword">var</span>);  </span><br><span class="line">        <span class="built_in">this</span>.setSize(<span class="number">1000</span>, <span class="number">1500</span>);  </span><br><span class="line">        <span class="built_in">this</span>.setTitle(<span class="string">&quot;RAMClient&quot;</span>);  </span><br><span class="line"></span><br><span class="line">        <span class="type">JPanel</span> <span class="variable">jp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();  </span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">jl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;Please type the URL you want to visit: &quot;</span>);  </span><br><span class="line">        <span class="type">JTextField</span> <span class="variable">jt1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">30</span>);  </span><br><span class="line">        <span class="type">JButton</span> <span class="variable">jb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Confirm&quot;</span>);  </span><br><span class="line">        jp1.add(jl1);  </span><br><span class="line">        jp1.add(jt1);  </span><br><span class="line">        jp1.add(jb1);  </span><br><span class="line"></span><br><span class="line">        <span class="type">JTextArea</span> <span class="variable">jTextArea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextArea</span>();  </span><br><span class="line">        jTextArea.setSize(<span class="number">250</span>, <span class="number">1200</span>);  </span><br><span class="line">        jTextArea.setEditable(<span class="literal">false</span>);  </span><br><span class="line">        <span class="type">JScrollPane</span> <span class="variable">sp</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">JScrollPane</span>();  </span><br><span class="line">        sp.setViewportView(jTextArea);</span><br></pre></td></tr></table></figure><br>监听JButton事件，将返回数据逐行添加到JTextArea<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">jb1.addActionListener((e)-&gt;&#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> jt1.getText();  </span><br><span class="line">    File htmlFile;  </span><br><span class="line">    <span class="comment">// lookup method to find reference  </span></span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">        <span class="type">DownloadService</span> <span class="variable">access</span> <span class="operator">=</span> (DownloadService) Naming.lookup(<span class="string">&quot;rmi://localhost:1099/download&quot;</span>);  </span><br><span class="line">        htmlFile = access.getHTMLfile(input);  </span><br><span class="line">        <span class="keyword">if</span>(htmlFile != <span class="literal">null</span>)&#123;  </span><br><span class="line">            <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(htmlFile));  </span><br><span class="line">            <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="keyword">while</span>((temp = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;  </span><br><span class="line">                jTextArea.append(temp+<span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">                <span class="comment">//System.out.println(temp+&#x27;\n&#x27;);  </span></span><br><span class="line">            &#125;  </span><br><span class="line">            bufferedReader.close();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception err)&#123;  </span><br><span class="line">        err.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>将组件添加到JFrame中并显示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        <span class="built_in">this</span>.setLayout(<span class="keyword">new</span> <span class="title class_">GridLayout</span>(<span class="number">3</span>, <span class="number">4</span>));  </span><br><span class="line">        <span class="built_in">this</span>.add(jp1);  </span><br><span class="line">        <span class="built_in">this</span>.add(sp);  </span><br><span class="line">        <span class="built_in">this</span>.setVisible(<span class="literal">true</span>);  </span><br><span class="line">        <span class="built_in">this</span>.pack();  </span><br><span class="line">        <span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-服务器端-1"><a href="#2-服务器端-1" class="headerlink" title="2. 服务器端"></a>2. 服务器端</h2><p>定义服务接口DownloadService<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DownloadService</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> &#123;  </span><br><span class="line">    File <span class="title function_">getHTMLfile</span><span class="params">(String urlStr)</span> <span class="keyword">throws</span> RemoteException, MalformedURLException;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>定义实现上述接口的服务类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownloadServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">DownloadService</span> &#123;  </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">DownloadServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException&#123;  </span><br><span class="line">        <span class="built_in">super</span>();  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><br>初始化Http连接对象以及响应文件对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">getHTMLfile</span><span class="params">(String urlStr)</span> <span class="keyword">throws</span> RemoteException, MalformedURLException &#123;  </span><br><span class="line">    <span class="comment">// initialization  </span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;result.html&quot;</span>);  </span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fileWriter</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span>(!file.exists())&#123;  </span><br><span class="line">            file.createNewFile();  </span><br><span class="line">        &#125;  </span><br><span class="line">        fileWriter = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file);  </span><br><span class="line">    &#125;<span class="keyword">catch</span> (IOException e)&#123;  </span><br><span class="line">        e.printStackTrace();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br></pre></td></tr></table></figure><br>建立连接，逐行读取返回的HTML响应，保存到文件中<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// create connection  </span></span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(urlStr);  </span><br><span class="line">            conn = (HttpURLConnection) url.openConnection();  </span><br><span class="line">            conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);  </span><br><span class="line">            conn.setConnectTimeout(<span class="number">12000</span>);  </span><br><span class="line">            conn.connect();  </span><br><span class="line">            System.out.println(<span class="string">&quot;Wait for response&quot;</span>);  </span><br><span class="line">            <span class="keyword">if</span>(conn.getResponseCode() == <span class="number">200</span>)&#123;  </span><br><span class="line">                <span class="comment">// if conn success  </span></span><br><span class="line">                inputStream = conn.getInputStream();  </span><br><span class="line">                <span class="keyword">if</span> (inputStream != <span class="literal">null</span>)&#123;  </span><br><span class="line">                    bufferedReader = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">&quot;UTF-8&quot;</span>));  </span><br><span class="line">                    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">                    <span class="keyword">while</span>((temp = bufferedReader.readLine())!= <span class="literal">null</span>)&#123;  </span><br><span class="line">                        fileWriter.write(temp);  </span><br><span class="line">                        fileWriter.write(<span class="string">&#x27;\n&#x27;</span>);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    fileWriter.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> file;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在主函数中注册服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            <span class="type">DownloadService</span> <span class="variable">downloadService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DownloadServiceImpl</span>();  </span><br><span class="line">            LocateRegistry.createRegistry(<span class="number">1099</span>);  </span><br><span class="line">            Naming.rebind(<span class="string">&quot;rmi://localhost:1099/download&quot;</span>, downloadService);  </span><br><span class="line">            System.out.println(<span class="string">&quot;Server is ready!&quot;</span>);  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="三、运行结果"><a href="#三、运行结果" class="headerlink" title="三、运行结果"></a>三、运行结果</h1><p>启动服务端<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">idea</span> <span class="title">project</span>\<span class="title">javaCourrse</span>\<span class="title">javaEX6</span>\<span class="title">javaEX6</span>\<span class="title">src</span>&gt;<span class="title">java</span> <span class="title">RMIdemo</span>/<span class="title">RMIServer</span></span></span><br><span class="line"><span class="function"><span class="title">Server</span> <span class="title">is</span> <span class="title">ready</span>!</span></span><br></pre></td></tr></table></figure><br>启动客户端<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">D:\<span class="title">idea</span> <span class="title">project</span>\<span class="title">javaCourrse</span>\<span class="title">javaEX6</span>\<span class="title">javaEX6</span>\<span class="title">src</span>&gt;<span class="title">java</span> <span class="title">RMIdemo</span>/<span class="title">RMIClient</span></span></span><br></pre></td></tr></table></figure></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ddf754dff32644dcb632deb737b69fff~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=771&amp;h=371&amp;s=16584&amp;e=png&amp;b=f5f5f5" alt="image.png"><br>输入网址并点击按钮<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa20d157c3074b199839f6334863ecbb~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=771&amp;h=354&amp;s=24419&amp;e=png&amp;b=f4f4f4" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> RMI </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java利用UDP实现客户端之间通信</title>
      <link href="/2023/12/17/Java%E5%88%A9%E7%94%A8UDP%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2023/12/17/Java%E5%88%A9%E7%94%A8UDP%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B9%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>利用数据报通信方式编写一程序，该程序生成两个客户端，一个服务器端，两个客户端可以相互进行简短的文字交流。</p><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>为使客户端能够接收到其他客户端的数据报，客户端在创建时应该<strong>指定端口号</strong>，开启接收数据的线程和等待发送消息的线程，当接收到数据或发送数据后，重启线程。并且发送方在数据报中应包含接收端的地址，由服务器端对地址进行解析并转达数据包。</p><h1 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h1><h2 id="1-服务器端："><a href="#1-服务器端：" class="headerlink" title="1. 服务器端："></a>1. 服务器端：</h2><p>在Server.java中实现Server类，静态变量指定服务器端口，接收数据报的大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">8000</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">packetSize</span> <span class="operator">=</span> <span class="number">1024</span>;  </span><br></pre></td></tr></table></figure><p>进入主函数时，初始化数据报套接字及接收数据报</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(serverPort);  </span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[packetSize];  </span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, packetSize);  </span><br><span class="line">        System.out.println(<span class="string">&quot;server is ready!!&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用死循环处理每一个客户端发送的数据报;\<br>将数据报分割为地址及信息两部分;\<br>根据地址及信息创建新数据报，并发送到目标客户端，完成对消息的转述</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">    server.receive(packet);  </span><br><span class="line">    System.out.println(<span class="string">&quot;server has received data from sender&quot;</span>);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">dataStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(data, <span class="number">0</span>, packet.getLength());  </span><br><span class="line">    String[] dataSegments = dataStr.split(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">    <span class="keyword">if</span>(dataSegments.length &gt;= <span class="number">2</span>)&#123;  </span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">receiverAddress</span> <span class="operator">=</span> InetAddress.getByName(dataSegments[<span class="number">0</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">receiverPort</span> <span class="operator">=</span> Integer.parseInt(dataSegments[<span class="number">0</span>].split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>]);  </span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">trulyData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(dataSegments[<span class="number">1</span>].getBytes(),  </span><br><span class="line">        dataSegments[<span class="number">1</span>].length(), receiverAddress, receiverPort);  </span><br><span class="line">        System.out.println(<span class="string">&quot;the message: &quot;</span>+dataSegments[<span class="number">1</span>]);  </span><br><span class="line">        server.send(trulyData);  </span><br><span class="line">        System.out.println(<span class="string">&quot;server has sent data to receiver&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-客户端"><a href="#2-客户端" class="headerlink" title="2. 客户端"></a>2. 客户端</h2><p>客户端在创建时需指定端口号，这里使用命令行参数传入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="type">int</span> port;  </span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            port = Integer.parseInt(args[<span class="number">0</span>]);  </span><br><span class="line">            <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(port);  </span><br><span class="line">            System.out.println(<span class="string">&quot;client is ready!!&quot;</span>);</span><br></pre></td></tr></table></figure><p>创建接收消息的线程及发送消息的线程等待输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">            <span class="comment">// create a receiver thread  </span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">receiveThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ReceiverRunnable</span>(socket));  </span><br><span class="line">            receiveThread.start(); <span class="comment">// receive message at any time  </span></span><br><span class="line">            <span class="comment">// create a sender thread  </span></span><br><span class="line">            <span class="type">Thread</span> <span class="variable">sendThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientSenderRunnable</span>(socket));  </span><br><span class="line">            sendThread.start();  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;you must indicate the port by adding argument&quot;</span>);  </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）接收消息的线程</p><p>在Receiver.java中实现一个实现Runnable接口的可执行类\<br>在构造方法中传入客户端数据报套接字，初始化接收端\<br>在静态变量中定义数据报大小，以及接收数据报的字符数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReceiverRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">dataSize</span> <span class="operator">=</span> <span class="number">1024</span>;  </span><br><span class="line">    DatagramPacket receivePacket;  </span><br><span class="line">    <span class="type">byte</span>[] data;  </span><br><span class="line">    <span class="keyword">public</span> DatagramSocket socket;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReceiverRunnable</span><span class="params">(DatagramSocket socket)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.socket = socket;  </span><br><span class="line">        data = <span class="keyword">new</span> <span class="title class_">byte</span>[dataSize];  </span><br><span class="line">        receivePacket = <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, dataSize);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重写run方法，接收数据报并打印消息\<br>在线程终点启动下一个接收消息的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            socket.receive(receivePacket);  </span><br><span class="line">            System.out.println(<span class="string">&quot;You have received a message: &quot;</span>+<span class="keyword">new</span> <span class="title class_">String</span>(data, dataSize));  </span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ReceiverRunnable</span>(socket));  </span><br><span class="line">            thread.start();  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;  </span><br><span class="line">            e.fillInStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）发送消息的线程</p><p>在ClientSenderRunnable.java中实现一个实现Runnable接口的可执行类\<br>在构造方法中传入客户端数据报套接字，初始化发送端\<br>在静态变量中指定服务器地址及端口，用于初始化数据报</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientSenderRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">serverName</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">8000</span>;  </span><br><span class="line">    <span class="keyword">public</span> DatagramSocket socket;  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientSenderRunnable</span><span class="params">(DatagramSocket socket)</span>&#123;  </span><br><span class="line">        <span class="built_in">this</span>.socket = socket;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重写run方法，读取键盘输入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;type as (address:port message):&quot;</span>);  </span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">    String dataStr;  </span><br><span class="line">    <span class="keyword">if</span> (scanner.hasNextLine()) &#123;  </span><br><span class="line">        dataStr = scanner.nextLine();  </span><br><span class="line">        System.out.println(<span class="string">&quot;your header and message: &quot;</span> + dataStr);  </span><br><span class="line">        <span class="type">byte</span>[] data = dataStr.getBytes();</span><br></pre></td></tr></table></figure><p>根据静态变量指定的服务端地址打包数据报并发送</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pack up the data  </span></span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="type">InetAddress</span> <span class="variable">serverAddress</span> <span class="operator">=</span> InetAddress.getByName(serverName);  </span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data, data.length, serverAddress, serverPort);  </span><br><span class="line">                <span class="comment">// create socket and send data packed  </span></span><br><span class="line">                socket.send(packet);  </span><br><span class="line">                System.out.println(<span class="string">&quot;client has sent data to server!!&quot;</span>);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在线程终点启动下一个发送消息的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">ClientSenderRunnable</span>(socket));  </span><br><span class="line">        thread.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p>启动服务端<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/279f6e561c7041b09a71efc24a4ba2b6~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667\&amp;h=74\&amp;s=197908\&amp;e=png\&amp;b=0d0d0d" alt="image.png"></p><p>启动两个客户端<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd72f59f5de74c16ae9a8baa6cf850de~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=74&amp;s=197908&amp;e=png&amp;b=0d0d0d" alt="image.png"><br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a946f76f3604fb2b7a8b0a7b37b728a~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=74&amp;s=197908&amp;e=png&amp;b=0d0d0d" alt="image.png"> </p><p>由客户端一(8001端口)向客户端二(8002端口)发送消息<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b13a7bd3fb643deae42af910a4686a9~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=167&amp;s=446520&amp;e=png&amp;b=0c0c0c" alt="image.png"></p><p>服务器端成功接收到消息并转发<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e054e46df9e04c0d9bb5c9e119351f6e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=122&amp;s=326220&amp;e=png&amp;b=0c0c0c" alt="image.png"></p><p>客户端二(8002端口)成功监听到接收的消息<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2559eac5a5de4915ab83f0dd84c1aa0f~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=106&amp;s=283451&amp;e=png&amp;b=0d0d0d" alt="image.png"></p><p>同理，由客户端二向客户端一发送消息也同样得以完成</p><p>客户端二：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d10d3f78c39d492fadc0b0f18c78ee7c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=667&amp;h=106&amp;s=283451&amp;e=png&amp;b=0d0d0d" alt="image.png"></p><p>服务器端：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bde43b7626314dcda64a63d90cbcfed5~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=476&amp;h=74&amp;s=141283&amp;e=png&amp;b=0c0c0c" alt="image.png"></p><p>客户端一：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b78f1f8ebb674a1e9cb1dc3722f16c04~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=492&amp;h=27&amp;s=53329&amp;e=png&amp;b=0c0c0c" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 课程实验 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> UDP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
